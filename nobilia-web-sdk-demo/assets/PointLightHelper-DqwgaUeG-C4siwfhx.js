import{g as I,U as ht,E as et,p as x,d as at,_ as nt,W as ot,L as G,G as ct,l as lt,y as ut,a as yt,F as K,b as pt,N as dt}from"./BufferGeometry-DF44aTDz-B_l4TPCu.js";class q{constructor(t=0,s=0,i=0,e=1){q.prototype.isVector4=!0,this.x=t,this.y=s,this.z=i,this.w=e}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,s,i,e){return this.x=t,this.y=s,this.z=i,this.w=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;case 3:this.w=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this.w=t.w+s.w,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this.w+=t.w*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this.w=t.w-s.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const s=this.x,i=this.y,e=this.z,h=this.w,r=t.elements;return this.x=r[0]*s+r[4]*i+r[8]*e+r[12]*h,this.y=r[1]*s+r[5]*i+r[9]*e+r[13]*h,this.z=r[2]*s+r[6]*i+r[10]*e+r[14]*h,this.w=r[3]*s+r[7]*i+r[11]*e+r[15]*h,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const s=Math.sqrt(1-t.w*t.w);return s<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/s,this.y=t.y/s,this.z=t.z/s),this}setAxisAngleFromRotationMatrix(t){let s,i,e,h;const r=t.elements,n=r[0],a=r[4],l=r[8],o=r[1],u=r[5],w=r[9],p=r[2],y=r[6],f=r[10];if(Math.abs(a-o)<.01&&Math.abs(l-p)<.01&&Math.abs(w-y)<.01){if(Math.abs(a+o)<.1&&Math.abs(l+p)<.1&&Math.abs(w+y)<.1&&Math.abs(n+u+f-3)<.1)return this.set(1,0,0,0),this;s=Math.PI;const d=(n+1)/2,g=(u+1)/2,M=(f+1)/2,m=(a+o)/4,z=(l+p)/4,b=(w+y)/4;return d>g&&d>M?d<.01?(i=0,e=.707106781,h=.707106781):(i=Math.sqrt(d),e=m/i,h=z/i):g>M?g<.01?(i=.707106781,e=0,h=.707106781):(e=Math.sqrt(g),i=m/e,h=b/e):M<.01?(i=.707106781,e=.707106781,h=0):(h=Math.sqrt(M),i=z/h,e=b/h),this.set(i,e,h,s),this}let c=Math.sqrt((y-w)*(y-w)+(l-p)*(l-p)+(o-a)*(o-a));return Math.abs(c)<.001&&(c=1),this.x=(y-w)/c,this.y=(l-p)/c,this.z=(o-a)/c,this.w=Math.acos((n+u+f-1)/2),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this.w=s[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,s){return this.x=I(this.x,t.x,s.x),this.y=I(this.y,t.y,s.y),this.z=I(this.z,t.z,s.z),this.w=I(this.w,t.w,s.w),this}clampScalar(t,s){return this.x=I(this.x,t,s),this.y=I(this.y,t,s),this.z=I(this.z,t,s),this.w=I(this.w,t,s),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(I(i,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this.w+=(t.w-this.w)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this.w=t.w+(s.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this.w=t[s+3],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t[s+3]=this.w,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this.w=t.getW(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}const S=new x,v=new x,O=new x,T=new x,L=new x,P=new x,_=new x,$=new x,C=new x,U=new x,Z=new q,H=new q,J=new q;class V{constructor(t=new x,s=new x,i=new x){this.a=t,this.b=s,this.c=i}static getNormal(t,s,i,e){e.subVectors(i,s),S.subVectors(t,s),e.cross(S);const h=e.lengthSq();return h>0?e.multiplyScalar(1/Math.sqrt(h)):e.set(0,0,0)}static getBarycoord(t,s,i,e,h){S.subVectors(e,s),v.subVectors(i,s),O.subVectors(t,s);const r=S.dot(S),n=S.dot(v),a=S.dot(O),l=v.dot(v),o=v.dot(O),u=r*l-n*n;if(u===0)return h.set(0,0,0),null;const w=1/u,p=(l*a-n*o)*w,y=(r*o-n*a)*w;return h.set(1-p-y,y,p)}static containsPoint(t,s,i,e){return this.getBarycoord(t,s,i,e,T)===null?!1:T.x>=0&&T.y>=0&&T.x+T.y<=1}static getInterpolation(t,s,i,e,h,r,n,a){return this.getBarycoord(t,s,i,e,T)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(h,T.x),a.addScaledVector(r,T.y),a.addScaledVector(n,T.z),a)}static getInterpolatedAttribute(t,s,i,e,h,r){return Z.setScalar(0),H.setScalar(0),J.setScalar(0),Z.fromBufferAttribute(t,s),H.fromBufferAttribute(t,i),J.fromBufferAttribute(t,e),r.setScalar(0),r.addScaledVector(Z,h.x),r.addScaledVector(H,h.y),r.addScaledVector(J,h.z),r}static isFrontFacing(t,s,i,e){return S.subVectors(i,s),v.subVectors(t,s),S.cross(v).dot(e)<0}set(t,s,i){return this.a.copy(t),this.b.copy(s),this.c.copy(i),this}setFromPointsAndIndices(t,s,i,e){return this.a.copy(t[s]),this.b.copy(t[i]),this.c.copy(t[e]),this}setFromAttributeAndIndices(t,s,i,e){return this.a.fromBufferAttribute(t,s),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,e),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return S.subVectors(this.c,this.b),v.subVectors(this.a,this.b),S.cross(v).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return V.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,s){return V.getBarycoord(t,this.a,this.b,this.c,s)}getInterpolation(t,s,i,e,h){return V.getInterpolation(t,this.a,this.b,this.c,s,i,e,h)}containsPoint(t){return V.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return V.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,s){const i=this.a,e=this.b,h=this.c;let r,n;L.subVectors(e,i),P.subVectors(h,i),$.subVectors(t,i);const a=L.dot($),l=P.dot($);if(a<=0&&l<=0)return s.copy(i);C.subVectors(t,e);const o=L.dot(C),u=P.dot(C);if(o>=0&&u<=o)return s.copy(e);const w=a*u-o*l;if(w<=0&&a>=0&&o<=0)return r=a/(a-o),s.copy(i).addScaledVector(L,r);U.subVectors(t,h);const p=L.dot(U),y=P.dot(U);if(y>=0&&p<=y)return s.copy(h);const f=p*l-a*y;if(f<=0&&l>=0&&y<=0)return n=l/(l-y),s.copy(i).addScaledVector(P,n);const c=o*y-p*u;if(c<=0&&u-o>=0&&p-y>=0)return _.subVectors(h,e),n=(u-o)/(u-o+(p-y)),s.copy(e).addScaledVector(_,n);const d=1/(c+f+w);return r=f*d,n=w*d,s.copy(i).addScaledVector(L,r).addScaledVector(P,n)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class rt extends ct{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ut,this.combine=yt,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const tt=new ot,B=new nt,F=new at,st=new x,R=new x,W=new x,j=new x,Y=new x,N=new x,it=new x,X=new x;class mt extends ht{constructor(t=new et,s=new rt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=s,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,s){return super.copy(t,s),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,h=i.length;e<h;e++){const r=i[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=e}}}}getVertexPosition(t,s){const i=this.geometry,e=i.attributes.position,h=i.morphAttributes.position,r=i.morphTargetsRelative;s.fromBufferAttribute(e,t);const n=this.morphTargetInfluences;if(h&&n){N.set(0,0,0);for(let a=0,l=h.length;a<l;a++){const o=n[a],u=h[a];o!==0&&(Y.fromBufferAttribute(u,t),r?N.addScaledVector(Y,o):N.addScaledVector(Y.sub(s),o))}s.add(N)}return s}raycast(t,s){const i=this.geometry,e=this.material,h=this.matrixWorld;e!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),F.copy(i.boundingSphere),F.applyMatrix4(h),B.copy(t.ray).recast(t.near),!(F.containsPoint(B.origin)===!1&&(B.intersectSphere(F,st)===null||B.origin.distanceToSquared(st)>(t.far-t.near)**2))&&(tt.copy(h).invert(),B.copy(t.ray).applyMatrix4(tt),!(i.boundingBox!==null&&B.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(t,s,B)))}_computeIntersections(t,s,i){let e;const h=this.geometry,r=this.material,n=h.index,a=h.attributes.position,l=h.attributes.uv,o=h.attributes.uv1,u=h.attributes.normal,w=h.groups,p=h.drawRange;if(n!==null)if(Array.isArray(r))for(let y=0,f=w.length;y<f;y++){const c=w[y],d=r[c.materialIndex],g=Math.max(c.start,p.start),M=Math.min(n.count,Math.min(c.start+c.count,p.start+p.count));for(let m=g,z=M;m<z;m+=3){const b=n.getX(m),k=n.getX(m+1),E=n.getX(m+2);e=D(this,d,t,i,l,o,u,b,k,E),e&&(e.faceIndex=Math.floor(m/3),e.face.materialIndex=c.materialIndex,s.push(e))}}else{const y=Math.max(0,p.start),f=Math.min(n.count,p.start+p.count);for(let c=y,d=f;c<d;c+=3){const g=n.getX(c),M=n.getX(c+1),m=n.getX(c+2);e=D(this,r,t,i,l,o,u,g,M,m),e&&(e.faceIndex=Math.floor(c/3),s.push(e))}}else if(a!==void 0)if(Array.isArray(r))for(let y=0,f=w.length;y<f;y++){const c=w[y],d=r[c.materialIndex],g=Math.max(c.start,p.start),M=Math.min(a.count,Math.min(c.start+c.count,p.start+p.count));for(let m=g,z=M;m<z;m+=3){const b=m,k=m+1,E=m+2;e=D(this,d,t,i,l,o,u,b,k,E),e&&(e.faceIndex=Math.floor(m/3),e.face.materialIndex=c.materialIndex,s.push(e))}}else{const y=Math.max(0,p.start),f=Math.min(a.count,p.start+p.count);for(let c=y,d=f;c<d;c+=3){const g=c,M=c+1,m=c+2;e=D(this,r,t,i,l,o,u,g,M,m),e&&(e.faceIndex=Math.floor(c/3),s.push(e))}}}}function wt(A,t,s,i,e,h,r,n){let a;if(t.side===pt?a=i.intersectTriangle(r,h,e,!0,n):a=i.intersectTriangle(e,h,r,t.side===dt,n),a===null)return null;X.copy(n),X.applyMatrix4(A.matrixWorld);const l=s.ray.origin.distanceTo(X);return l<s.near||l>s.far?null:{distance:l,point:X.clone(),object:A}}function D(A,t,s,i,e,h,r,n,a,l){A.getVertexPosition(n,R),A.getVertexPosition(a,W),A.getVertexPosition(l,j);const o=wt(A,t,s,i,R,W,j,it);if(o){const u=new x;V.getBarycoord(it,R,W,j,u),e&&(o.uv=V.getInterpolatedAttribute(e,n,a,l,u,new K)),h&&(o.uv1=V.getInterpolatedAttribute(h,n,a,l,u,new K)),r&&(o.normal=V.getInterpolatedAttribute(r,n,a,l,u,new x),o.normal.dot(i.direction)>0&&o.normal.multiplyScalar(-1));const w={a:n,b:a,c:l,normal:new x,materialIndex:0};V.getNormal(R,W,j,w.normal),o.face=w,o.barycoord=u}return o}class Q extends et{constructor(t=1,s=32,i=16,e=0,h=Math.PI*2,r=0,n=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:s,heightSegments:i,phiStart:e,phiLength:h,thetaStart:r,thetaLength:n},s=Math.max(3,Math.floor(s)),i=Math.max(2,Math.floor(i));const a=Math.min(r+n,Math.PI);let l=0;const o=[],u=new x,w=new x,p=[],y=[],f=[],c=[];for(let d=0;d<=i;d++){const g=[],M=d/i;let m=0;d===0&&r===0?m=.5/s:d===i&&a===Math.PI&&(m=-.5/s);for(let z=0;z<=s;z++){const b=z/s;u.x=-t*Math.cos(e+b*h)*Math.sin(r+M*n),u.y=t*Math.cos(r+M*n),u.z=t*Math.sin(e+b*h)*Math.sin(r+M*n),y.push(u.x,u.y,u.z),w.copy(u).normalize(),f.push(w.x,w.y,w.z),c.push(b+m,1-M),g.push(l++)}o.push(g)}for(let d=0;d<i;d++)for(let g=0;g<s;g++){const M=o[d][g+1],m=o[d][g],z=o[d+1][g],b=o[d+1][g+1];(d!==0||r>0)&&p.push(M,m,b),(d!==i-1||a<Math.PI)&&p.push(m,z,b)}this.setIndex(p),this.setAttribute("position",new G(y,3)),this.setAttribute("normal",new G(f,3)),this.setAttribute("uv",new G(c,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Q(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class gt extends mt{constructor(t,s,i){const e=new Q(s,4,2),h=new rt({wireframe:!0,fog:!1,toneMapped:!1});super(e,h),this.light=t,this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}export{gt as PointLightHelper};
