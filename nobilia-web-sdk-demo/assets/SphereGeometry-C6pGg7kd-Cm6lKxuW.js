import{j as st,X as d,Q as it,o as at,af as nt,c8 as ot,u as Y,z as ct,A as ht,q as K}from"./index-vzMrgKlp.js";import{D as et,j as lt,L as Q,Q as ut,d as pt}from"./BufferGeometry-Bn0KB3W4-DM3rF_S1.js";const x=new d,B=new d,k=new d,T=new d,P=new d,L=new d,Z=new d,G=new d,J=new d,W=new d,C=new K,$=new K,E=new K;class I{constructor(t=new d,e=new d,s=new d){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,r){r.subVectors(s,e),x.subVectors(t,e),r.cross(x);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,s,r,i){x.subVectors(r,e),B.subVectors(s,e),k.subVectors(t,e);const o=x.dot(x),n=x.dot(B),a=x.dot(k),u=B.dot(B),c=B.dot(k),l=o*u-n*n;if(l===0)return i.set(0,0,0),null;const y=1/l,m=(u*a-n*c)*y,p=(o*c-n*a)*y;return i.set(1-m-p,p,m)}static containsPoint(t,e,s,r){return this.getBarycoord(t,e,s,r,T)===null?!1:T.x>=0&&T.y>=0&&T.x+T.y<=1}static getInterpolation(t,e,s,r,i,o,n,a){return this.getBarycoord(t,e,s,r,T)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(i,T.x),a.addScaledVector(o,T.y),a.addScaledVector(n,T.z),a)}static getInterpolatedAttribute(t,e,s,r,i,o){return C.setScalar(0),$.setScalar(0),E.setScalar(0),C.fromBufferAttribute(t,e),$.fromBufferAttribute(t,s),E.fromBufferAttribute(t,r),o.setScalar(0),o.addScaledVector(C,i.x),o.addScaledVector($,i.y),o.addScaledVector(E,i.z),o}static isFrontFacing(t,e,s,r){return x.subVectors(s,e),B.subVectors(t,e),x.cross(B).dot(r)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,r){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,s,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return x.subVectors(this.c,this.b),B.subVectors(this.a,this.b),x.cross(B).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return I.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return I.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,r,i){return I.getInterpolation(t,this.a,this.b,this.c,e,s,r,i)}containsPoint(t){return I.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return I.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,r=this.b,i=this.c;let o,n;P.subVectors(r,s),L.subVectors(i,s),G.subVectors(t,s);const a=P.dot(G),u=L.dot(G);if(a<=0&&u<=0)return e.copy(s);J.subVectors(t,r);const c=P.dot(J),l=L.dot(J);if(c>=0&&l<=c)return e.copy(r);const y=a*l-c*u;if(y<=0&&a>=0&&c<=0)return o=a/(a-c),e.copy(s).addScaledVector(P,o);W.subVectors(t,i);const m=P.dot(W),p=L.dot(W);if(p>=0&&m<=p)return e.copy(i);const M=m*u-a*p;if(M<=0&&u>=0&&p<=0)return n=u/(u-p),e.copy(s).addScaledVector(L,n);const h=c*p-m*l;if(h<=0&&l-c>=0&&m-p>=0)return Z.subVectors(i,r),n=(l-c)/(l-c+(m-p)),e.copy(r).addScaledVector(Z,n);const f=1/(h+M+y);return o=M*f,n=y*f,e.copy(s).addScaledVector(P,o).addScaledVector(L,n)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class dt extends ut{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new pt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new nt,this.combine=ot,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const U=new at,v=new lt,j=new it,_=new d,X=new d,z=new d,F=new d,H=new d,q=new d,tt=new d,D=new d;class yt extends st{constructor(t=new et,e=new dt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const s=t[e[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,i=s.length;r<i;r++){const o=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}getVertexPosition(t,e){const s=this.geometry,r=s.attributes.position,i=s.morphAttributes.position,o=s.morphTargetsRelative;e.fromBufferAttribute(r,t);const n=this.morphTargetInfluences;if(i&&n){q.set(0,0,0);for(let a=0,u=i.length;a<u;a++){const c=n[a],l=i[a];c!==0&&(H.fromBufferAttribute(l,t),o?q.addScaledVector(H,c):q.addScaledVector(H.sub(e),c))}e.add(q)}return e}raycast(t,e){const s=this.geometry,r=this.material,i=this.matrixWorld;r!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),j.copy(s.boundingSphere),j.applyMatrix4(i),v.copy(t.ray).recast(t.near),!(j.containsPoint(v.origin)===!1&&(v.intersectSphere(j,_)===null||v.origin.distanceToSquared(_)>(t.far-t.near)**2))&&(U.copy(i).invert(),v.copy(t.ray).applyMatrix4(U),!(s.boundingBox!==null&&v.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(t,e,v)))}_computeIntersections(t,e,s){let r;const i=this.geometry,o=this.material,n=i.index,a=i.attributes.position,u=i.attributes.uv,c=i.attributes.uv1,l=i.attributes.normal,y=i.groups,m=i.drawRange;if(n!==null)if(Array.isArray(o))for(let p=0,M=y.length;p<M;p++){const h=y[p],f=o[h.materialIndex],b=Math.max(h.start,m.start),w=Math.min(n.count,Math.min(h.start+h.count,m.start+m.count));for(let g=b,V=w;g<V;g+=3){const S=n.getX(g),N=n.getX(g+1),O=n.getX(g+2);r=R(this,f,t,s,u,c,l,S,N,O),r&&(r.faceIndex=Math.floor(g/3),r.face.materialIndex=h.materialIndex,e.push(r))}}else{const p=Math.max(0,m.start),M=Math.min(n.count,m.start+m.count);for(let h=p,f=M;h<f;h+=3){const b=n.getX(h),w=n.getX(h+1),g=n.getX(h+2);r=R(this,o,t,s,u,c,l,b,w,g),r&&(r.faceIndex=Math.floor(h/3),e.push(r))}}else if(a!==void 0)if(Array.isArray(o))for(let p=0,M=y.length;p<M;p++){const h=y[p],f=o[h.materialIndex],b=Math.max(h.start,m.start),w=Math.min(a.count,Math.min(h.start+h.count,m.start+m.count));for(let g=b,V=w;g<V;g+=3){const S=g,N=g+1,O=g+2;r=R(this,f,t,s,u,c,l,S,N,O),r&&(r.faceIndex=Math.floor(g/3),r.face.materialIndex=h.materialIndex,e.push(r))}}else{const p=Math.max(0,m.start),M=Math.min(a.count,m.start+m.count);for(let h=p,f=M;h<f;h+=3){const b=h,w=h+1,g=h+2;r=R(this,o,t,s,u,c,l,b,w,g),r&&(r.faceIndex=Math.floor(h/3),e.push(r))}}}}function mt(A,t,e,s,r,i,o,n){let a;if(t.side===ct?a=s.intersectTriangle(o,i,r,!0,n):a=s.intersectTriangle(r,i,o,t.side===ht,n),a===null)return null;D.copy(n),D.applyMatrix4(A.matrixWorld);const u=e.ray.origin.distanceTo(D);return u<e.near||u>e.far?null:{distance:u,point:D.clone(),object:A}}function R(A,t,e,s,r,i,o,n,a,u){A.getVertexPosition(n,X),A.getVertexPosition(a,z),A.getVertexPosition(u,F);const c=mt(A,t,e,s,X,z,F,tt);if(c){const l=new d;I.getBarycoord(tt,X,z,F,l),r&&(c.uv=I.getInterpolatedAttribute(r,n,a,u,l,new Y)),i&&(c.uv1=I.getInterpolatedAttribute(i,n,a,u,l,new Y)),o&&(c.normal=I.getInterpolatedAttribute(o,n,a,u,l,new d),c.normal.dot(s.direction)>0&&c.normal.multiplyScalar(-1));const y={a:n,b:a,c:u,normal:new d,materialIndex:0};I.getNormal(X,z,F,y.normal),c.face=y,c.barycoord=l}return c}class rt extends et{constructor(t=1,e=32,s=16,r=0,i=Math.PI*2,o=0,n=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:s,phiStart:r,phiLength:i,thetaStart:o,thetaLength:n},e=Math.max(3,Math.floor(e)),s=Math.max(2,Math.floor(s));const a=Math.min(o+n,Math.PI);let u=0;const c=[],l=new d,y=new d,m=[],p=[],M=[],h=[];for(let f=0;f<=s;f++){const b=[],w=f/s;let g=0;f===0&&o===0?g=.5/e:f===s&&a===Math.PI&&(g=-.5/e);for(let V=0;V<=e;V++){const S=V/e;l.x=-t*Math.cos(r+S*i)*Math.sin(o+w*n),l.y=t*Math.cos(o+w*n),l.z=t*Math.sin(r+S*i)*Math.sin(o+w*n),p.push(l.x,l.y,l.z),y.copy(l).normalize(),M.push(y.x,y.y,y.z),h.push(S+g,1-w),b.push(u++)}c.push(b)}for(let f=0;f<s;f++)for(let b=0;b<e;b++){const w=c[f][b+1],g=c[f][b],V=c[f+1][b],S=c[f+1][b+1];(f!==0||o>0)&&m.push(w,g,S),(f!==s-1||a<Math.PI)&&m.push(g,V,S)}this.setIndex(m),this.setAttribute("position",new Q(p,3)),this.setAttribute("normal",new Q(M,3)),this.setAttribute("uv",new Q(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new rt(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}export{yt as M,dt as f,rt as n};
