import{j,X as m,Q as P,o as R}from"./index-Dis_VqaA.js";import{D as v,L as T,j as k}from"./BufferGeometry-Bn0KB3W4-C0_Zf33T.js";import{n as I}from"./LineBasicMaterial-Cx-RKwkZ-T-lW3OVj.js";const M=new m,b=new m,S=new R,y=new k,x=new P,L=new m,W=new m;class z extends j{constructor(t=new v,i=new I){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=i,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,i){return super.copy(t,i),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[0];for(let e=1,n=i.count;e<n;e++)M.fromBufferAttribute(i,e-1),b.fromBufferAttribute(i,e),s[e]=s[e-1],s[e]+=M.distanceTo(b);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,i){const s=this.geometry,e=this.matrixWorld,n=t.params.Line.threshold,r=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),x.copy(s.boundingSphere),x.applyMatrix4(e),x.radius+=n,t.ray.intersectsSphere(x)===!1)return;S.copy(e).invert(),y.copy(t.ray).applyMatrix4(S);const c=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=c*c,f=this.isLineSegments?2:1,h=s.index,E=s.attributes.position;if(h!==null){const d=Math.max(0,r.start),u=Math.min(h.count,r.start+r.count);for(let o=d,g=u-1;o<g;o+=f){const p=h.getX(o),H=h.getX(o+1),A=w(this,t,y,a,p,H,o);A&&i.push(A)}if(this.isLineLoop){const o=h.getX(u-1),g=h.getX(d),p=w(this,t,y,a,o,g,u-1);p&&i.push(p)}}else{const d=Math.max(0,r.start),u=Math.min(E.count,r.start+r.count);for(let o=d,g=u-1;o<g;o+=f){const p=w(this,t,y,a,o,o+1,o);p&&i.push(p)}if(this.isLineLoop){const o=w(this,t,y,a,u-1,d,u-1);o&&i.push(o)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=s.length;e<n;e++){const r=s[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=e}}}}}function w(l,t,i,s,e,n,r){const c=l.geometry.attributes.position;if(M.fromBufferAttribute(c,e),b.fromBufferAttribute(c,n),i.distanceSqToSegment(M,b,L,W)>s)return;L.applyMatrix4(l.matrixWorld);const a=t.ray.origin.distanceTo(L);if(!(a<t.near||a>t.far))return{distance:a,point:W.clone().applyMatrix4(l.matrixWorld),index:r,face:null,faceIndex:null,barycoord:null,object:l}}const D=new m,B=new m;class C extends z{constructor(t,i){super(t,i),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[];for(let e=0,n=i.count;e<n;e+=2)D.fromBufferAttribute(i,e),B.fromBufferAttribute(i,e+1),s[e]=e===0?0:s[e-1],s[e+1]=s[e]+D.distanceTo(B);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}const X=new m;class q extends j{constructor(t,i){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=i,this.type="SpotLightHelper";const s=new v,e=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,c=1,a=32;r<a;r++,c++){const f=r/a*Math.PI*2,h=c/a*Math.PI*2;e.push(Math.cos(f),Math.sin(f),1,Math.cos(h),Math.sin(h),1)}s.setAttribute("position",new T(e,3));const n=new I({fog:!1,toneMapped:!1});this.cone=new C(s,n),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,i=t*Math.tan(this.light.angle);this.cone.scale.set(i,i,t),X.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(X),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}export{q as SpotLightHelper};
