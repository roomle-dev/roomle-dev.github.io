import{ad as it,ae as d,af as at,ag as ot,ah as nt,ai as ct,aj as Q,ak as ht,al as lt,am as Z}from"./index-3eT8XdN2.js";import{E as rt,_ as ut,J as G,G as pt,l as dt}from"./BufferGeometry-BluAz28W-plKaKLQ2.js";const x=new d,T=new d,J=new d,B=new d,P=new d,L=new d,Y=new d,W=new d,k=new d,E=new d,H=new Z,C=new Z,K=new Z;class S{constructor(t=new d,e=new d,s=new d){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,r){r.subVectors(s,e),x.subVectors(t,e),r.cross(x);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(t,e,s,r,i){x.subVectors(r,e),T.subVectors(s,e),J.subVectors(t,e);const n=x.dot(x),o=x.dot(T),a=x.dot(J),u=T.dot(T),c=T.dot(J),l=n*u-o*o;if(l===0)return i.set(0,0,0),null;const y=1/l,m=(u*a-o*c)*y,p=(n*c-o*a)*y;return i.set(1-m-p,p,m)}static containsPoint(t,e,s,r){return this.getBarycoord(t,e,s,r,B)===null?!1:B.x>=0&&B.y>=0&&B.x+B.y<=1}static getInterpolation(t,e,s,r,i,n,o,a){return this.getBarycoord(t,e,s,r,B)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(i,B.x),a.addScaledVector(n,B.y),a.addScaledVector(o,B.z),a)}static getInterpolatedAttribute(t,e,s,r,i,n){return H.setScalar(0),C.setScalar(0),K.setScalar(0),H.fromBufferAttribute(t,e),C.fromBufferAttribute(t,s),K.fromBufferAttribute(t,r),n.setScalar(0),n.addScaledVector(H,i.x),n.addScaledVector(C,i.y),n.addScaledVector(K,i.z),n}static isFrontFacing(t,e,s,r){return x.subVectors(s,e),T.subVectors(t,e),x.cross(T).dot(r)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,r){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,s,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return x.subVectors(this.c,this.b),T.subVectors(this.a,this.b),x.cross(T).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return S.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return S.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,r,i){return S.getInterpolation(t,this.a,this.b,this.c,e,s,r,i)}containsPoint(t){return S.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return S.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,r=this.b,i=this.c;let n,o;P.subVectors(r,s),L.subVectors(i,s),W.subVectors(t,s);const a=P.dot(W),u=L.dot(W);if(a<=0&&u<=0)return e.copy(s);k.subVectors(t,r);const c=P.dot(k),l=L.dot(k);if(c>=0&&l<=c)return e.copy(r);const y=a*l-c*u;if(y<=0&&a>=0&&c<=0)return n=a/(a-c),e.copy(s).addScaledVector(P,n);E.subVectors(t,i);const m=P.dot(E),p=L.dot(E);if(p>=0&&m<=p)return e.copy(i);const M=m*u-a*p;if(M<=0&&u>=0&&p<=0)return o=u/(u-p),e.copy(s).addScaledVector(L,o);const h=c*p-m*l;if(h<=0&&l-c>=0&&m-p>=0)return Y.subVectors(i,r),o=(l-c)/(l-c+(m-p)),e.copy(r).addScaledVector(Y,o);const g=1/(h+M+y);return n=M*g,o=y*g,e.copy(s).addScaledVector(P,n).addScaledVector(L,o)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class st extends pt{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new dt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new nt,this.combine=ct,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const _=new ot,v=new ut,F=new at,tt=new d,j=new d,q=new d,z=new d,U=new d,R=new d,et=new d,X=new d;class mt extends it{constructor(t=new rt,e=new st){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,e=Object.keys(t);if(e.length>0){const s=t[e[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,i=s.length;r<i;r++){const n=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=r}}}}getVertexPosition(t,e){const s=this.geometry,r=s.attributes.position,i=s.morphAttributes.position,n=s.morphTargetsRelative;e.fromBufferAttribute(r,t);const o=this.morphTargetInfluences;if(i&&o){R.set(0,0,0);for(let a=0,u=i.length;a<u;a++){const c=o[a],l=i[a];c!==0&&(U.fromBufferAttribute(l,t),n?R.addScaledVector(U,c):R.addScaledVector(U.sub(e),c))}e.add(R)}return e}raycast(t,e){const s=this.geometry,r=this.material,i=this.matrixWorld;r!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),F.copy(s.boundingSphere),F.applyMatrix4(i),v.copy(t.ray).recast(t.near),!(F.containsPoint(v.origin)===!1&&(v.intersectSphere(F,tt)===null||v.origin.distanceToSquared(tt)>(t.far-t.near)**2))&&(_.copy(i).invert(),v.copy(t.ray).applyMatrix4(_),!(s.boundingBox!==null&&v.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(t,e,v)))}_computeIntersections(t,e,s){let r;const i=this.geometry,n=this.material,o=i.index,a=i.attributes.position,u=i.attributes.uv,c=i.attributes.uv1,l=i.attributes.normal,y=i.groups,m=i.drawRange;if(o!==null)if(Array.isArray(n))for(let p=0,M=y.length;p<M;p++){const h=y[p],g=n[h.materialIndex],b=Math.max(h.start,m.start),w=Math.min(o.count,Math.min(h.start+h.count,m.start+m.count));for(let f=b,A=w;f<A;f+=3){const I=o.getX(f),N=o.getX(f+1),O=o.getX(f+2);r=D(this,g,t,s,u,c,l,I,N,O),r&&(r.faceIndex=Math.floor(f/3),r.face.materialIndex=h.materialIndex,e.push(r))}}else{const p=Math.max(0,m.start),M=Math.min(o.count,m.start+m.count);for(let h=p,g=M;h<g;h+=3){const b=o.getX(h),w=o.getX(h+1),f=o.getX(h+2);r=D(this,n,t,s,u,c,l,b,w,f),r&&(r.faceIndex=Math.floor(h/3),e.push(r))}}else if(a!==void 0)if(Array.isArray(n))for(let p=0,M=y.length;p<M;p++){const h=y[p],g=n[h.materialIndex],b=Math.max(h.start,m.start),w=Math.min(a.count,Math.min(h.start+h.count,m.start+m.count));for(let f=b,A=w;f<A;f+=3){const I=f,N=f+1,O=f+2;r=D(this,g,t,s,u,c,l,I,N,O),r&&(r.faceIndex=Math.floor(f/3),r.face.materialIndex=h.materialIndex,e.push(r))}}else{const p=Math.max(0,m.start),M=Math.min(a.count,m.start+m.count);for(let h=p,g=M;h<g;h+=3){const b=h,w=h+1,f=h+2;r=D(this,n,t,s,u,c,l,b,w,f),r&&(r.faceIndex=Math.floor(h/3),e.push(r))}}}}function gt(V,t,e,s,r,i,n,o){let a;if(t.side===ht?a=s.intersectTriangle(n,i,r,!0,o):a=s.intersectTriangle(r,i,n,t.side===lt,o),a===null)return null;X.copy(o),X.applyMatrix4(V.matrixWorld);const u=e.ray.origin.distanceTo(X);return u<e.near||u>e.far?null:{distance:u,point:X.clone(),object:V}}function D(V,t,e,s,r,i,n,o,a,u){V.getVertexPosition(o,j),V.getVertexPosition(a,q),V.getVertexPosition(u,z);const c=gt(V,t,e,s,j,q,z,et);if(c){const l=new d;S.getBarycoord(et,j,q,z,l),r&&(c.uv=S.getInterpolatedAttribute(r,o,a,u,l,new Q)),i&&(c.uv1=S.getInterpolatedAttribute(i,o,a,u,l,new Q)),n&&(c.normal=S.getInterpolatedAttribute(n,o,a,u,l,new d),c.normal.dot(s.direction)>0&&c.normal.multiplyScalar(-1));const y={a:o,b:a,c:u,normal:new d,materialIndex:0};S.getNormal(j,q,z,y.normal),c.face=y,c.barycoord=l}return c}class $ extends rt{constructor(t=1,e=32,s=16,r=0,i=Math.PI*2,n=0,o=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:s,phiStart:r,phiLength:i,thetaStart:n,thetaLength:o},e=Math.max(3,Math.floor(e)),s=Math.max(2,Math.floor(s));const a=Math.min(n+o,Math.PI);let u=0;const c=[],l=new d,y=new d,m=[],p=[],M=[],h=[];for(let g=0;g<=s;g++){const b=[],w=g/s;let f=0;g===0&&n===0?f=.5/e:g===s&&a===Math.PI&&(f=-.5/e);for(let A=0;A<=e;A++){const I=A/e;l.x=-t*Math.cos(r+I*i)*Math.sin(n+w*o),l.y=t*Math.cos(n+w*o),l.z=t*Math.sin(r+I*i)*Math.sin(n+w*o),p.push(l.x,l.y,l.z),y.copy(l).normalize(),M.push(y.x,y.y,y.z),h.push(I+f,1-w),b.push(u++)}c.push(b)}for(let g=0;g<s;g++)for(let b=0;b<e;b++){const w=c[g][b+1],f=c[g][b],A=c[g+1][b],I=c[g+1][b+1];(g!==0||n>0)&&m.push(w,f,I),(g!==s-1||a<Math.PI)&&m.push(f,A,I)}this.setIndex(m),this.setAttribute("position",new G(p,3)),this.setAttribute("normal",new G(M,3)),this.setAttribute("uv",new G(h,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new $(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class bt extends mt{constructor(t,e,s){const r=new $(e,4,2),i=new st({wireframe:!0,fog:!1,toneMapped:!1});super(r,i),this.light=t,this.color=s,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}export{bt as PointLightHelper};
