import{ad as E,ae as m,af as G,ag as P}from"./index-B6gMdnHJ.js";import{E as X,J as T,G as R,l as _,_ as k}from"./BufferGeometry-BluAz28W-DTjalBwT.js";class I extends R{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new _(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const M=new m,b=new m,S=new P,y=new k,x=new G,L=new m,W=new m;class z extends E{constructor(t=new X,i=new I){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=i,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,i){return super.copy(t,i),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[0];for(let e=1,n=i.count;e<n;e++)M.fromBufferAttribute(i,e-1),b.fromBufferAttribute(i,e),s[e]=s[e-1],s[e]+=M.distanceTo(b);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,i){const s=this.geometry,e=this.matrixWorld,n=t.params.Line.threshold,r=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),x.copy(s.boundingSphere),x.applyMatrix4(e),x.radius+=n,t.ray.intersectsSphere(x)===!1)return;S.copy(e).invert(),y.copy(t.ray).applyMatrix4(S);const l=n/((this.scale.x+this.scale.y+this.scale.z)/3),a=l*l,d=this.isLineSegments?2:1,h=s.index,j=s.attributes.position;if(h!==null){const f=Math.max(0,r.start),u=Math.min(h.count,r.start+r.count);for(let o=f,g=u-1;o<g;o+=d){const p=h.getX(o),H=h.getX(o+1),A=w(this,t,y,a,p,H,o);A&&i.push(A)}if(this.isLineLoop){const o=h.getX(u-1),g=h.getX(f),p=w(this,t,y,a,o,g,u-1);p&&i.push(p)}}else{const f=Math.max(0,r.start),u=Math.min(j.count,r.start+r.count);for(let o=f,g=u-1;o<g;o+=d){const p=w(this,t,y,a,o,o+1,o);p&&i.push(p)}if(this.isLineLoop){const o=w(this,t,y,a,u-1,f,u-1);o&&i.push(o)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,n=s.length;e<n;e++){const r=s[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=e}}}}}function w(c,t,i,s,e,n,r){const l=c.geometry.attributes.position;if(M.fromBufferAttribute(l,e),b.fromBufferAttribute(l,n),i.distanceSqToSegment(M,b,L,W)>s)return;L.applyMatrix4(c.matrixWorld);const a=t.ray.origin.distanceTo(L);if(!(a<t.near||a>t.far))return{distance:a,point:W.clone().applyMatrix4(c.matrixWorld),index:r,face:null,faceIndex:null,barycoord:null,object:c}}const B=new m,D=new m;class C extends z{constructor(t,i){super(t,i),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[];for(let e=0,n=i.count;e<n;e+=2)B.fromBufferAttribute(i,e),D.fromBufferAttribute(i,e+1),s[e]=e===0?0:s[e-1],s[e+1]=s[e]+B.distanceTo(D);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}const v=new m;class O extends E{constructor(t,i){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=i,this.type="SpotLightHelper";const s=new X,e=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let r=0,l=1,a=32;r<a;r++,l++){const d=r/a*Math.PI*2,h=l/a*Math.PI*2;e.push(Math.cos(d),Math.sin(d),1,Math.cos(h),Math.sin(h),1)}s.setAttribute("position",new T(e,3));const n=new I({fog:!1,toneMapped:!1});this.cone=new C(s,n),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,i=t*Math.tan(this.light.angle);this.cone.scale.set(i,i,t),v.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(v),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}export{O as SpotLightHelper};
