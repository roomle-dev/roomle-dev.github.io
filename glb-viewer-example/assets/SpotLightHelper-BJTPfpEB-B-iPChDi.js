import{Bt as e,Zr as t,kn as n,xi as r}from"./index-BPCKOvYy.js";import{m as i,r as a,s as o}from"./BufferGeometry-Bn0KB3W4-YHVejfVJ.js";import{t as s}from"./LineBasicMaterial-Cx-RKwkZ-xIHI-2u7.js";var c=new n,l=new n,u=new r,d=new i,f=new e,p=new n,m=new n,h=class extends t{constructor(e=new a,t=new s){super(),this.isLine=!0,this.type=`Line`,this.geometry=e,this.material=t,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){let e=this.geometry;if(e.index===null){let t=e.attributes.position,n=[0];for(let e=1,r=t.count;e<r;e++)c.fromBufferAttribute(t,e-1),l.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=c.distanceTo(l);e.setAttribute(`lineDistance`,new o(n,1))}else console.warn(`THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.`);return this}raycast(e,t){let n=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),f.copy(n.boundingSphere),f.applyMatrix4(r),f.radius+=i,e.ray.intersectsSphere(f)===!1)return;u.copy(r).invert(),d.copy(e.ray).applyMatrix4(u);let o=i/((this.scale.x+this.scale.y+this.scale.z)/3),s=o*o,c=this.isLineSegments?2:1,l=n.index,p=n.attributes.position;if(l!==null){let n=Math.max(0,a.start),r=Math.min(l.count,a.start+a.count);for(let i=n,a=r-1;i<a;i+=c){let n=l.getX(i),r=l.getX(i+1),a=g(this,e,d,s,n,r,i);a&&t.push(a)}if(this.isLineLoop){let i=l.getX(r-1),a=l.getX(n),o=g(this,e,d,s,i,a,r-1);o&&t.push(o)}}else{let n=Math.max(0,a.start),r=Math.min(p.count,a.start+a.count);for(let i=n,a=r-1;i<a;i+=c){let n=g(this,e,d,s,i,i+1,i);n&&t.push(n)}if(this.isLineLoop){let i=g(this,e,d,s,r-1,n,r-1);i&&t.push(i)}}}updateMorphTargets(){let e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){let n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=n.length;e<t;e++){let t=n[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}};function g(e,t,n,r,i,a,o){let s=e.geometry.attributes.position;if(c.fromBufferAttribute(s,i),l.fromBufferAttribute(s,a),n.distanceSqToSegment(c,l,p,m)>r)return;p.applyMatrix4(e.matrixWorld);let u=t.ray.origin.distanceTo(p);if(!(u<t.near||u>t.far))return{distance:u,point:m.clone().applyMatrix4(e.matrixWorld),index:o,face:null,faceIndex:null,barycoord:null,object:e}}var _=new n,v=new n,y=class extends h{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type=`LineSegments`}computeLineDistances(){let e=this.geometry;if(e.index===null){let t=e.attributes.position,n=[];for(let e=0,r=t.count;e<r;e+=2)_.fromBufferAttribute(t,e),v.fromBufferAttribute(t,e+1),n[e]=e===0?0:n[e-1],n[e+1]=n[e]+_.distanceTo(v);e.setAttribute(`lineDistance`,new o(n,1))}else console.warn(`THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.`);return this}},b=new n,x=class extends t{constructor(e,t){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=t,this.type=`SpotLightHelper`;let n=new a,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let e=0,t=1;e<32;e++,t++){let n=e/32*Math.PI*2,i=t/32*Math.PI*2;r.push(Math.cos(n),Math.sin(n),1,Math.cos(i),Math.sin(i),1)}n.setAttribute(`position`,new o(r,3)),this.cone=new y(n,new s({fog:!1,toneMapped:!1})),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);let e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),b.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(b),this.color===void 0?this.cone.material.color.copy(this.light.color):this.cone.material.color.set(this.color)}};export{x as SpotLightHelper};