import { g as getAssetPath, A as AmbientLight, D as DirectionalLight, V as Vector2, a as Vector3, R as RectAreaLight, S as SpotLight, C as Color$1, M as MainThreadToWorker, B as BufferGeometry, b as BufferAttribute, T as TrianglesDrawMode, c as TriangleFanDrawMode, d as TriangleStripDrawMode, L as Loader, e as LoaderUtils, F as FileLoader, f as LinearSRGBColorSpace, P as PointLight, h as MeshBasicMaterial, i as SRGBColorSpace, j as MeshPhysicalMaterial, k as Matrix4, Q as Quaternion, I as InstancedMesh, l as InstancedBufferAttribute, O as Object3D, m as TextureLoader, n as ImageBitmapLoader, o as InterleavedBuffer, p as LinearFilter, q as LinearMipmapLinearFilter, r as RepeatWrapping, s as PointsMaterial, t as Material, u as LineBasicMaterial, v as MeshStandardMaterial, w as DoubleSide, x as PropertyBinding, y as SkinnedMesh, z as Mesh, E as LineSegments, G as Line, H as LineLoop, J as Points, K as Group, N as PerspectiveCamera, U as MathUtils, W as OrthographicCamera, X as Skeleton, Y as AnimationClip, Z as Bone, _ as InterpolateLinear, $ as ColorManagement, a0 as NearestFilter, a1 as NearestMipmapNearestFilter, a2 as LinearMipmapNearestFilter, a3 as NearestMipmapLinearFilter, a4 as ClampToEdgeWrapping, a5 as MirroredRepeatWrapping, a6 as InterpolateDiscrete, a7 as FrontSide, a8 as InterleavedBufferAttribute, a9 as Texture, aa as VectorKeyframeTrack, ab as NumberKeyframeTrack, ac as QuaternionKeyframeTrack, ad as Box3, ae as Sphere, af as Interpolant, ag as Euler, ah as CubeTexture, ai as RGBAFormat$1, aj as DataTexture, ak as getValue, al as Scene, am as Vector4, an as Matrix3, ao as ShaderMaterial, ap as DstColorFactor, aq as ZeroFactor, ar as AddEquation, as as DstAlphaFactor, at as UniformsUtils, au as NoBlending, av as Float32BufferAttribute, aw as UnsignedByteType, ax as CustomBlending, ay as MinEquation, az as OneFactor, aA as WebGLRenderTarget, aB as deepMerge, aC as ROOMLE_COLORS, aD as ROOMLE_HIGHLIGHTNG, aE as CAMERA_TYPE, aF as setWriteable, aG as setDescriptor, aH as Uint32BufferAttribute, aI as createBenchmarkMaterial, aJ as createBenchmarkTexture, aK as ShapePath, aL as removeItem, aM as transformRange, aN as BoxGeometry, aO as getGlbUrl, aP as wait, aQ as objectArrayToMap, aR as roundWithPrecision, aS as uuid, aT as handleJsonResponse, aU as setCursor, aV as EdgesGeometry, aW as LineDashedMaterial, aX as ArrowHelper, aY as CylinderGeometry, aZ as Line3, a_ as SphereGeometry, a$ as RingGeometry, b0 as isString, b1 as DataTextureLoader, b2 as HalfFloatType, b3 as FloatType, b4 as RedFormat, b5 as NoColorSpace, b6 as DataUtils, b7 as EquirectangularReflectionMapping, b8 as PlaneGeometry, b9 as RGFormat, ba as CameraHelper, bb as MeshDepthMaterial, bc as MeshNormalMaterial, bd as DepthTexture, be as DepthStencilFormat, bf as UnsignedInt248Type, bg as BackSide, bh as MeshLambertMaterial, bi as PCFShadowMap, bj as BasicShadowMap, bk as PCFSoftShadowMap, bl as VSMShadowMap, bm as ShadowMaterial, bn as MeshPhongMaterial, bo as AdditiveBlending, bp as NoToneMapping, bq as LinearToneMapping, br as ReinhardToneMapping, bs as CineonToneMapping, bt as ACESFilmicToneMapping, bu as Layers, bv as WebGLRenderer } from './main-thread-to-worker-8a755a37.js';

class Container {
    constructor() {
        this._context = new Map();
        this._lookups = new Map();
        this._singletons = new Map();
    }
    getContext(name) {
        if (this._context.has(name)) {
            const count = this._context.get(name);
            this._context.set(name, count + 1);
            return name + count;
        }
        this._context.set(name, 1);
        return name + 0;
    }
    addDependencyInjectionAssignments(injections) {
        injections.forEach((definition) => {
            this._lookups.set(definition.className, definition);
        });
    }
    lookup(specifier, context) {
        if (!this._lookups.has(specifier)) {
            return null;
        }
        const definition = this._lookups.get(specifier);
        if (definition.type === 1 /* DI_TYPE.CONTEXT */ && context === undefined) {
            const message = 'Dependency ' +
                specifier +
                ' has definition context but no context was defined!';
            console.trace(message);
            console.error(message);
            return null;
        }
        let key = context && definition.type === 1 /* DI_TYPE.CONTEXT */ ? context : 'global';
        key += '_' + specifier;
        if (definition.type === 2 /* DI_TYPE.NEW */) {
            return new definition.classDefinition();
        }
        else if (this._singletons.has(key)) {
            return this._singletons.get(key);
        }
        const singleton = new definition.classDefinition(context);
        this._singletons.set(key, singleton);
        return singleton;
    }
    cleanUp(context) {
        if (context) {
            let removals = [];
            this._singletons.forEach((value, key) => {
                if (key.startsWith(context)) {
                    removals.push(key);
                }
            });
            removals.forEach((key) => {
                this._singletons.delete(key);
            });
        }
        else {
            this._singletons.clear();
            this._singletons = new Map();
        }
    }
}
class DependencyInjectionAssignment {
    constructor(className, classDefinition, type) {
        this.className = className;
        this.classDefinition = classDefinition;
        this.type = type === undefined ? 0 /* DI_TYPE.GLOBAL */ : type;
    }
}

class ErrorHandler {
    constructor() {
        this._listeners = {};
    }
    _subscribe(errorCode, callback) {
        if (!this._listeners[errorCode]) {
            this._listeners[errorCode] = [];
        }
        this._listeners[errorCode].push(callback);
    }
    subscribe(errorCode, callback) {
        this._subscribe(errorCode, callback);
    }
    dispatch(errorCode, args) {
        if (!this._listeners[errorCode]) {
            return;
        }
        const listeners = this._listeners[errorCode];
        let length = listeners.length;
        for (let i = 0; i < length; i++) {
            const listener = listeners[i];
            listener.apply(listener, args);
        }
    }
    unsubscribe(errorCode, callback) {
        if (!this._listeners[errorCode]) {
            return;
        }
        const listeners = this._listeners[errorCode];
        let length = listeners.length;
        for (let i = 0; i < length; i++) {
            if (listeners[i] === callback) {
                listeners.splice(i, 1);
                length--;
                i--;
                return;
            }
        }
    }
    softReject(resolve, errorMessage, errorCode) {
        this.dispatch(errorCode, [errorMessage]);
        return resolve();
    }
}

const IMAGE_FORMATS = {
    JPG: '.jpg',
    JPEG: '.jpeg',
    PNG: '.png',
    GIF: '.gif',
};
class FormDataUtil {
    _base64toBlob(base64, contentType) {
        contentType = contentType || '';
        const sliceSize = 1024;
        const byteCharacters = atob(base64);
        const bytesLength = byteCharacters.length;
        const slicesCount = Math.ceil(bytesLength / sliceSize);
        const byteArrays = new Array(slicesCount);
        for (let sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
            let begin = sliceIndex * sliceSize;
            let end = Math.min(begin + sliceSize, bytesLength);
            const bytes = new Array(end - begin);
            for (let offset = begin, i = 0; offset < end; ++i, ++offset) {
                bytes[i] = byteCharacters[offset].charCodeAt(0);
            }
            byteArrays[sliceIndex] = new Uint8Array(bytes);
        }
        return new Blob(byteArrays, { type: contentType });
    }
    _createFormData(base64, hash, fileExtension, formField) {
        const formData = new FormData();
        if (base64.indexOf(',') !== -1) {
            base64 = base64.substr(base64.indexOf(',') + 1);
        }
        const imageTypes = Object.keys(IMAGE_FORMATS).map((key) => IMAGE_FORMATS[key]);
        const filetype = imageTypes.indexOf(fileExtension) === -1 ? 'application' : 'image';
        const blob = this._base64toBlob(base64, filetype + '/' + fileExtension.substr(1));
        formData.append(formField, blob, hash + fileExtension);
        return formData;
    }
    create(base64, hash, fileExtension, formfield) {
        return this._createFormData(base64, hash, fileExtension, formfield);
    }
}

class SinglePromiseFactory {
    constructor(creator) {
        this._promises = new Map();
        this._creator_ = creator;
    }
    create(promiseCategory, promiseIdentifier, workToDo) {
        return new Promise((resolveExtern, rejectExtern) => {
            let category = this._promises.get(promiseCategory);
            let isPending = true;
            if (!category) {
                const map = new Map();
                this._promises.set(promiseCategory, map);
                category = this._promises.get(promiseCategory);
                isPending = false;
            }
            if (!category.get(promiseIdentifier)) {
                category.set(promiseIdentifier, []);
                isPending = false;
            }
            const waiters = category.get(promiseIdentifier);
            waiters.push({ resolve: resolveExtern, reject: rejectExtern });
            category.set(promiseIdentifier, waiters);
            const cleanMap = () => {
                category.delete(promiseIdentifier);
                if (category.size === 0) {
                    this._promises.delete(promiseCategory);
                }
            };
            if (!isPending) {
                new Promise(workToDo).then((data) => {
                    category
                        .get(promiseIdentifier)
                        .forEach(({ resolve }) => resolve(data));
                    cleanMap();
                }, (error) => {
                    category
                        .get(promiseIdentifier)
                        .forEach(({ reject }) => reject(error));
                    cleanMap();
                });
            }
        });
    }
}

var LIGHT_SETTINGS_BAKED_FILE_NAME = "static/baked-6485a2b1daeb69e8.json";

var LIGHT_SETTINGS_CAMERA_FILE_NAME = "static/camera-05824b47cdb951e4.json";

var LIGHT_SETTINGS_EQUAL_FILE_NAME = "static/equal-319f6b83c827913f.json";

var LIGHT_SETTINGS_SHELF_FRONT_FILE_NAME = "static/shelf_front-8c9566a4512f0de8.json";

var LIGHT_SETTINGS_SHELF_FILE_NAME = "static/shelf-2975dd3f2fa9c763.json";

var LIGHT_SETTINGS_SOFA_FILE_NAME = "static/sofa-997b116bc5f2e92e.json";

const RECT_AREA_LIGHT_DEFAULT_SIZE = 0.8;
const PREDEFINED_LIGHTSETTING = {
    SOFA: 'sofa',
    SHELF: 'shelf',
    SHELF_FRONT: 'shelf_front',
    BAKED: 'baked',
    CAMERA: 'camera',
    EQUAL: 'equal',
    /* as const is used to create a union type from object for more
     * details see: so#53662389/10800831
     */
};
class DynamicLightSettingLoader {
    static createDynamicLightSettingSource(dls, ls) {
        let dynamicLightSettingSource = {};
        if (dls) {
            dynamicLightSettingSource.url = dls;
        }
        else if (ls) {
            switch (ls) {
                case PREDEFINED_LIGHTSETTING.SHELF:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_SHELF_FILE_NAME;
                    break;
                case PREDEFINED_LIGHTSETTING.SHELF_FRONT:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_SHELF_FRONT_FILE_NAME;
                    break;
                case PREDEFINED_LIGHTSETTING.SOFA:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_SOFA_FILE_NAME;
                    break;
                case PREDEFINED_LIGHTSETTING.BAKED:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_BAKED_FILE_NAME;
                    break;
                case PREDEFINED_LIGHTSETTING.CAMERA:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_CAMERA_FILE_NAME;
                    break;
                case PREDEFINED_LIGHTSETTING.EQUAL:
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_EQUAL_FILE_NAME;
                    break;
                default:
                    //use camera lightsetting as default
                    dynamicLightSettingSource.url =
                        getAssetPath() + LIGHT_SETTINGS_CAMERA_FILE_NAME;
            }
        }
        else {
            dynamicLightSettingSource = null;
        }
        return dynamicLightSettingSource;
    }
    parse(json) {
        let jsonObject = JSON.parse(json);
        if (!jsonObject.lights) {
            return [];
        }
        return this.load(jsonObject);
    }
    load(jsonObject) {
        let lights = [];
        if (!jsonObject.lights) {
            return [];
        }
        jsonObject.lights.forEach((lightObject) => {
            let light;
            switch (lightObject.type) {
                case "ambient" /* LIGHT_TYPE.AMBIENT_LIGHT */:
                    light = this._parseAmbientLight(lightObject);
                    break;
                case "rectarea" /* LIGHT_TYPE.RECTAREA_LIGHT */:
                    light = this._parseRectAreaLight(lightObject);
                    break;
                case "spot" /* LIGHT_TYPE.SPOT_LIGHT */:
                    light = this._parseSpotLight(lightObject);
                    break;
                case "directional" /* LIGHT_TYPE.DIRECTIONAL_LIGHT */:
                    light = this._parseDirectionalLight(lightObject);
                    break;
            }
            if (light) {
                lights.push(light);
            }
        });
        return lights;
    }
    _parseAmbientLight(light) {
        let ambientLight = new AmbientLight();
        this._parseCommon(ambientLight, light);
        return ambientLight;
    }
    _parseRectAreaLight(light) {
        // three-refactor - find a better solution for RectAreaLight with shadow
        let { intensity, castShadow, target, width, height } = light;
        let lightSource = null;
        if (castShadow && DynamicLightSettingLoader.rectAreaLightReplacement) {
            const directionalShadowLight = new DirectionalLight();
            this._parseCommon(directionalShadowLight, light);
            lightSource = directionalShadowLight;
            directionalShadowLight.castShadow = true;
            directionalShadowLight.shadow.camera.near = 0.1;
            directionalShadowLight.shadow.camera.far = 100;
            directionalShadowLight.shadow.mapSize = new Vector2(1024, 1024);
            directionalShadowLight.shadow.bias = -0.00005;
            directionalShadowLight.shadow.normalBias = 0.01;
            directionalShadowLight.intensity = intensity ? intensity / 100 : 1;
            directionalShadowLight.lookAt(target
                ? new Vector3(target.x, target.y, target.z)
                : new Vector3(0, 0, 0));
        }
        else {
            const rectAreaLight = new RectAreaLight();
            this._parseCommon(rectAreaLight, light);
            lightSource = rectAreaLight;
            rectAreaLight.width = width ? width : RECT_AREA_LIGHT_DEFAULT_SIZE;
            rectAreaLight.height = height ? height : RECT_AREA_LIGHT_DEFAULT_SIZE;
            rectAreaLight.castShadow = false; // castShadow ? castShadow : false; - RectAreaLight has no shadow.
            rectAreaLight.matrixAutoUpdate = true;
            rectAreaLight.intensity =
                (intensity ? intensity : 240) /
                    ((width ? width : RECT_AREA_LIGHT_DEFAULT_SIZE) *
                        (height ? height : RECT_AREA_LIGHT_DEFAULT_SIZE));
            rectAreaLight.lookAt(target
                ? new Vector3(target.x, target.y, target.z)
                : new Vector3(0, 0, 0));
            if (DynamicLightSettingLoader.rectAreaLightLoadingListener) {
                DynamicLightSettingLoader.rectAreaLightLoadingListener(rectAreaLight);
            }
        }
        return lightSource;
    }
    _parseSpotLight(light) {
        let spotlight = new SpotLight();
        this._parseCommon(spotlight, light);
        let { angle, penumbra, target, castShadow } = light;
        spotlight.angle = ((angle ? angle : 100) * Math.PI) / 180;
        spotlight.penumbra = penumbra ? penumbra : 0.5;
        spotlight.lookAt(target ? new Vector3(target.x, target.y, target.z) : new Vector3(0, 0, 0));
        spotlight.shadow.camera.near = 0.1;
        spotlight.shadow.camera.far = 10;
        spotlight.shadow.mapSize = new Vector2(1024, 1024);
        spotlight.castShadow = castShadow ? castShadow : false;
        return spotlight;
    }
    _parseDirectionalLight(light) {
        let directionalLight = new DirectionalLight();
        this._parseCommon(directionalLight, light);
        let { target, castShadow } = light;
        directionalLight.castShadow = castShadow ? castShadow : false;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.mapSize = new Vector2(1024, 1024);
        directionalLight.shadow.bias = -0.00005;
        directionalLight.lookAt(target ? new Vector3(target.x, target.y, target.z) : new Vector3(0, 0, 0));
        return directionalLight;
    }
    _parseCommon(light, lightObject) {
        let { name, intensity, color, position, movesWithCamera } = lightObject;
        light.name = name ? name : '';
        light.intensity = intensity ? intensity : 1;
        light.color = new Color$1(color ? color : '#ffffff');
        light.position.copy(position
            ? new Vector3(position.x, position.y, position.z)
            : new Vector3(0, 0, 0));
        light.visible = true;
        light.layers.set(1 /* LAYER.LIGHTING */);
        light.userData.movesWithCamera = movesWithCamera;
    }
}
DynamicLightSettingLoader.rectAreaLightReplacement = true;

const isInIframe = () => {
    if (
    // @ts-ignore -- TS believe me, this works ;-)
    window.__RML__ENV__ &&
        // @ts-ignore -- TS believe me, this works ;-)
        window.__RML__ENV__.skipIframeCheck) {
        return false;
    }
    try {
        // @ts-ignore -- TS believe me, this works ;-)
        return window.self !== window.top;
    }
    catch (e) {
        return true;
    }
};
const getHostname = () => {
    var _a;
    const isIframe = isInIframe();
    // @ts-ignore -- TS believe me, this works ;-)
    let url = (_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href;
    if (!url) {
        return null;
    }
    if (isIframe) {
        // @ts-ignore -- TS believe me, this works ;-)
        if (!document.referrer) {
            return null;
        }
        // @ts-ignore -- TS believe me, this works ;-)
        url = document.referrer;
    }
    const { hostname } = new URL(url);
    return hostname;
};
const NAMES_FOR_LOCALHOST = ['127.0.0.1', 'localhost', '0.0.0.0'];
const isDemoHostname = (hostname) => {
    if (!hostname) {
        return false;
    }
    if (NAMES_FOR_LOCALHOST.includes(hostname)) {
        return true;
    }
    // exception for CI builds
    if (hostname.endsWith('gitlab.io') || hostname.endsWith('gitlab.com')) {
        return true;
    }
    // exception for sandbox sites
    if (hostname.endsWith('codesandbox.io') ||
        hostname.endsWith('stackblitz.com')) {
        return true;
    }
    if (/^(admin.*.roomle.com)$/.test(hostname)) {
        return true;
    }
    return false;
};
const isIdItemId = function (id) {
    if (!id || typeof id !== 'string') {
        return false;
    }
    const parts = id.split(':');
    if (parts.length > 2) {
        return false;
    }
    else {
        return true;
    }
};
const getCatalogIdFromItemOrConfigurationId = (id) => {
    if (!id || typeof id !== 'string') {
        return null;
    }
    const idParts = id.split(':');
    if (idParts.length < 2) {
        return null;
    }
    return idParts[0];
};
const kernelPartToPriceId = ({ articleNr, componentId }) => {
    if (!!articleNr && articleNr !== '') {
        const catalogIdentifier = componentId.split(':')[0];
        return catalogIdentifier + ':' + articleNr;
    }
    return null;
};
const wasRequestSuccess = (ok, status) => {
    if (ok !== undefined && ok !== null) {
        return typeof ok === 'string' ? ok === 'true' : ok === true;
    }
    if (typeof status === 'string') {
        status = parseInt(status, 10);
    }
    return status >= 200 && status < 300; // for details see: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_Success
};

const MAX_NETWORK_CALLS = 40;
class NetworkLayer {
    constructor() {
        // @todo create one queue and sync it between,
        // main thread and worker thread
        this._queue = [];
        this._pendingRequests = 0;
    }
    _nextSlot() {
        this._pendingRequests -= 1;
        if (!this._queue.length) {
            return;
        }
        const { request, resolve, reject } = this._queue.shift();
        this._fetch(request).then(resolve, reject);
    }
    _fetch(request, options = {}, validation = {}) {
        this._pendingRequests += 1;
        return new Promise((resolve, reject) => {
            // NO ARROW FUNCTION ON PURPOSE OTHERWISE I HAVE NO ACCESS TO AGRUMENTS
            // TO HAVE CORRECT THIS, USE BIND
            self.fetch(request, options).then(async function (response) {
                this._nextSlot();
                const isSuccess = validation.checkResponse
                    ? (await validation.checkResponse(response)) !== false
                    : true;
                if (wasRequestSuccess(response.ok, response.status) && isSuccess) {
                    resolve(...arguments);
                }
                else {
                    const url = (response === null || response === void 0 ? void 0 : response.url) || 'URL unknown';
                    reject(new Error(response.statusText ||
                        'Http error "' +
                            (response && response.status
                                ? response.status
                                : 'unknown') +
                            '", for "' +
                            url +
                            '"'));
                }
            }.bind(this), (error) => {
                this._nextSlot();
                reject(error);
            });
        });
    }
    fetch(request, options = {}, checks = {}) {
        const isCongested = this._pendingRequests >= MAX_NETWORK_CALLS;
        if (isCongested) {
            return new Promise((resolve, reject) => this._queue.push({ request, resolve, reject }));
        }
        else {
            return this._fetch(request, options, checks);
        }
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*
 * Lifted from https://github.com/shahata/dasherize/blob/master/index.js
 */
const dashCase = function (str) {
    if (str.startsWith('_')) {
        str = str.substr(1);
    }
    return str.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (s, i) {
        return (i > 0 ? '-' : '') + s.toLowerCase();
    });
};

function inject(target, propertyName) {
    const propertyCache = Symbol('property-cache');
    Object.defineProperty(target, propertyName, {
        get() {
            if (!this[propertyCache]) {
                // eslint-disable-next-line
                const instance = window.__RML__DI__.lookup(dashCase(propertyName), this._creator_);
                if (!instance) {
                    console.error('Dependency ' +
                        dashCase(propertyName) +
                        ' not found! Add dependency to /utils/injectables.ts');
                }
                else {
                    this[propertyCache] = instance;
                }
            }
            return this[propertyCache];
        },
    });
}

/* eslint-disable prefer-spread */
class Logger {
    info(...args) {
        console.info.apply(console, args);
    }
    log(...args) {
        console.log.apply(console, args);
    }
    warn(...args) {
        console.warn.apply(console, args);
    }
    error(...args) {
        console.warn.apply(console, args);
    }
}

const KERNEL_MESSAGE_TYPE = {
    EXCEPTION: 'exception',
    ERROR: 'error',
    WARNING: 'warning',
    LOG: 'log',
};
class KernelIo extends Logger {
    constructor(creator) {
        super();
        this._creator_ = creator;
    }
    setMeta(meta) {
        this._meta = meta;
    }
    get meta() {
        return this._meta ? this._meta : {};
    }
    throw(msg) {
        const errorMsg = '[Kernel Exception]: ' + msg;
        this._globalCallback.onKernelMsg(KERNEL_MESSAGE_TYPE.EXCEPTION, msg, this.meta);
        this.error(errorMsg);
    }
    error(msg) {
        this._globalCallback.onKernelMsg(KERNEL_MESSAGE_TYPE.ERROR, msg, this.meta);
        super.error(msg);
    }
    warn(msg) {
        this._globalCallback.onKernelMsg(KERNEL_MESSAGE_TYPE.WARNING, msg, this.meta);
        super.warn(msg);
    }
}
__decorate([
    inject
], KernelIo.prototype, "_globalCallback", void 0);

class LocalStorage {
    constructor(_context_) {
        this._context_ = _context_;
    }
    get _localStorage() {
        let storage = null;
        try {
            storage = window.localStorage;
        }
        catch (e) {
            console.error(e);
        }
        return storage;
    }
    getItem(key) {
        if (!this._localStorage) {
            return null;
        }
        const data = this._localStorage.getItem(key);
        try {
            // if its boolean, number or object JSON.parse will work
            return JSON.parse(data);
        }
        catch (e) {
            // if not its a string and we return it as it is
            return data;
        }
    }
    setItem(key, value) {
        if (!this._localStorage) {
            return;
        }
        try {
            const valueStringified = JSON.stringify(value);
            this._localStorage.setItem(key, valueStringified);
        }
        catch (e) {
            console.error(e);
        }
    }
}

var ASSET_LOADER_FILE_NAME = "static/asset-loader.worker-d3edfa68eb20e0c6.js";

const ASSET_CACHE = new Map();
const SYNCED_CATALOGS = new Map();
const SYNCED_FLOORS_TAGS = new Map();
const SYNCED_TYPE_CHANGE_TAGS = new Map();
class DataSyncer {
    constructor(creator) {
        this._bootCallbacks = [];
        this._isStarted = false;
        this._isStarting = false;
        this._alwaysUseCache = false;
        this._creator_ = creator;
    }
    start(catalogId) {
        this._configuratorUiCallbacks.onSyncStarted();
        return this._startWorker()
            .then(() => this._handleCatalog(catalogId))
            .then(() => {
            // HANDLE TYPCHANGE TAG AND FLOORMATERIALS TAG AFTER CATALOG SYNC BECAUSE
            // PROBABILITY THAT EVERYTHING IS ALREADY ON THE CLIENT IS VERY HIGH
            const { typeChangeTag, floorMaterialsTag } = this._initData;
            Promise.all([
                this._syncFloorTag(floorMaterialsTag),
                this._syncTypeChangeTag(typeChangeTag),
            ]).then(() => {
                SYNCED_TYPE_CHANGE_TAGS.set(typeChangeTag, true);
                this._configuratorUiCallbacks.onSyncDone();
            });
        });
    }
    syncCatalog(catalogId) {
        return this._startWorker().then(() => this._handleCatalog(catalogId));
    }
    syncFloorTag(tagId) {
        return this._startWorker().then(() => this._syncFloorTag(tagId));
    }
    syncTypeChangeTag(tagId) {
        return this._startWorker().then(() => this._syncTypeChangeTag(tagId));
    }
    _syncFloorTag(tagId) {
        const promises = [];
        if (tagId && !SYNCED_FLOORS_TAGS.get(tagId)) {
            promises.push(this._handleTags([tagId]));
            this._rapiAccess.getTag(tagId).then((tag) => {
                promises.push(this._handleMaterialsAndTextures(tag));
            });
            return this._singlePromiseFactory.create(1 /* PROMISE_CATEGORY.OFFLINE_FLOOR_TAG_SYNC */, tagId, (resolve) => {
                Promise.all(promises).then(() => {
                    SYNCED_FLOORS_TAGS.set(tagId, true);
                    resolve();
                }, (error) => this._softReject(resolve, '_syncFloorTag error: "' + error + '"'));
            });
        }
        return Promise.resolve();
    }
    _syncTypeChangeTag(tagId) {
        const promises = [];
        if (tagId && !SYNCED_TYPE_CHANGE_TAGS.get(tagId)) {
            promises.push(this._handleTags([tagId]));
            this._rapiAccess.getTag(tagId).then((tag) => {
                this._rapiAccess.getItems(tag.items).then((items) => {
                    items.forEach((item) => {
                        if (this.getIsCatalogSynced(item.catalog)) {
                            promises.push(this._handleCatalog(item.catalog));
                        }
                    });
                });
            });
            return this._singlePromiseFactory.create(2 /* PROMISE_CATEGORY.OFFLINE_TPYE_CHANGE_TAG_SYNC */, tagId, (resolve) => {
                Promise.all(promises).then(() => {
                    SYNCED_FLOORS_TAGS.set(tagId, true);
                    resolve();
                }, (error) => this._softReject(resolve, '_syncTypeChangeTag error: "' + error + '"'));
            });
        }
        return Promise.resolve();
    }
    getIsCatalogSynced(catalogId) {
        const isSynced = SYNCED_CATALOGS.get(catalogId);
        // handle "undefined" and "false" case
        if (!isSynced) {
            return false;
        }
        return true;
    }
    _startWorker() {
        return new Promise((resolve, reject) => {
            if (this._isStarted) {
                return resolve();
            }
            this._bootCallbacks.push({ resolve, reject });
            if (this._isStarting) {
                return;
            }
            this._worker = new Worker(getAssetPath() + ASSET_LOADER_FILE_NAME);
            this._mainThreadToWorker = new MainThreadToWorker(this, this._worker);
            this._isStarting = true;
            this._mainThreadToWorker.sendToWorker(1 /* WORKER_MESSAGE.INIT */);
        });
    }
    onCommand(command, conversationId, data) {
        switch (command) {
            case 4 /* WORKER_MESSAGE.INIT_DONE */:
                this._isStarted = true;
                this._bootCallbacks.forEach(({ resolve }) => resolve());
                break;
            case 3 /* WORKER_MESSAGE.ASSET_LOADED */:
                this._mainThreadToWorker.resolvePromises(conversationId, data);
                break;
        }
    }
    _handleCatalog(catalogId) {
        return this._singlePromiseFactory.create(0 /* PROMISE_CATEGORY.OFFLINE_CATALOG_SYNC */, catalogId, (resolve) => {
            if (this.getIsCatalogSynced(catalogId)) {
                return resolve();
            }
            return this._rapiAccess
                .getCatalog(catalogId)
                .then((catalog) => Promise.all([
                this._handleContentWithAssets(this._rapiAccess.getComponentsOf(catalog), ["perspectiveImage" /* ASSET_KEYS.PERSPECTIVE_IMAGE */]),
                this._handleItemsAndAdditionalContents(catalog),
                this._handleMaterialsAndTextures(catalog),
                this._handleExternalMeshes(catalog),
                this._handleTags(catalog.tags),
            ]))
                .then(() => {
                console.log('CATALOG SYNC DONE');
                SYNCED_CATALOGS.set(catalogId, true);
                resolve();
            }, (error) => this._softReject(resolve, 'Catalog sync error: "' + error + '"'));
        });
    }
    _handleTags(tagIds) {
        return this._handleContentWithAssets(this._rapiAccess.getTags(tagIds), [
            "pngIcon" /* ASSET_KEYS.PNG_ICON */,
            "svgIcon" /* ASSET_KEYS.SVG_ICON */,
        ]);
    }
    _handleExternalMeshes(catalog) {
        return new Promise((resolve) => {
            this._rapiAccess.getMeshesOfCatalog(catalog.id).then((meshes) => {
                const promises = [];
                meshes.forEach((mesh) => {
                    promises.push(this._handleContentWithAssets(Promise.all([this._rapiAccess.getMesh(mesh.id)]), ["url" /* ASSET_KEYS.URL */]));
                });
                Promise.all(promises).then(resolve, (error) => this._softReject(resolve, 'Sync crt files error: "' + error + '"'));
            }, (error) => this._softReject(resolve, 'getMeshesOfCatalog error: "' + error + '"'));
        });
    }
    _handleItemsAndAdditionalContents(catalog) {
        return new Promise((resolve) => {
            this._rapiAccess.getItemsOf(catalog).then((items) => {
                const promises = [];
                promises.push(this._handleContentWithAssets(Promise.resolve(items), [
                    "perspectiveImage" /* ASSET_KEYS.PERSPECTIVE_IMAGE */,
                ]));
                this._rapiAccess.getAdditionalContentsOfItems(items).then((additionalContents) => {
                    const additionalContentsToPreCache = additionalContents.filter((additionalContent) => [
                        5 /* RAPI_ADDITIONAL_CONTENTS.IMAGE */,
                        6 /* RAPI_ADDITIONAL_CONTENTS.SKETCH */,
                        4 /* RAPI_ADDITIONAL_CONTENTS.DOWNLOAD */,
                    ].indexOf(additionalContent.type) !== -1);
                    promises.push(this._handleContentWithAssets(Promise.resolve(additionalContentsToPreCache), ["content" /* ASSET_KEYS.CONTENT */]));
                }, (error) => this._softReject(resolve, 'getAdditionalContentsOfItems error: "' + error + '"'));
                Promise.all(promises).then(resolve, (error) => this._softReject(resolve, 'AdditionalContent image sync error:"' + error + '"'));
            });
        });
    }
    _handleMaterialsAndTextures(catalog) {
        return new Promise((resolve) => {
            this._rapiAccess.getMaterialsOf(catalog).then((materials) => {
                const promises = [];
                promises.push(this._handleContentWithAssets(Promise.resolve(materials), [
                    "thumbnail" /* ASSET_KEYS.THUMBNAIL */,
                ]));
                materials.forEach((material) => {
                    promises.push(this._handleContentWithAssets(this._rapiAccess.getTexturesOf(material), ["image" /* ASSET_KEYS.IMAGE */]));
                });
                Promise.all(promises).then(resolve, (error) => this._softReject(resolve, 'getTexturesOf error: "' + error + '"'));
            }, (error) => this._softReject(resolve, 'getMaterialsOf error: "' + error + '"'));
        });
    }
    _handleContentWithAssets(promise, assetKey) {
        return new Promise((resolve) => promise.then((data) => this._fetchAssets(data, assetKey).then(resolve, (error) => this._softReject(resolve, '_handleContentWithAssets error: "' + error + '"')), (error) => this._softReject(resolve, '_handleContentWithAssets promise error: "' + error + '"')));
    }
    _fetchAssets(data, assetKeys) {
        const promises = [];
        if (!data) {
            data = [];
        }
        for (let i = 0, length = data.length; i < length; i++) {
            const dataEntry = data[i];
            assetKeys.forEach((assetKey) => {
                const url = dataEntry[assetKey];
                if (url) {
                    promises.push(this._preCacheAsset(url));
                }
            });
        }
        return Promise.all(promises);
    }
    _preCacheAsset(url) {
        return new Promise((resolve) => {
            if (ASSET_CACHE.get(url)) {
                return resolve();
            }
            this._assetUrlToBase64(url).then((assetUrl) => {
                ASSET_CACHE.set(url, assetUrl);
                resolve();
            }, (error) => this._softReject(resolve, '_preCacheAsset error: "' + error + '"'));
        });
    }
    _assetUrlToBase64(url) {
        return new Promise((resolve) => {
            this._mainThreadToWorker.sendToWorker(5 /* WORKER_MESSAGE.LOAD_ASSET */, url, resolve, (error) => this._softReject(resolve, '_assetUrlToBase64 error: "' + error + '"'));
        });
    }
    _softReject(resolve, errorMessage) {
        this._errorHandler.softReject(resolve, errorMessage, 2 /* ERROR_CODES.CONTENT_PROBLEM */);
    }
    requestAsset(url, urlAsFallback = false) {
        if (navigator.onLine && !this._alwaysUseCache) {
            return url;
        }
        const asset = ASSET_CACHE.get(url);
        return asset ? asset : urlAsFallback ? url : null;
    }
    setAlwaysUseCache(alwaysUseCache) {
        this._alwaysUseCache = alwaysUseCache;
    }
    // this is needed for testing until caches are injectable
    preFillAssetCache(key, url) {
        ASSET_CACHE.set(key, url);
    }
}
__decorate([
    inject
], DataSyncer.prototype, "_rapiAccess", void 0);
__decorate([
    inject
], DataSyncer.prototype, "_singlePromiseFactory", void 0);
__decorate([
    inject
], DataSyncer.prototype, "_errorHandler", void 0);
__decorate([
    inject
], DataSyncer.prototype, "_configuratorUiCallbacks", void 0);
__decorate([
    inject
], DataSyncer.prototype, "_initData", void 0);

const SINGLE_LOAD_LIMIT = 30;
const DIFFERENT_CONFIGURATION_LOAD_LIMIT = 15;
class MemoryManager {
    constructor() {
        this._configurationStringSet = new Set();
        this._singleLoadCounter = 0;
    }
    loadingConfigurationString() {
        this._singleLoadCounter += 1;
    }
    loadingConfiguration(configurationId) {
        this._configurationStringSet.add(configurationId);
        this._singleLoadCounter += 1;
    }
    shouldHardReset() {
        return (this._configurationStringSet.size >= DIFFERENT_CONFIGURATION_LOAD_LIMIT ||
            this._singleLoadCounter >= SINGLE_LOAD_LIMIT);
    }
    // this should only be called, if we are really done with our hard reset.
    executedHardReset() {
        this._configurationStringSet.clear();
        this._singleLoadCounter = 0;
    }
}

class LifeCycleManager {
    constructor() {
        this._listeners = [];
    }
    addEventListener(listener) {
        this._listeners.push(listener);
    }
    removeEventListener(listener) {
        const listeners = this._listeners;
        let length = listeners.length;
        if (!length) {
            return;
        }
        for (let i = 0; i < length; i++) {
            if (listeners[i] === listener) {
                listeners.splice(i, 1);
                i--;
                length--;
            }
        }
    }
    pause() {
        this._listeners.forEach((listener) => listener.pause());
    }
    resume() {
        this._listeners.forEach((listener) => listener.resume());
    }
    destroy() {
        this._listeners.forEach((listener) => listener.destroy());
    }
}

class AsyncGuard {
    constructor(info) {
        this.info = info;
        this._init();
    }
    _init() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    resolve(value) {
        if (value) {
            this._resolve(value);
        }
        this._resolve();
    }
    reject(e) {
        this._reject(e);
    }
    wait() {
        return this._promise;
    }
    reset() {
        this._init();
    }
}

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let gpuType = - 1;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		if ( gpuType === - 1 ) gpuType = attribute.gpuType;
		if ( gpuType !== attribute.gpuType ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	const result = new BufferAttribute( array, itemSize, normalized );
	if ( gpuType !== undefined ) {

		result.gpuType = gpuType;

	}

	return result;

}

/**
 * @param {BufferGeometry} geometry
 * @param {number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	if ( drawMode === TrianglesDrawMode ) {

		console.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );
		return geometry;

	}

	if ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {

		let index = geometry.getIndex();

		// generate index if not present

		if ( index === null ) {

			const indices = [];

			const position = geometry.getAttribute( 'position' );

			if ( position !== undefined ) {

				for ( let i = 0; i < position.count; i ++ ) {

					indices.push( i );

				}

				geometry.setIndex( indices );
				index = geometry.getIndex();

			} else {

				console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
				return geometry;

			}

		}

		//

		const numberOfTriangles = index.count - 2;
		const newIndices = [];

		if ( drawMode === TriangleFanDrawMode ) {

			// gl.TRIANGLE_FAN

			for ( let i = 1; i <= numberOfTriangles; i ++ ) {

				newIndices.push( index.getX( 0 ) );
				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );

			}

		} else {

			// gl.TRIANGLE_STRIP

			for ( let i = 0; i < numberOfTriangles; i ++ ) {

				if ( i % 2 === 0 ) {

					newIndices.push( index.getX( i ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i + 2 ) );

				} else {

					newIndices.push( index.getX( i + 2 ) );
					newIndices.push( index.getX( i + 1 ) );
					newIndices.push( index.getX( i ) );

				}

			}

		}

		if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

			console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

		}

		// build final geometry

		const newGeometry = geometry.clone();
		newGeometry.setIndex( newIndices );
		newGeometry.clearGroups();

		return newGeometry;

	} else {

		console.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );
		return geometry;

	}

}

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureAVIFExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsAnisotropyExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsBumpExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshGpuInstancing( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file
			// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'
			// resourcePath = 'https://my-cnd-server.com/assets/models/'
			// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'
			// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'
			const relativeUrl = LoaderUtils.extractUrlBase( url );
			resourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let json;
		const extensions = {};
		const plugins = {};
		const textDecoder = new TextDecoder();

		if ( typeof data === 'string' ) {

			json = JSON.parse( data );

		} else if ( data instanceof ArrayBuffer ) {

			const magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				json = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );

			} else {

				json = JSON.parse( textDecoder.decode( data ) );

			}

		} else {

			json = data;

		}

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );

			if ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );

			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color$1( 0xffffff );

		if ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		assignExtrasToUserData( lightNode, lightDef );

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	getDependency( type, index ) {

		if ( type !== 'light' ) return;

		return this._loadLight( index );

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color$1( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color$1( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			const colorFactor = extension.sheenColorFactor;
			materialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || Infinity;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color$1().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color$1().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending );

	}

}


/**
 * Materials bump Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump
 */
class GLTFMaterialsBumpExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_MATERIALS_BUMP;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;

		if ( extension.bumpTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials anisotropy Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy
 */
class GLTFMaterialsAnisotropyExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.anisotropyStrength !== undefined ) {

			materialParams.anisotropy = extension.anisotropyStrength;

		}

		if ( extension.anisotropyRotation !== undefined ) {

			materialParams.anisotropyRotation = extension.anisotropyRotation;

		}

		if ( extension.anisotropyTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * AVIF Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif
 */
class GLTFTextureAVIFExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image.
				image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return buffer.then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const source = new Uint8Array( res, byteOffset, byteLength );

				if ( decoder.decodeGltfBufferAsync ) {

					return decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {

						return res.buffer;

					} );

				} else {

					// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync
					return decoder.ready.then( function () {

						const result = new ArrayBuffer( count * stride );
						decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
						return result;

					} );

				}

			} );

		} else {

			return null;

		}

	}

}

/**
 * GPU Instancing Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 *
 */
class GLTFMeshGpuInstancing {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
		this.parser = parser;

	}

	createNodeMesh( nodeIndex ) {

		const json = this.parser.json;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||
			nodeDef.mesh === undefined ) {

			return null;

		}

		const meshDef = json.meshes[ nodeDef.mesh ];

		// No Points or Lines + Instancing support yet

		for ( const primitive of meshDef.primitives ) {

			if ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
				 primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
				 primitive.mode !== undefined ) {

				return null;

			}

		}

		const extensionDef = nodeDef.extensions[ this.name ];
		const attributesDef = extensionDef.attributes;

		// @TODO: Can we support InstancedMesh + SkinnedMesh?

		const pending = [];
		const attributes = {};

		for ( const key in attributesDef ) {

			pending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {

				attributes[ key ] = accessor;
				return attributes[ key ];

			} ) );

		}

		if ( pending.length < 1 ) {

			return null;

		}

		pending.push( this.parser.createNodeMesh( nodeIndex ) );

		return Promise.all( pending ).then( results => {

			const nodeObject = results.pop();
			const meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];
			const count = results[ 0 ].count; // All attribute counts should be same
			const instancedMeshes = [];

			for ( const mesh of meshes ) {

				// Temporal variables
				const m = new Matrix4();
				const p = new Vector3();
				const q = new Quaternion();
				const s = new Vector3( 1, 1, 1 );

				const instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );

				for ( let i = 0; i < count; i ++ ) {

					if ( attributes.TRANSLATION ) {

						p.fromBufferAttribute( attributes.TRANSLATION, i );

					}

					if ( attributes.ROTATION ) {

						q.fromBufferAttribute( attributes.ROTATION, i );

					}

					if ( attributes.SCALE ) {

						s.fromBufferAttribute( attributes.SCALE, i );

					}

					instancedMesh.setMatrixAt( i, m.compose( p, q, s ) );

				}

				// Add instance attributes to the geometry, excluding TRS.
				for ( const attributeName in attributes ) {

					if ( attributeName === '_COLOR_0' ) {

						const attr = attributes[ attributeName ];
						instancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );

					} else if ( attributeName !== 'TRANSLATION' &&
						 attributeName !== 'ROTATION' &&
						 attributeName !== 'SCALE' ) {

						mesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );

					}

				}

				// Just in case
				Object3D.prototype.copy.call( instancedMesh, mesh );

				this.parser.assignFinalMaterial( instancedMesh );

				instancedMeshes.push( instancedMesh );

			}

			if ( nodeObject.isGroup ) {

				nodeObject.clear();

				nodeObject.add( ... instancedMeshes );

				return nodeObject;

			}

			return instancedMeshes[ 0 ];

		} );

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );
		const textDecoder = new TextDecoder();

		this.header = {
			magic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = textDecoder.decode( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType.name;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve, reject ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )
			&& transform.offset === undefined
			&& transform.rotation === undefined
			&& transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.texCoord !== undefined ) {

			texture.channel = transform.texCoord;

		}

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q = new Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv1',
	TEXCOORD_2: 'uv2',
	TEXCOORD_3: 'uv3',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	let geometryKey;

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	if ( primitiveDef.targets !== undefined ) {

		for ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {

			geometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );

		}

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

const _identityMatrix = new Matrix4();

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Node cache
		this.nodeCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		let isSafari = false;
		let isFirefox = false;
		let firefoxVersion = - 1;

		if ( typeof navigator !== 'undefined' ) {

			isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
			isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;
			firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

		}

		if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();
		this.nodeCache = {};

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			return Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadNode && ext.loadNode( index );

					} );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					dependency = this._invokeOne( function ( ext ) {

						return ext != this && ext.getDependency && ext.getDependency( type, index );

					} );

					if ( ! dependency ) {

						throw new Error( 'Unknown type: ' + type );

					}

					break;

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];
			const normalized = accessorDef.normalized === true;

			const array = new TypedArray( accessorDef.count * itemSize );
			return Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			texture.name = textureDef.name || sourceDef.name || '';

			if ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {

				texture.name = sourceDef.uri;

			}

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, colorSpace ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			if ( ! texture ) return null;

			if ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {

				texture = texture.clone();
				texture.channel = mapDef.texCoord;

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( colorSpace !== undefined ) {

				texture.colorSpace = colorSpace;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );
				lineMaterial.map = material.map;

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color$1( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			const emissiveFactor = materialDef.emissiveFactor;
			materialParams.emissive = new Color$1().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );

		}

		return Promise.all( pending ).then( function () {

			const material = new materialType( materialParams );

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		if ( sanitizedName in this.nodeNamesUsed ) {

			return sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );

		} else {

			this.nodeNamesUsed[ sanitizedName ] = 0;

			return sanitizedName;

		}

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true ) {

						// normalize skin weights to fix malformed assets (see #15319)
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );

				return meshes[ 0 ];

			}

			const group = new Group();

			if ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const pending = [];

		for ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {

			pending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );

		}

		if ( skinDef.inverseBindMatrices !== undefined ) {

			pending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );

		} else {

			pending.push( null );

		}

		return Promise.all( pending ).then( function ( results ) {

			const inverseBindMatrices = results.pop();
			const jointNodes = results;

			// Note that bones (joint nodes) may or may not be in the
			// scene graph at this time.

			const bones = [];
			const boneInverses = [];

			for ( let i = 0, il = jointNodes.length; i < il; i ++ ) {

				const jointNode = jointNodes[ i ];

				if ( jointNode ) {

					bones.push( jointNode );

					const mat = new Matrix4();

					if ( inverseBindMatrices !== null ) {

						mat.fromArray( inverseBindMatrices.array, i * 16 );

					}

					boneInverses.push( mat );

				} else {

					console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[ i ] );

				}

			}

			return new Skeleton( bones, boneInverses );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;
		const parser = this;

		const animationDef = json.animations[ animationIndex ];
		const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node;
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			if ( target.node === undefined ) continue;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				if ( node.updateMatrix ) {

					node.updateMatrix();

				}

				const createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );

				if ( createdTracks ) {

					for ( let k = 0; k < createdTracks.length; k ++ ) {

						tracks.push( createdTracks[ k ] );

					}

				}

			}

			return new AnimationClip( animationName, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		const nodePending = parser._loadNodeShallow( nodeIndex );

		const childPending = [];
		const childrenDef = nodeDef.children || [];

		for ( let i = 0, il = childrenDef.length; i < il; i ++ ) {

			childPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );

		}

		const skeletonPending = nodeDef.skin === undefined
			? Promise.resolve( null )
			: parser.getDependency( 'skin', nodeDef.skin );

		return Promise.all( [
			nodePending,
			Promise.all( childPending ),
			skeletonPending
		] ).then( function ( results ) {

			const node = results[ 0 ];
			const children = results[ 1 ];
			const skeleton = results[ 2 ];

			if ( skeleton !== null ) {

				// This full traverse should be fine because
				// child glTF nodes have not been added to this node yet.
				node.traverse( function ( mesh ) {

					if ( ! mesh.isSkinnedMesh ) return;

					mesh.bind( skeleton, _identityMatrix );

				} );

			}

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				node.add( children[ i ] );

			}

			return node;

		} );

	}

	// ._loadNodeShallow() parses a single node.
	// skin and child nodes are created and added in .loadNode() (no '_' prefix).
	_loadNodeShallow( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		// This method is called from .loadNode() and .loadSkin().
		// Cache a node to avoid duplication.

		if ( this.nodeCache[ nodeIndex ] !== undefined ) {

			return this.nodeCache[ nodeIndex ];

		}

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		const pending = [];

		const meshPromise = parser._invokeOne( function ( ext ) {

			return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

		} );

		if ( meshPromise ) {

			pending.push( meshPromise );

		}

		if ( nodeDef.camera !== undefined ) {

			pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

				return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

			} ) );

		}

		parser._invokeAll( function ( ext ) {

			return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

		} ).forEach( function ( promise ) {

			pending.push( promise );

		} );

		this.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

		return this.nodeCache[ nodeIndex ];

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( parser.getDependency( 'node', nodeIds[ i ] ) );

		}

		return Promise.all( pending ).then( function ( nodes ) {

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				scene.add( nodes[ i ] );

			}

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

	_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {

		const tracks = [];

		const targetName = node.name ? node.name : node.uuid;
		const targetNames = [];

		if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

			node.traverse( function ( object ) {

				if ( object.morphTargetInfluences ) {

					targetNames.push( object.name ? object.name : object.uuid );

				}

			} );

		} else {

			targetNames.push( targetName );

		}

		let TypedKeyframeTrack;

		switch ( PATH_PROPERTIES[ target.path ] ) {

			case PATH_PROPERTIES.weights:

				TypedKeyframeTrack = NumberKeyframeTrack;
				break;

			case PATH_PROPERTIES.rotation:

				TypedKeyframeTrack = QuaternionKeyframeTrack;
				break;

			case PATH_PROPERTIES.position:
			case PATH_PROPERTIES.scale:

				TypedKeyframeTrack = VectorKeyframeTrack;
				break;

			default:

				switch ( outputAccessor.itemSize ) {

					case 1:
						TypedKeyframeTrack = NumberKeyframeTrack;
						break;
					case 2:
					case 3:
					default:
						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				break;

		}

		const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;


		const outputArray = this._getArrayFromAccessor( outputAccessor );

		for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

			const track = new TypedKeyframeTrack(
				targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
				inputAccessor.array,
				outputArray,
				interpolation
			);

			// Override interpolation with custom factory method.
			if ( sampler.interpolation === 'CUBICSPLINE' ) {

				this._createCubicSplineTrackInterpolant( track );

			}

			tracks.push( track );

		}

		return tracks;

	}

	_getArrayFromAccessor( accessor ) {

		let outputArray = accessor.array;

		if ( accessor.normalized ) {

			const scale = getNormalizedComponentScale( outputArray.constructor );
			const scaled = new Float32Array( outputArray.length );

			for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

				scaled[ j ] = outputArray[ j ] * scale;

			}

			outputArray = scaled;

		}

		return outputArray;

	}

	_createCubicSplineTrackInterpolant( track ) {

		track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

			// A CUBICSPLINE keyframe in glTF has three output values for each input value,
			// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
			// must be divided by three to get the interpolant's sampleSize argument.

			const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

			return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

		};

		// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
		track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

	}

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	if ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {

		console.warn( `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.` );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

const _taskCache = new WeakMap();

class DRACOLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			this.parse( buffer, onLoad, onError );

		}, onProgress, onError );

	}


	parse( buffer, onLoad, onError = ()=>{} ) {

		this.decodeDracoFile( buffer, onLoad, null, null, SRGBColorSpace ).catch( onError );

	}

	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {} ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs,
			vertexColorSpace: vertexColorSpace,
		};

		return this.decodeGeometry( buffer, taskConfig ).then( callback ).catch( onError );

	}

	decodeGeometry( buffer, taskConfig ) {

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const result = geometryData.attributes[ i ];
			const name = result.name;
			const array = result.array;
			const itemSize = result.itemSize;

			const attribute = new BufferAttribute( array, itemSize );

			if ( name === 'color' ) {

				this._assignVertexColorSpace( attribute, result.vertexColorSpace );

				attribute.normalized = ( array instanceof Float32Array ) === false;

			}

			geometry.setAttribute( name, attribute );

		}

		return geometry;

	}

	_assignVertexColorSpace( attribute, inputColorSpace ) {

		// While .drc files do not specify colorspace, the only 'official' tooling
		// is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc
		// file is passed into .load() or .parse(). GLTFLoader uses internal APIs
		// to decode geometry, and vertex colors are already Linear-sRGB in there.

		if ( inputColorSpace !== SRGBColorSpace ) return;

		const _color = new Color$1();

		for ( let i = 0, il = attribute.count; i < il; i ++ ) {

			_color.fromBufferAttribute( attribute, i ).convertSRGBToLinear();
			attribute.setXYZ( i, _color.r, _color.g, _color.b );

		}

	}

	_loadLibrary( url, responseType ) {

		const loader = new FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		if ( this.workerSourceURL !== '' ) {

			URL.revokeObjectURL( this.workerSourceURL );

		}

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}

var DRACO_WASM_WRAPPER_FILE_NAME = "static/draco_wasm_wrapper-6263f3a4b71cdf3b.js";

var DRACO_DECODER_WASM_FILE_NAME = "static/draco_decoder-b048235474cbf09e.wasm";

var DRACO_DECODER_JS_FILE_NAME = "static/draco_decoder-dc7f397e2a2ebac4.js";

// @ts-ignore --  three-refactor
const DRACO_LIB_FILES = {
    'draco_wasm_wrapper.js': DRACO_WASM_WRAPPER_FILE_NAME,
    'draco_decoder.wasm': DRACO_DECODER_WASM_FILE_NAME,
    'draco_decoder.js': DRACO_DECODER_JS_FILE_NAME,
};

class StaticItemLoader {
    constructor(creator) {
        this._gltfLoaderGuard = new AsyncGuard();
        this._creator_ = creator;
        this._initLoaders();
    }
    _initLoaders() {
        this._gltfLoader = new GLTFLoader();
        // three-refactor - DRACOLoader - there is an issue with minification of the DRACOLoader, the minifier destroys the code
        // three-refactor - DRACOLoader - maybe it's an issue of the minifier, maybe updating the minifier is enough :-) but we
        // three-refactor - DRACOLoader - need to decide if we want to go with terser or something new, therefore we skip minification
        // three-refactor - DRACOLoader - for the proof of concept. Since it's an import of DRACOLoader we can not simply exclude only
        // three-refactor - DRACOLoader - the draco loader from minification
        const dracoLoader = new DRACOLoader();
        // We need to monkey patch the _loadLibrary because setDecoderPath only let's us specify a folder
        // because we fingerprint the files the folder name is not enough. The loader needs to know the
        // exact name of the file but this is not possible over an official API so we need to override
        // the private method _loadLibrary
        const oldLoadLib = dracoLoader._loadLibrary.bind(dracoLoader._loadLibrary);
        dracoLoader._loadLibrary = (url, responseType) => {
            const lib = DRACO_LIB_FILES[url];
            if (!lib) {
                throw new Error('Can not load draco dependency "' +
                    url +
                    '" did three.js update DracoLoader lib? Available files' +
                    JSON.stringify(DRACO_LIB_FILES));
            }
            return oldLoadLib(getAssetPath() + lib, responseType);
        };
        dracoLoader.setDecoderConfig({ type: 'wasm' });
        this._gltfLoader.setDRACOLoader(dracoLoader);
        this._gltfLoaderGuard.resolve(this._gltfLoader);
    }
    async loadGLB(url, position, rotation, size, scaling, color, colorable, callback) {
        await this._gltfLoaderGuard.wait();
        return new Promise((resolve, reject) => {
            this._gltfLoader.load(url, (gltf) => {
                resolve(this._handleGLTFScene("GLB" /* STATIC_ITEM_TYPE.GLB */, gltf, position, rotation, size, scaling, color, colorable));
            }, (xhr) => {
                if (callback) {
                    callback(xhr.loaded / xhr.total);
                }
                // EMPTY BLOCK use comment to make tslint quite
            }, (error) => {
                reject(error);
            });
        });
    }
    async loadGLTF(gltfJSON, position, rotation, size, scale, color, colorable, callback) {
        await this._gltfLoaderGuard.wait();
        return new Promise((resolve, reject) => {
            this._gltfLoader.parse(gltfJSON, null, (gltf) => {
                resolve(this._handleGLTFScene("GLTF" /* STATIC_ITEM_TYPE.GLTF */, gltf, position, rotation, size, scale, color, colorable));
            }, (xhr) => {
                if (callback) {
                    callback(xhr.loaded / xhr.total);
                }
                // EMPTY BLOCK use comment to make tslint quite
            }, (error) => {
                reject(error);
            });
        });
    }
    _handleGLTFScene(type, gltf, position, rotation, size, scale, color, colorable) {
        if (!gltf ||
            !gltf.scene ||
            !gltf.scene.children ||
            gltf.scene.children.length === 0) {
            return null;
        }
        if (position) {
            gltf.scene.position.copy(position);
        }
        if (rotation) {
            gltf.scene.rotation.y = rotation;
        }
        const boundingBox = new Box3();
        boundingBox.setFromObject(gltf.scene);
        if (size) {
            const { x, y, z } = boundingBox.getSize(new Vector3());
            let calculatedScale = new Vector3(size.x / x, size.y / y, size.z / z);
            gltf.scene.scale.copy(calculatedScale);
        }
        if (scale) {
            gltf.scene.scale.multiply(scale);
        }
        gltf.scene.type = type;
        gltf.scene.traverse((node) => {
            if (node instanceof Mesh) {
                // set object layer, needed for raycasting
                node.layers.set(3 /* LAYER.OBJECT */);
                if (node.material instanceof MeshStandardMaterial) {
                    const material = node.material;
                    if (colorable && color && color > 0) {
                        let materialColor = new Color$1(color);
                        material.color = materialColor.copySRGBToLinear(materialColor);
                        material.roughness = 0.5;
                        material.metalness = 0.1;
                    }
                    material.needsUpdate = true;
                }
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        return { boundingBox, scene: gltf.scene };
    }
}

const DEFAULT_STORE = 'rml_default';
const DEFAULT_STORE_SIZE = 5;
class LocalStorageHelper {
    constructor(_context_) {
        this._context_ = _context_;
    }
    getStore(storeId = DEFAULT_STORE) {
        const store = this._localStorage.getItem(storeId);
        if (store) {
            return store;
        }
        else {
            return { entries: [] };
        }
    }
    saveStore(storeId, store) {
        this._localStorage.setItem(storeId, store);
    }
    addItem(id, payload, storeId = DEFAULT_STORE, limit = DEFAULT_STORE_SIZE) {
        const store = this.getStore(storeId);
        const item = store.entries.find((entry) => entry.id === id);
        if (item) {
            item.payload = payload;
            item.date = Date.now();
        }
        else {
            store.entries.push({
                id,
                date: Date.now(),
                payload,
            });
        }
        if (store.entries.length > limit) {
            store.entries.sort((a, b) => b.date - a.date);
            // Use a while loop in case we decrease DEFAULT_STORE_SIZE
            while (store.entries.length > limit) {
                store.entries.pop();
            }
        }
        this.saveStore(storeId, store);
    }
    getItem(id, storeId = DEFAULT_STORE) {
        const store = this.getStore(storeId);
        const item = store.entries.find((entry) => entry.id === id);
        if (item) {
            return item.payload;
        }
        return null;
    }
}
__decorate([
    inject
], LocalStorageHelper.prototype, "_localStorage", void 0);

const toRadiant = function (degree) {
    return degree * (Math.PI / 180);
};
const toDegrees = function (radians) {
    return radians * (180 / Math.PI);
};
const getIdealDistance = function (width, height, depth, fov, screenWidth, screenHeight) {
    width = Math.sqrt(width * width + depth * depth);
    const aspectRatio = screenWidth / screenHeight;
    const radianHorizontalFov = (2 * Math.atan(Math.tan((fov * Math.PI) / 180 / 2) * aspectRatio) * 180) /
        Math.PI;
    const radianFOV = toRadiant(fov);
    const fitHeightDistance = height / 2 / Math.tan(radianFOV / 2);
    const fitWidthDistance = width / (2 * Math.atan((Math.PI * radianHorizontalFov) / 360));
    return Math.max(fitHeightDistance, fitWidthDistance);
};
const round = function (x) {
    return Math.round(x * 1000) / 1000;
};
const getDelta = function (v1, v2) {
    // return Math.sqrt(Math.pow(this._downPosition.y - this._position.y, 2) + Math.pow(this._downPosition.x - this._position.x, 2));
    //this calculation is cheaper than pythagoras
    return Math.abs(v1.y - v2.y) + Math.abs(v1.x - v2.x);
};
const getAngle = function (v1, v2) {
    return Math.atan2(v2.y - v1.y, v2.x - v1.x);
};
const to360Degrees = function (radians) {
    let degrees = toDegrees(radians);
    //normalize to 360 degrees
    if (degrees < 0) {
        degrees = 180 + (180 + degrees);
    }
    return degrees;
};

const convertToTHREE = (vector) => {
    return new Vector3(vector.x / 1000, vector.z / 1000, vector.y / -1000);
};
const convertToEuler = (vector) => {
    return new Euler(vector.x, vector.z, -vector.y);
};
const convertToThreeDimensions = (vector) => {
    return new Vector3(vector.x / 1000, vector.z / 1000, vector.y / 1000);
};
const convertToKernel = (vector) => {
    return {
        x: Math.round(vector.x * 1000),
        y: Math.round(vector.z * -1000),
        z: Math.round(vector.y * 1000),
    };
};
const utilityStringToUTF16 = (str) => {
    return decodeURIComponent(encodeURIComponent(str));
};
const convertCObject = (obj) => {
    if (!obj) {
        const typeOfObj = typeof obj;
        if (typeOfObj === 'number' || typeOfObj === 'boolean') {
            return obj;
        }
        return null;
    }
    if (!obj.hasOwnProperty('size') &&
        !!obj.size &&
        typeof obj.size === 'function') {
        let result = utilityToArray(obj);
        for (let i = 0; i < result.length; i++) {
            result[i] = convertCObject(result[i]);
        }
        if (typeof result === 'string') {
            return utilityStringToUTF16(result);
        }
        return result;
    }
    if (typeof obj === 'object') {
        for (let property in obj) {
            if (obj.hasOwnProperty(property)) {
                obj[property] = convertCObject(obj[property]);
            }
        }
    }
    if (typeof obj === 'string') {
        return utilityStringToUTF16(obj);
    }
    return obj;
};
const utilityToArray = (obj) => {
    let result = [];
    if (obj) {
        let size = obj.size();
        for (let i = 0; i < size; i++) {
            result.push(obj.get(i));
        }
    }
    return result;
};
const convertKernelMatrixCoordsToThree = (matrix) => {
    let a = new Matrix4();
    a.set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
    a.scale(new Vector3(1 / 1000, 1 / 1000, 1 / 1000));
    let b = new Matrix4();
    b.set(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
    b.scale(new Vector3(1000, 1000, 1000));
    return a.multiply(matrix).multiply(b);
};
const convertToThreeMatrix = (transform) => {
    let transformMatrix = new Matrix4();
    let transformArray = convertCObject(transform);
    transformMatrix.fromArray(transformArray);
    transformMatrix.transpose();
    return convertKernelMatrixCoordsToThree(transformMatrix);
};
const convertToThreeUVMatrix = (transform) => {
    const uvTransformMatrix = new Matrix4();
    uvTransformMatrix.set(transform[0], transform[2], 0, transform[4], transform[1], transform[3], 0, transform[5], 0, 0, 1, 0, 0, 0, 0, 1);
    return uvTransformMatrix;
};

/**
 * dat-gui JavaScript Controller Library
 * https://github.com/dataarts/dat.gui
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

function ___$insertStyle(css) {
  if (!css) {
    return;
  }
  if (typeof window === 'undefined') {
    return;
  }

  var style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);

  return css;
}

function colorToString (color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString();
  var r = Math.round(color.r);
  var g = Math.round(color.g);
  var b = Math.round(color.b);
  var a = color.a;
  var h = Math.round(color.h);
  var s = color.s.toFixed(1);
  var v = color.v.toFixed(1);
  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
    var str = color.hex.toString(16);
    while (str.length < 6) {
      str = '0' + str;
    }
    return '#' + str;
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')';
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16);
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']';
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
  }
  return 'unknown format';
}

var ARR_EACH = Array.prototype.forEach;
var ARR_SLICE = Array.prototype.slice;
var Common = {
  BREAK: {},
  extend: function extend(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (!this.isUndefined(obj[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  defaults: function defaults(target) {
    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
      var keys = this.isObject(obj) ? Object.keys(obj) : [];
      keys.forEach(function (key) {
        if (this.isUndefined(target[key])) {
          target[key] = obj[key];
        }
      }.bind(this));
    }, this);
    return target;
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments);
    return function () {
      var args = ARR_SLICE.call(arguments);
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)];
      }
      return args[0];
    };
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return;
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope);
    } else if (obj.length === obj.length + 0) {
      var key = void 0;
      var l = void 0;
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return;
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return;
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0);
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0;
    return function () {
      var obj = this;
      var args = arguments;
      function delayed() {
        timeout = null;
        if (!callImmediately) func.apply(obj, args);
      }
      var callNow = callImmediately || !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(delayed, threshold);
      if (callNow) {
        func.apply(obj, args);
      }
    };
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray();
    return ARR_SLICE.call(obj);
  },
  isUndefined: function isUndefined(obj) {
    return obj === undefined;
  },
  isNull: function isNull(obj) {
    return obj === null;
  },
  isNaN: function (_isNaN) {
    function isNaN(_x) {
      return _isNaN.apply(this, arguments);
    }
    isNaN.toString = function () {
      return _isNaN.toString();
    };
    return isNaN;
  }(function (obj) {
    return isNaN(obj);
  }),
  isArray: Array.isArray || function (obj) {
    return obj.constructor === Array;
  },
  isObject: function isObject(obj) {
    return obj === Object(obj);
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0;
  },
  isString: function isString(obj) {
    return obj === obj + '';
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true;
  },
  isFunction: function isFunction(obj) {
    return obj instanceof Function;
  }
};

var INTERPRETATIONS = [
{
  litmus: Common.isString,
  conversions: {
    THREE_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
        };
      },
      write: colorToString
    },
    SIX_CHAR_HEX: {
      read: function read(original) {
        var test = original.match(/^#([A-F0-9]{6})$/i);
        if (test === null) {
          return false;
        }
        return {
          space: 'HEX',
          hex: parseInt('0x' + test[1].toString(), 0)
        };
      },
      write: colorToString
    },
    CSS_RGB: {
      read: function read(original) {
        var test = original.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3])
        };
      },
      write: colorToString
    },
    CSS_RGBA: {
      read: function read(original) {
        var test = original.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        if (test === null) {
          return false;
        }
        return {
          space: 'RGB',
          r: parseFloat(test[1]),
          g: parseFloat(test[2]),
          b: parseFloat(test[3]),
          a: parseFloat(test[4])
        };
      },
      write: colorToString
    }
  }
},
{
  litmus: Common.isNumber,
  conversions: {
    HEX: {
      read: function read(original) {
        return {
          space: 'HEX',
          hex: original,
          conversionName: 'HEX'
        };
      },
      write: function write(color) {
        return color.hex;
      }
    }
  }
},
{
  litmus: Common.isArray,
  conversions: {
    RGB_ARRAY: {
      read: function read(original) {
        if (original.length !== 3) {
          return false;
        }
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b];
      }
    },
    RGBA_ARRAY: {
      read: function read(original) {
        if (original.length !== 4) return false;
        return {
          space: 'RGB',
          r: original[0],
          g: original[1],
          b: original[2],
          a: original[3]
        };
      },
      write: function write(color) {
        return [color.r, color.g, color.b, color.a];
      }
    }
  }
},
{
  litmus: Common.isObject,
  conversions: {
    RGBA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b,
          a: color.a
        };
      }
    },
    RGB_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
          return {
            space: 'RGB',
            r: original.r,
            g: original.g,
            b: original.b
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          r: color.r,
          g: color.g,
          b: color.b
        };
      }
    },
    HSVA_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v,
            a: original.a
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v,
          a: color.a
        };
      }
    },
    HSV_OBJ: {
      read: function read(original) {
        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
          return {
            space: 'HSV',
            h: original.h,
            s: original.s,
            v: original.v
          };
        }
        return false;
      },
      write: function write(color) {
        return {
          h: color.h,
          s: color.s,
          v: color.v
        };
      }
    }
  }
}];
var result = void 0;
var toReturn = void 0;
var interpret = function interpret() {
  toReturn = false;
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original);
        if (toReturn === false && result !== false) {
          toReturn = result;
          result.conversionName = conversionName;
          result.conversion = conversion;
          return Common.BREAK;
        }
      });
      return Common.BREAK;
    }
  });
  return toReturn;
};

var tmpComponent = void 0;
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
    var hi = Math.floor(h / 60) % 6;
    var f = h / 60 - Math.floor(h / 60);
    var p = v * (1.0 - s);
    var q = v * (1.0 - f * s);
    var t = v * (1.0 - (1.0 - f) * s);
    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255
    };
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h = void 0;
    var s = void 0;
    if (max !== 0) {
      s = delta / max;
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0
      };
    }
    if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else {
      h = 4 + (r - g) / delta;
    }
    h /= 6;
    if (h < 0) {
      h += 1;
    }
    return {
      h: h * 360,
      s: s,
      v: max / 255
    };
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r);
    hex = this.hex_with_component(hex, 1, g);
    hex = this.hex_with_component(hex, 0, b);
    return hex;
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return hex >> componentIndex * 8 & 0xFF;
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
  }
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Color = function () {
  function Color() {
    classCallCheck(this, Color);
    this.__state = interpret.apply(this, arguments);
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments');
    }
    this.__state.a = this.__state.a || 1;
  }
  createClass(Color, [{
    key: 'toString',
    value: function toString() {
      return colorToString(this);
    }
  }, {
    key: 'toHexString',
    value: function toHexString() {
      return colorToString(this, true);
    }
  }, {
    key: 'toOriginal',
    value: function toOriginal() {
      return this.__state.conversion.write(this);
    }
  }]);
  return Color;
}();
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'RGB') {
        return this.__state[component];
      }
      Color.recalculateRGB(this, component, componentHexIndex);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex);
        this.__state.space = 'RGB';
      }
      this.__state[component] = v;
    }
  });
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$1() {
      if (this.__state.space === 'HSV') {
        return this.__state[component];
      }
      Color.recalculateHSV(this);
      return this.__state[component];
    },
    set: function set$$1(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this);
        this.__state.space = 'HSV';
      }
      this.__state[component] = v;
    }
  });
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
  } else if (color.__state.space === 'HSV') {
    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
  } else {
    throw new Error('Corrupted color state');
  }
};
Color.recalculateHSV = function (color) {
  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
  Common.extend(color.__state, {
    s: result.s,
    v: result.v
  });
  if (!Common.isNaN(result.h)) {
    color.__state.h = result.h;
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0;
  }
};
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
defineRGBComponent(Color.prototype, 'r', 2);
defineRGBComponent(Color.prototype, 'g', 1);
defineRGBComponent(Color.prototype, 'b', 0);
defineHSVComponent(Color.prototype, 'h');
defineHSVComponent(Color.prototype, 's');
defineHSVComponent(Color.prototype, 'v');
Object.defineProperty(Color.prototype, 'a', {
  get: function get$$1() {
    return this.__state.a;
  },
  set: function set$$1(v) {
    this.__state.a = v;
  }
});
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$1() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
      this.__state.space = 'HEX';
    }
    return this.__state.hex;
  },
  set: function set$$1(v) {
    this.__state.space = 'HEX';
    this.__state.hex = v;
  }
});

var Controller = function () {
  function Controller(object, property) {
    classCallCheck(this, Controller);
    this.initialValue = object[property];
    this.domElement = document.createElement('div');
    this.object = object;
    this.property = property;
    this.__onChange = undefined;
    this.__onFinishChange = undefined;
  }
  createClass(Controller, [{
    key: 'onChange',
    value: function onChange(fnc) {
      this.__onChange = fnc;
      return this;
    }
  }, {
    key: 'onFinishChange',
    value: function onFinishChange(fnc) {
      this.__onFinishChange = fnc;
      return this;
    }
  }, {
    key: 'setValue',
    value: function setValue(newValue) {
      this.object[this.property] = newValue;
      if (this.__onChange) {
        this.__onChange.call(this, newValue);
      }
      this.updateDisplay();
      return this;
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      return this.object[this.property];
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      return this;
    }
  }, {
    key: 'isModified',
    value: function isModified() {
      return this.initialValue !== this.getValue();
    }
  }]);
  return Controller;
}();

var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown']
};
var EVENT_MAP_INV = {};
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k;
  });
});
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0;
  }
  var match = val.match(CSS_VALUE_PIXELS);
  if (!Common.isNull(match)) {
    return parseFloat(match[1]);
  }
  return 0;
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === undefined || elem.style === undefined) return;
    elem.onselectstart = selectable ? function () {
      return false;
    } : function () {};
    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
    elem.unselectable = selectable ? 'on' : 'off';
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert;
    var horizontal = hor;
    if (Common.isUndefined(horizontal)) {
      horizontal = true;
    }
    if (Common.isUndefined(vertical)) {
      vertical = true;
    }
    elem.style.position = 'absolute';
    if (horizontal) {
      elem.style.left = 0;
      elem.style.right = 0;
    }
    if (vertical) {
      elem.style.top = 0;
      elem.style.bottom = 0;
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {};
    var className = EVENT_MAP_INV[eventType];
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.');
    }
    var evt = document.createEvent(className);
    switch (className) {
      case 'MouseEvents':
        {
          var clientX = params.x || params.clientX || 0;
          var clientY = params.y || params.clientY || 0;
          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
          0,
          clientX,
          clientY,
          false, false, false, false, 0, null);
          break;
        }
      case 'KeyboardEvents':
        {
          var init = evt.initKeyboardEvent || evt.initKeyEvent;
          Common.defaults(params, {
            cancelable: true,
            ctrlKey: false,
            altKey: false,
            shiftKey: false,
            metaKey: false,
            keyCode: undefined,
            charCode: undefined
          });
          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
          break;
        }
      default:
        {
          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
          break;
        }
    }
    Common.defaults(evt, aux);
    elem.dispatchEvent(evt);
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func);
    }
    return dom;
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false;
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func);
    }
    return dom;
  },
  addClass: function addClass(elem, className) {
    if (elem.className === undefined) {
      elem.className = className;
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/);
      if (classes.indexOf(className) === -1) {
        classes.push(className);
        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
      }
    }
    return dom;
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class');
      } else {
        var classes = elem.className.split(/ +/);
        var index = classes.indexOf(className);
        if (index !== -1) {
          classes.splice(index, 1);
          elem.className = classes.join(' ');
        }
      }
    } else {
      elem.className = undefined;
    }
    return dom;
  },
  hasClass: function hasClass(elem, className) {
    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem);
    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
  },
  getOffset: function getOffset(el) {
    var elem = el;
    var offset = { left: 0, top: 0 };
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft;
        offset.top += elem.offsetTop;
        elem = elem.offsetParent;
      } while (elem);
    }
    return offset;
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href);
  }
};

var BooleanController = function (_Controller) {
  inherits(BooleanController, _Controller);
  function BooleanController(object, property) {
    classCallCheck(this, BooleanController);
    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
    var _this = _this2;
    _this2.__prev = _this2.getValue();
    _this2.__checkbox = document.createElement('input');
    _this2.__checkbox.setAttribute('type', 'checkbox');
    function onChange() {
      _this.setValue(!_this.__prev);
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false);
    _this2.domElement.appendChild(_this2.__checkbox);
    _this2.updateDisplay();
    return _this2;
  }
  createClass(BooleanController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      this.__prev = this.getValue();
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (this.getValue() === true) {
        this.__checkbox.setAttribute('checked', 'checked');
        this.__checkbox.checked = true;
        this.__prev = true;
      } else {
        this.__checkbox.checked = false;
        this.__prev = false;
      }
      return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return BooleanController;
}(Controller);

var OptionController = function (_Controller) {
  inherits(OptionController, _Controller);
  function OptionController(object, property, opts) {
    classCallCheck(this, OptionController);
    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
    var options = opts;
    var _this = _this2;
    _this2.__select = document.createElement('select');
    if (Common.isArray(options)) {
      var map = {};
      Common.each(options, function (element) {
        map[element] = element;
      });
      options = map;
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option');
      opt.innerHTML = key;
      opt.setAttribute('value', value);
      _this.__select.appendChild(opt);
    });
    _this2.updateDisplay();
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value;
      _this.setValue(desiredValue);
    });
    _this2.domElement.appendChild(_this2.__select);
    return _this2;
  }
  createClass(OptionController, [{
    key: 'setValue',
    value: function setValue(v) {
      var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
      return toReturn;
    }
  }, {
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (dom.isActive(this.__select)) return this;
      this.__select.value = this.getValue();
      return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return OptionController;
}(Controller);

var StringController = function (_Controller) {
  inherits(StringController, _Controller);
  function StringController(object, property) {
    classCallCheck(this, StringController);
    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
    var _this = _this2;
    function onChange() {
      _this.setValue(_this.__input.value);
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'keyup', onChange);
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(StringController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      if (!dom.isActive(this.__input)) {
        this.__input.value = this.getValue();
      }
      return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return StringController;
}(Controller);

function numDecimals(x) {
  var _x = x.toString();
  if (_x.indexOf('.') > -1) {
    return _x.length - _x.indexOf('.') - 1;
  }
  return 0;
}
var NumberController = function (_Controller) {
  inherits(NumberController, _Controller);
  function NumberController(object, property, params) {
    classCallCheck(this, NumberController);
    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
    var _params = params || {};
    _this.__min = _params.min;
    _this.__max = _params.max;
    _this.__step = _params.step;
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1;
      } else {
        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
      }
    } else {
      _this.__impliedStep = _this.__step;
    }
    _this.__precision = numDecimals(_this.__impliedStep);
    return _this;
  }
  createClass(NumberController, [{
    key: 'setValue',
    value: function setValue(v) {
      var _v = v;
      if (this.__min !== undefined && _v < this.__min) {
        _v = this.__min;
      } else if (this.__max !== undefined && _v > this.__max) {
        _v = this.__max;
      }
      if (this.__step !== undefined && _v % this.__step !== 0) {
        _v = Math.round(_v / this.__step) * this.__step;
      }
      return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
    }
  }, {
    key: 'min',
    value: function min(minValue) {
      this.__min = minValue;
      return this;
    }
  }, {
    key: 'max',
    value: function max(maxValue) {
      this.__max = maxValue;
      return this;
    }
  }, {
    key: 'step',
    value: function step(stepValue) {
      this.__step = stepValue;
      this.__impliedStep = stepValue;
      this.__precision = numDecimals(stepValue);
      return this;
    }
  }]);
  return NumberController;
}(Controller);

function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals);
  return Math.round(value * tenTo) / tenTo;
}
var NumberControllerBox = function (_NumberController) {
  inherits(NumberControllerBox, _NumberController);
  function NumberControllerBox(object, property, params) {
    classCallCheck(this, NumberControllerBox);
    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
    _this2.__truncationSuspended = false;
    var _this = _this2;
    var prevY = void 0;
    function onChange() {
      var attempted = parseFloat(_this.__input.value);
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted);
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onBlur() {
      onFinish();
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY;
      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
      prevY = e.clientY;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      onFinish();
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      prevY = e.clientY;
    }
    _this2.__input = document.createElement('input');
    _this2.__input.setAttribute('type', 'text');
    dom.bind(_this2.__input, 'change', onChange);
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__input, 'mousedown', onMouseDown);
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true;
        this.blur();
        _this.__truncationSuspended = false;
        onFinish();
      }
    });
    _this2.updateDisplay();
    _this2.domElement.appendChild(_this2.__input);
    return _this2;
  }
  createClass(NumberControllerBox, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
      return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerBox;
}(NumberController);

function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
}
var NumberControllerSlider = function (_NumberController) {
  inherits(NumberControllerSlider, _NumberController);
  function NumberControllerSlider(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider);
    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
    var _this = _this2;
    _this2.__background = document.createElement('div');
    _this2.__foreground = document.createElement('div');
    dom.bind(_this2.__background, 'mousedown', onMouseDown);
    dom.bind(_this2.__background, 'touchstart', onTouchStart);
    dom.addClass(_this2.__background, 'slider');
    dom.addClass(_this2.__foreground, 'slider-fg');
    function onMouseDown(e) {
      document.activeElement.blur();
      dom.bind(window, 'mousemove', onMouseDrag);
      dom.bind(window, 'mouseup', onMouseUp);
      onMouseDrag(e);
    }
    function onMouseDrag(e) {
      e.preventDefault();
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      return false;
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag);
      dom.unbind(window, 'mouseup', onMouseUp);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return;
      }
      dom.bind(window, 'touchmove', onTouchMove);
      dom.bind(window, 'touchend', onTouchEnd);
      onTouchMove(e);
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX;
      var bgRect = _this.__background.getBoundingClientRect();
      _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove);
      dom.unbind(window, 'touchend', onTouchEnd);
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue());
      }
    }
    _this2.updateDisplay();
    _this2.__background.appendChild(_this2.__foreground);
    _this2.domElement.appendChild(_this2.__background);
    return _this2;
  }
  createClass(NumberControllerSlider, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
      this.__foreground.style.width = pct * 100 + '%';
      return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
    }
  }]);
  return NumberControllerSlider;
}(NumberController);

var FunctionController = function (_Controller) {
  inherits(FunctionController, _Controller);
  function FunctionController(object, property, text) {
    classCallCheck(this, FunctionController);
    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
    var _this = _this2;
    _this2.__button = document.createElement('div');
    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault();
      _this.fire();
      return false;
    });
    dom.addClass(_this2.__button, 'button');
    _this2.domElement.appendChild(_this2.__button);
    return _this2;
  }
  createClass(FunctionController, [{
    key: 'fire',
    value: function fire() {
      if (this.__onChange) {
        this.__onChange.call(this);
      }
      this.getValue().call(this.object);
      if (this.__onFinishChange) {
        this.__onFinishChange.call(this, this.getValue());
      }
    }
  }]);
  return FunctionController;
}(Controller);

var ColorController = function (_Controller) {
  inherits(ColorController, _Controller);
  function ColorController(object, property) {
    classCallCheck(this, ColorController);
    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
    _this2.__color = new Color(_this2.getValue());
    _this2.__temp = new Color(0);
    var _this = _this2;
    _this2.domElement = document.createElement('div');
    dom.makeSelectable(_this2.domElement, false);
    _this2.__selector = document.createElement('div');
    _this2.__selector.className = 'selector';
    _this2.__saturation_field = document.createElement('div');
    _this2.__saturation_field.className = 'saturation-field';
    _this2.__field_knob = document.createElement('div');
    _this2.__field_knob.className = 'field-knob';
    _this2.__field_knob_border = '2px solid ';
    _this2.__hue_knob = document.createElement('div');
    _this2.__hue_knob.className = 'hue-knob';
    _this2.__hue_field = document.createElement('div');
    _this2.__hue_field.className = 'hue-field';
    _this2.__input = document.createElement('input');
    _this2.__input.type = 'text';
    _this2.__input_textShadow = '0 1px 1px ';
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this);
      }
    });
    dom.bind(_this2.__input, 'blur', onBlur);
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag');
      });
    });
    var valueField = document.createElement('div');
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
    });
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1
    });
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1
    });
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer'
    });
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none'
    });
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px'
    });
    hueGradient(_this2.__hue_field);
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
    });
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
    function fieldDown(e) {
      setSV(e);
      dom.bind(window, 'mousemove', setSV);
      dom.bind(window, 'touchmove', setSV);
      dom.bind(window, 'mouseup', fieldUpSV);
      dom.bind(window, 'touchend', fieldUpSV);
    }
    function fieldDownH(e) {
      setH(e);
      dom.bind(window, 'mousemove', setH);
      dom.bind(window, 'touchmove', setH);
      dom.bind(window, 'mouseup', fieldUpH);
      dom.bind(window, 'touchend', fieldUpH);
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV);
      dom.unbind(window, 'touchmove', setSV);
      dom.unbind(window, 'mouseup', fieldUpSV);
      dom.unbind(window, 'touchend', fieldUpSV);
      onFinish();
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH);
      dom.unbind(window, 'touchmove', setH);
      dom.unbind(window, 'mouseup', fieldUpH);
      dom.unbind(window, 'touchend', fieldUpH);
      onFinish();
    }
    function onBlur() {
      var i = interpret(this.value);
      if (i !== false) {
        _this.__color.__state = i;
        _this.setValue(_this.__color.toOriginal());
      } else {
        this.value = _this.__color.toString();
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
      }
    }
    _this2.__saturation_field.appendChild(valueField);
    _this2.__selector.appendChild(_this2.__field_knob);
    _this2.__selector.appendChild(_this2.__saturation_field);
    _this2.__selector.appendChild(_this2.__hue_field);
    _this2.__hue_field.appendChild(_this2.__hue_knob);
    _this2.domElement.appendChild(_this2.__input);
    _this2.domElement.appendChild(_this2.__selector);
    _this2.updateDisplay();
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect();
      var _ref = e.touches && e.touches[0] || e,
          clientX = _ref.clientX,
          clientY = _ref.clientY;
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (s > 1) {
        s = 1;
      } else if (s < 0) {
        s = 0;
      }
      _this.__color.v = v;
      _this.__color.s = s;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault();
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect();
      var _ref2 = e.touches && e.touches[0] || e,
          clientY = _ref2.clientY;
      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
      if (h > 1) {
        h = 1;
      } else if (h < 0) {
        h = 0;
      }
      _this.__color.h = h * 360;
      _this.setValue(_this.__color.toOriginal());
      return false;
    }
    return _this2;
  }
  createClass(ColorController, [{
    key: 'updateDisplay',
    value: function updateDisplay() {
      var i = interpret(this.getValue());
      if (i !== false) {
        var mismatch = false;
        Common.each(Color.COMPONENTS, function (component) {
          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
            mismatch = true;
            return {};
          }
        }, this);
        if (mismatch) {
          Common.extend(this.__color.__state, i);
        }
      }
      Common.extend(this.__temp.__state, this.__color.__state);
      this.__temp.a = 1;
      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
      var _flip = 255 - flip;
      Common.extend(this.__field_knob.style, {
        marginLeft: 100 * this.__color.s - 7 + 'px',
        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
        backgroundColor: this.__temp.toHexString(),
        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
      });
      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
      this.__temp.s = 1;
      this.__temp.v = 1;
      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
      this.__input.value = this.__color.toString();
      Common.extend(this.__input.style, {
        backgroundColor: this.__color.toHexString(),
        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
      });
    }
  }]);
  return ColorController;
}(Controller);
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
function linearGradient(elem, x, a, b) {
  elem.style.background = '';
  Common.each(vendors, function (vendor) {
    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
  });
}
function hueGradient(elem) {
  elem.style.background = '';
  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
}

var css = {
  load: function load(url, indoc) {
    var doc = indoc || document;
    var link = doc.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';
    link.href = url;
    doc.getElementsByTagName('head')[0].appendChild(link);
  },
  inject: function inject(cssContent, indoc) {
    var doc = indoc || document;
    var injected = document.createElement('style');
    injected.type = 'text/css';
    injected.innerHTML = cssContent;
    var head = doc.getElementsByTagName('head')[0];
    try {
      head.appendChild(injected);
    } catch (e) {
    }
  }
};

var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

var ControllerFactory = function ControllerFactory(object, property) {
  var initialValue = object[property];
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2]);
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
      }
      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
    }
    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property);
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '');
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property);
  }
  return null;
};

function requestAnimationFrame(callback) {
  setTimeout(callback, 1000 / 60);
}
var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

var CenteredDiv = function () {
  function CenteredDiv() {
    classCallCheck(this, CenteredDiv);
    this.backgroundElement = document.createElement('div');
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear'
    });
    dom.makeFullscreen(this.backgroundElement);
    this.backgroundElement.style.position = 'fixed';
    this.domElement = document.createElement('div');
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
    });
    document.body.appendChild(this.backgroundElement);
    document.body.appendChild(this.domElement);
    var _this = this;
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide();
    });
  }
  createClass(CenteredDiv, [{
    key: 'show',
    value: function show() {
      var _this = this;
      this.backgroundElement.style.display = 'block';
      this.domElement.style.display = 'block';
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
      this.layout();
      Common.defer(function () {
        _this.backgroundElement.style.opacity = 1;
        _this.domElement.style.opacity = 1;
        _this.domElement.style.webkitTransform = 'scale(1)';
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this = this;
      var hide = function hide() {
        _this.domElement.style.display = 'none';
        _this.backgroundElement.style.display = 'none';
        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
        dom.unbind(_this.domElement, 'transitionend', hide);
        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
      };
      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
      dom.bind(this.domElement, 'transitionend', hide);
      dom.bind(this.domElement, 'oTransitionEnd', hide);
      this.backgroundElement.style.opacity = 0;
      this.domElement.style.opacity = 0;
      this.domElement.style.webkitTransform = 'scale(1.1)';
    }
  }, {
    key: 'layout',
    value: function layout() {
      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
    }
  }]);
  return CenteredDiv;
}();

var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

css.inject(styleSheet);
var CSS_NAMESPACE = 'dg';
var HIDE_KEY_CODE = 72;
var CLOSE_BUTTON_HEIGHT = 20;
var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
var SUPPORTS_LOCAL_STORAGE = function () {
  try {
    return !!window.localStorage;
  } catch (e) {
    return false;
  }
}();
var SAVE_DIALOGUE = void 0;
var autoPlaceVirgin = true;
var autoPlaceContainer = void 0;
var hide = false;
var hideableGuis = [];
var GUI = function GUI(pars) {
  var _this = this;
  var params = pars || {};
  this.domElement = document.createElement('div');
  this.__ul = document.createElement('ul');
  this.domElement.appendChild(this.__ul);
  dom.addClass(this.domElement, CSS_NAMESPACE);
  this.__folders = {};
  this.__controllers = [];
  this.__rememberedObjects = [];
  this.__rememberedObjectIndecesToControllers = [];
  this.__listening = [];
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI.DEFAULT_WIDTH
  });
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace
  });
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset;
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this);
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable;
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true;
  }
  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
  var saveToLocalStorage = void 0;
  var titleRow = void 0;
  Object.defineProperties(this,
  {
    parent: {
      get: function get$$1() {
        return params.parent;
      }
    },
    scrollable: {
      get: function get$$1() {
        return params.scrollable;
      }
    },
    autoPlace: {
      get: function get$$1() {
        return params.autoPlace;
      }
    },
    closeOnTop: {
      get: function get$$1() {
        return params.closeOnTop;
      }
    },
    preset: {
      get: function get$$1() {
        if (_this.parent) {
          return _this.getRoot().preset;
        }
        return params.load.preset;
      },
      set: function set$$1(v) {
        if (_this.parent) {
          _this.getRoot().preset = v;
        } else {
          params.load.preset = v;
        }
        setPresetSelectIndex(this);
        _this.revert();
      }
    },
    width: {
      get: function get$$1() {
        return params.width;
      },
      set: function set$$1(v) {
        params.width = v;
        setWidth(_this, v);
      }
    },
    name: {
      get: function get$$1() {
        return params.name;
      },
      set: function set$$1(v) {
        params.name = v;
        if (titleRow) {
          titleRow.innerHTML = params.name;
        }
      }
    },
    closed: {
      get: function get$$1() {
        return params.closed;
      },
      set: function set$$1(v) {
        params.closed = v;
        if (params.closed) {
          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
        } else {
          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
        }
        this.onResize();
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
        }
      }
    },
    load: {
      get: function get$$1() {
        return params.load;
      }
    },
    useLocalStorage: {
      get: function get$$1() {
        return useLocalStorage;
      },
      set: function set$$1(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool;
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage);
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage);
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
        }
      }
    }
  });
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false;
    dom.addClass(this.domElement, GUI.CLASS_MAIN);
    dom.makeSelectable(this.domElement, false);
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true;
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
        if (savedGui) {
          params.load = JSON.parse(savedGui);
        }
      }
    }
    this.__closeButton = document.createElement('div');
    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
    } else {
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
      this.domElement.appendChild(this.__closeButton);
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed;
    });
  } else {
    if (params.closed === undefined) {
      params.closed = true;
    }
    var titleRowName = document.createTextNode(params.name);
    dom.addClass(titleRowName, 'controller-name');
    titleRow = addRow(_this, titleRowName);
    var onClickTitle = function onClickTitle(e) {
      e.preventDefault();
      _this.closed = !_this.closed;
      return false;
    };
    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
    dom.addClass(titleRow, 'title');
    dom.bind(titleRow, 'click', onClickTitle);
    if (!params.closed) {
      this.closed = false;
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div');
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
        document.body.appendChild(autoPlaceContainer);
        autoPlaceVirgin = false;
      }
      autoPlaceContainer.appendChild(this.domElement);
      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
    }
    if (!this.parent) {
      setWidth(_this, params.width);
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced();
  };
  dom.bind(window, 'resize', this.__resizeHandler);
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
  this.onResize();
  if (params.resizable) {
    addResizeHandle(this);
  }
  saveToLocalStorage = function saveToLocalStorage() {
    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
    }
  };
  this.saveToLocalStorageIfPossible = saveToLocalStorage;
  function resetWidth() {
    var root = _this.getRoot();
    root.width += 1;
    Common.defer(function () {
      root.width -= 1;
    });
  }
  if (!params.parent) {
    resetWidth();
  }
};
GUI.toggleHide = function () {
  hide = !hide;
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : '';
  });
};
GUI.CLASS_AUTO_PLACE = 'a';
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
GUI.CLASS_MAIN = 'main';
GUI.CLASS_CONTROLLER_ROW = 'cr';
GUI.CLASS_TOO_TALL = 'taller-than-window';
GUI.CLASS_CLOSED = 'closed';
GUI.CLASS_CLOSE_BUTTON = 'close-button';
GUI.CLASS_CLOSE_TOP = 'close-top';
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
GUI.CLASS_DRAG = 'drag';
GUI.DEFAULT_WIDTH = 245;
GUI.TEXT_CLOSED = 'Close Controls';
GUI.TEXT_OPEN = 'Open Controls';
GUI._keydownHandler = function (e) {
  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
    GUI.toggleHide();
  }
};
dom.bind(window, 'keydown', GUI._keydownHandler, false);
Common.extend(GUI.prototype,
{
  add: function add(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2)
    });
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true
    });
  },
  remove: function remove(controller) {
    this.__ul.removeChild(controller.__li);
    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
    var _this = this;
    Common.defer(function () {
      _this.onResize();
    });
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement);
    }
    var _this = this;
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder);
    });
    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
    removeListeners(this);
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== undefined) {
      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
    }
    var newGuiParams = { name: name, parent: this };
    newGuiParams.autoPlace = this.autoPlace;
    if (this.load &&
    this.load.folders &&
    this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed;
      newGuiParams.load = this.load.folders[name];
    }
    var gui = new GUI(newGuiParams);
    this.__folders[name] = gui;
    var li = addRow(this, gui.domElement);
    dom.addClass(li, 'folder');
    return gui;
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement);
    delete this.__folders[folder.name];
    if (this.load &&
    this.load.folders &&
    this.load.folders[folder.name]) {
      delete this.load.folders[folder.name];
    }
    removeListeners(folder);
    var _this = this;
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder);
    });
    Common.defer(function () {
      _this.onResize();
    });
  },
  open: function open() {
    this.closed = false;
  },
  close: function close() {
    this.closed = true;
  },
  hide: function hide() {
    this.domElement.style.display = 'none';
  },
  show: function show() {
    this.domElement.style.display = '';
  },
  onResize: function onResize() {
    var root = this.getRoot();
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top;
      var h = 0;
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h += dom.getHeight(node);
        }
      });
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
        root.__ul.style.height = 'auto';
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
      });
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px';
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize();
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv();
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.');
    }
    var _this = this;
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this);
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object);
      }
    });
    if (this.autoPlace) {
      setWidth(this, this.width);
    }
  },
  getRoot: function getRoot() {
    var gui = this;
    while (gui.parent) {
      gui = gui.parent;
    }
    return gui;
  },
  getSaveObject: function getSaveObject() {
    var toReturn = this.load;
    toReturn.closed = this.closed;
    if (this.__rememberedObjects.length > 0) {
      toReturn.preset = this.preset;
      if (!toReturn.remembered) {
        toReturn.remembered = {};
      }
      toReturn.remembered[this.preset] = getCurrentPreset(this);
    }
    toReturn.folders = {};
    Common.each(this.__folders, function (element, key) {
      toReturn.folders[key] = element.getSaveObject();
    });
    return toReturn;
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {};
    }
    this.load.remembered[this.preset] = getCurrentPreset(this);
    markPresetModified(this, false);
    this.saveToLocalStorageIfPossible();
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {};
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
    }
    this.load.remembered[presetName] = getCurrentPreset(this);
    this.preset = presetName;
    addPresetOption(this, presetName, true);
    this.saveToLocalStorageIfPossible();
  },
  revert: function revert(gui) {
    Common.each(this.__controllers, function (controller) {
      if (!this.getRoot().load.remembered) {
        controller.setValue(controller.initialValue);
      } else {
        recallSavedValue(gui || this.getRoot(), controller);
      }
      if (controller.__onFinishChange) {
        controller.__onFinishChange.call(controller, controller.getValue());
      }
    }, this);
    Common.each(this.__folders, function (folder) {
      folder.revert(folder);
    });
    if (!gui) {
      markPresetModified(this.getRoot(), false);
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0;
    this.__listening.push(controller);
    if (init) {
      updateDisplays(this.__listening);
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay();
    });
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay();
    });
  }
});
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li');
  if (newDom) {
    li.appendChild(newDom);
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore);
  } else {
    gui.__ul.appendChild(li);
  }
  gui.onResize();
  return li;
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler);
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
  if (modified) {
    opt.innerHTML = opt.value + '*';
  } else {
    opt.innerHTML = opt.value;
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li;
  controller.__gui = gui;
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)]
        });
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling;
        controller.remove();
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options]
        });
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
      return controller;
    },
    listen: function listen() {
      controller.__gui.listen(controller);
      return controller;
    },
    remove: function remove() {
      controller.__gui.remove(controller);
      return controller;
    }
  });
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
      var pc = controller[method];
      var pb = box[method];
      controller[method] = box[method] = function () {
        var args = Array.prototype.slice.call(arguments);
        pb.apply(box, args);
        return pc.apply(controller, args);
      };
    });
    dom.addClass(li, 'has-slider');
    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
  } else if (controller instanceof NumberControllerBox) {
    var r = function r(returned) {
      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
        controller.remove();
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step]
        });
        newController.name(oldName);
        if (wasListening) newController.listen();
        return newController;
      }
      return returned;
    };
    controller.min = Common.compose(r, controller.min);
    controller.max = Common.compose(r, controller.max);
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click');
    });
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation();
    });
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click');
    });
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover');
    });
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover');
    });
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString();
      return val;
    }, controller.updateDisplay);
    controller.updateDisplay();
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true);
    }
    return val;
  }, controller.setValue);
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot();
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
  if (matchedIndex !== -1) {
    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
    if (controllerMap === undefined) {
      controllerMap = {};
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
    }
    controllerMap[controller.property] = controller;
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered;
      var preset = void 0;
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset];
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
      } else {
        return;
      }
      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
        var value = preset[matchedIndex][controller.property];
        controller.initialValue = value;
        controller.setValue(value);
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === undefined) {
    throw new Error('Object "' + object + '" has no property "' + property + '"');
  }
  var controller = void 0;
  if (params.color) {
    controller = new ColorController(object, property);
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs);
    controller = ControllerFactory.apply(gui, factoryArgs);
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li;
  }
  recallSavedValue(gui, controller);
  dom.addClass(controller.domElement, 'c');
  var name = document.createElement('span');
  dom.addClass(name, 'property-name');
  name.innerHTML = controller.property;
  var container = document.createElement('div');
  container.appendChild(name);
  container.appendChild(controller.domElement);
  var li = addRow(gui, container, params.before);
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color');
  } else {
    dom.addClass(li, _typeof(controller.getValue()));
  }
  augmentController(gui, li, controller);
  gui.__controllers.push(controller);
  return controller;
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key;
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option');
  opt.innerHTML = name;
  opt.value = name;
  gui.__preset_select.appendChild(opt);
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
}
function addSaveMenu(gui) {
  var div = gui.__save_row = document.createElement('li');
  dom.addClass(gui.domElement, 'has-save');
  gui.__ul.insertBefore(div, gui.__ul.firstChild);
  dom.addClass(div, 'save-row');
  var gears = document.createElement('span');
  gears.innerHTML = '&nbsp;';
  dom.addClass(gears, 'button gears');
  var button = document.createElement('span');
  button.innerHTML = 'Save';
  dom.addClass(button, 'button');
  dom.addClass(button, 'save');
  var button2 = document.createElement('span');
  button2.innerHTML = 'New';
  dom.addClass(button2, 'button');
  dom.addClass(button2, 'save-as');
  var button3 = document.createElement('span');
  button3.innerHTML = 'Revert';
  dom.addClass(button3, 'button');
  dom.addClass(button3, 'revert');
  var select = gui.__preset_select = document.createElement('select');
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset);
    });
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
    }
    gui.preset = this.value;
  });
  div.appendChild(select);
  div.appendChild(gears);
  div.appendChild(button);
  div.appendChild(button2);
  div.appendChild(button3);
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain');
    var localStorageCheckBox = document.getElementById('dg-local-storage');
    var saveLocally = document.getElementById('dg-save-locally');
    saveLocally.style.display = 'block';
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked');
    }
    showHideExplain(gui, explain);
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage;
      showHideExplain(gui, explain);
    });
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor');
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide();
    }
  });
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
    SAVE_DIALOGUE.show();
    newConstructorTextArea.focus();
    newConstructorTextArea.select();
  });
  dom.bind(button, 'click', function () {
    gui.save();
  });
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.');
    if (presetName) {
      gui.saveAs(presetName);
    }
  });
  dom.bind(button3, 'click', function () {
    gui.revert();
  });
}
function addResizeHandle(gui) {
  var pmouseX = void 0;
  gui.__resize_handle = document.createElement('div');
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute'
  });
  function drag(e) {
    e.preventDefault();
    gui.width += pmouseX - e.clientX;
    gui.onResize();
    pmouseX = e.clientX;
    return false;
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.unbind(window, 'mousemove', drag);
    dom.unbind(window, 'mouseup', dragStop);
  }
  function dragStart(e) {
    e.preventDefault();
    pmouseX = e.clientX;
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
    dom.bind(window, 'mousemove', drag);
    dom.bind(window, 'mouseup', dragStop);
    return false;
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
  dom.bind(gui.__closeButton, 'mousedown', dragStart);
  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px';
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px';
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px';
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn = {};
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {};
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
    });
    toReturn[index] = savedValues;
  });
  return toReturn;
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index;
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame$1.call(window, function () {
      updateDisplays(controllerArray);
    });
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay();
  });
}
var GUI$1 = GUI;

class MaterialCreator {
    static createMeshPhysicalMaterial(params) {
        return new MeshPhysicalMaterial(params);
    }
    static createMeshStandardMaterial(params) {
        return new MeshStandardMaterial(params);
    }
}

const PREVIEW_LINE_MATERIAL_OPACITY = 0.4;
const PREVIEW_MATERIAL_COLOR = '#DDDDDD';
const PREVIEW_MATERIAL_ROUGHNESS = 1;
const PREVIEW_MATERIAL_METALNESS = 0;
const PREVIEW_MATERIAL_OPACITY = 1;
const DOCK_PREVIEW_MATERIAL_ROUGHNESS = 1;
const DOCK_PREVIEW_MATERIAL_METALNESS = 0;
const DOCK_PREVIEW_MATERIAL_OPACITY = 0.8;
const DOCK_PREVIEW_MATERIAL_OPACITY_HOVERED = 0.9;
const getScreenXY = (obj, camera, clientWidth, clientHeight) => {
    if (!obj || !camera || clientWidth === 0 || clientHeight === 0) {
        return new Vector3();
    }
    let vector = obj.clone();
    let widthHalf = clientWidth / 2;
    let heightHalf = clientHeight / 2;
    vector.project(camera);
    vector.x = Math.floor(vector.x * widthHalf + widthHalf);
    vector.y = Math.floor(-(vector.y * heightHalf) + heightHalf);
    vector.z = obj.distanceTo(camera.position);
    return vector;
};
const kernelBoxToThreeBox = (kernelCube, margin) => {
    if (!margin) {
        margin = new Vector3(0, 0, 0);
    }
    let bounds = new Vector3(kernelCube.size.x / 1000, kernelCube.size.z / 1000, kernelCube.size.y / 1000);
    let boxOrigin = new Vector3(kernelCube.origin.x / 1000, kernelCube.origin.z / 1000, kernelCube.origin.y / -1000);
    let lineMinVector = new Vector3(0, 0, -bounds.z)
        .add(boxOrigin)
        .sub(margin);
    let lineMaxVector = new Vector3(bounds.x, bounds.y, 0)
        .add(boxOrigin)
        .add(margin);
    return new Box3(lineMinVector, lineMaxVector);
};
const kernelDimensioningToThree = (dimensions) => {
    dimensions.from = dimensions.from / 1000;
    dimensions.to = dimensions.to / 1000;
    if (dimensions.type.value === 1 /* DIMENSIONING_TYPE.Y */) {
        dimensions.type = { value: 2 /* DIMENSIONING_TYPE.Z */ };
        dimensions.from *= -1;
        dimensions.to *= -1;
    }
    else if (dimensions.type.value === 2 /* DIMENSIONING_TYPE.Z */) {
        dimensions.type = { value: 1 /* DIMENSIONING_TYPE.Y */ };
    }
    return dimensions;
};
const position3VectorsAreEqual = (a, b) => {
    let aX = round(a.x);
    let aY = round(a.y);
    let aZ = round(a.z);
    let bX = round(b.x);
    let bY = round(b.y);
    let bZ = round(b.z);
    return aX === bX && aY === bY && aZ === bZ;
};
const rotationQuaternionsAreEqual = (a, b) => {
    let aW = round(a.w);
    let aX = round(a.x);
    let aY = round(a.y);
    let aZ = round(a.z);
    let bW = round(b.w);
    let bX = round(b.x);
    let bY = round(b.y);
    let bZ = round(b.z);
    return aW === bW && aX === bX && aY === bY && aZ === bZ;
};
const position2VectorsAreEqual = (a, b) => {
    let aX = round(a.x);
    let aY = round(a.y);
    let bX = round(b.x);
    let bY = round(b.y);
    return aX === bX && aY === bY;
};
let whiteTexture = null;
const getWhiteTexture = () => {
    if (whiteTexture) {
        return whiteTexture;
    }
    const width = 1;
    const height = 1;
    const size = width * height;
    const data = new Uint8Array(4 * size);
    for (let i = 0; i < size; i++) {
        const stride = i * 4;
        data[stride] = 255;
        data[stride + 1] = 255;
        data[stride + 2] = 255;
        data[stride + 3] = 255;
    }
    const texture = new DataTexture(data, width, height, RGBAFormat$1);
    texture.needsUpdate = true;
    return texture;
};
const createColorTexture = (red, green, blue, alpha) => {
    const data = new Uint8Array(4);
    const r = Math.floor(red * 255);
    const g = Math.floor(green * 255);
    const b = Math.floor(blue * 255);
    const a = Math.floor(alpha * 255);
    for (let i = 0; i < 4; i++) {
        const stride = i * 4;
        data[stride] = r;
        data[stride + 1] = g;
        data[stride + 2] = b;
        data[stride + 3] = a;
    }
    const texture = new DataTexture(data, 1, 1, RGBAFormat$1);
    texture.needsUpdate = true;
    return texture;
};
const createColorCubeTexture = (red, green, blue, alpha) => {
    const cubeTexture = new CubeTexture();
    cubeTexture.format = RGBAFormat$1;
    cubeTexture.generateMipmaps = false;
    for (let i = 0; i < 6; ++i) {
        const dataTexture = createColorTexture(red, green, blue, alpha);
        dataTexture.format = cubeTexture.format;
        dataTexture.type = cubeTexture.type;
        dataTexture.minFilter = cubeTexture.minFilter;
        dataTexture.magFilter = cubeTexture.magFilter;
        dataTexture.generateMipmaps = cubeTexture.generateMipmaps;
        dataTexture.needsUpdate = true;
        cubeTexture.images[i] = dataTexture;
    }
    cubeTexture.needsUpdate = true;
    return cubeTexture;
};
const createMaterial = (material) => {
    return setMaterial(null, material);
};
// eslint-disable-next-line complexity
const setMaterial = (meshPhysicalMaterial, rapiMaterial) => {
    var _a;
    if (!meshPhysicalMaterial) {
        meshPhysicalMaterial = createMeshPhysicalMaterial();
    }
    meshPhysicalMaterial.name = rapiMaterial.id ? rapiMaterial.id.toString() : '';
    const isV2Material = rapiMaterial.shading.version === '2' ||
        ((_a = rapiMaterial.shading.version) === null || _a === void 0 ? void 0 : _a.startsWith('2.'));
    meshPhysicalMaterial = isV2Material
        ? _setMaterialV2Properties(meshPhysicalMaterial, rapiMaterial)
        : _setMaterialV1Properties(meshPhysicalMaterial, rapiMaterial);
    meshPhysicalMaterial.userData.materialVersion = isV2Material ? 2 : 1;
    if (!meshPhysicalMaterial.map) {
        if (!whiteTexture) {
            whiteTexture = getWhiteTexture();
        }
        // this is a workaround because materials are displayed wrong on some mobile devices (Pixel 3 for example)
        // when a material has only a color but no texture
        meshPhysicalMaterial.map = whiteTexture;
    }
    return meshPhysicalMaterial;
};
const _setMaterialV1Properties = (meshPhysicalMaterial, rapiMaterial) => {
    if (rapiMaterial.shading.metallic !== undefined) {
        meshPhysicalMaterial.metalness =
            rapiMaterial.shading.metallic === 1 ? 1 : 0.5;
        meshPhysicalMaterial.reflectivity = getValue(rapiMaterial.shading.metallic, 0.5); //three.js default is 0.5
    }
    let forceDoubleSide = false; // for backwards compatibility
    if (rapiMaterial.shading.transmission &&
        rapiMaterial.shading.transmission > 0) {
        // disabled transmission compatibility mode to improve performance and be compatible with pixotronics renderer
        // meshPhysicalMaterial.transmission = rapiMaterial.shading.transmission;
        meshPhysicalMaterial.opacity = 1 - rapiMaterial.shading.transmission;
        meshPhysicalMaterial.transparent = true;
        meshPhysicalMaterial.depthWrite = false;
        meshPhysicalMaterial.metalness = 0;
        forceDoubleSide = true;
    }
    else if (rapiMaterial.shading.alpha !== undefined &&
        rapiMaterial.shading.alpha < 1) {
        meshPhysicalMaterial.transparent = rapiMaterial.shading.alpha < 1;
        meshPhysicalMaterial.opacity = rapiMaterial.shading.alpha;
        meshPhysicalMaterial.depthWrite = rapiMaterial.shading.alpha >= 1;
        // modulate metalness with alpha channel for backwards compatibility
        meshPhysicalMaterial.metalness =
            0.5 * Math.max(0, rapiMaterial.shading.alpha);
        forceDoubleSide = true;
    }
    meshPhysicalMaterial.aoMapIntensity = getValue(rapiMaterial.shading.occlusion, 1);
    meshPhysicalMaterial.roughness = getValue(rapiMaterial.shading.roughness, 0.5); //three.js default is 0.5
    meshPhysicalMaterial.alphaTest = getValue(rapiMaterial.shading.alphaCutoff, 0);
    _setColor(meshPhysicalMaterial.color, rapiMaterial.shading.basecolor);
    if (forceDoubleSide || rapiMaterial.shading.doubleSided) {
        meshPhysicalMaterial.side = DoubleSide;
    }
    else {
        meshPhysicalMaterial.side = FrontSide;
    }
    return meshPhysicalMaterial;
};
// To fulfill the "eslint" complexity rule, we would have to split this function into at least 3 functions.
// This is pointless, as this function does exactly one thing, namely map "RapiMaterial" to "MeshPhysicalMaterial".
// eslint-disable-next-line complexity
const _setMaterialV2Properties = (meshPhysicalMaterial, rapiMaterial) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    let forceDoubleSide = false; // for backwards compatibility
    if (rapiMaterial.shading.alpha !== undefined &&
        rapiMaterial.shading.alpha < 1) {
        meshPhysicalMaterial.transparent = true;
        meshPhysicalMaterial.opacity = rapiMaterial.shading.alpha;
        meshPhysicalMaterial.depthWrite = false;
        forceDoubleSide = true;
    }
    else {
        meshPhysicalMaterial.transparent = false;
        meshPhysicalMaterial.opacity = 1;
        meshPhysicalMaterial.depthWrite = true;
    }
    meshPhysicalMaterial.alphaTest = (_a = rapiMaterial.shading.alphaCutoff) !== null && _a !== void 0 ? _a : 0;
    _setColor(meshPhysicalMaterial.color, rapiMaterial.shading.basecolor);
    meshPhysicalMaterial.transmission = (_b = rapiMaterial.shading.transmission) !== null && _b !== void 0 ? _b : 0;
    meshPhysicalMaterial.ior =
        (_c = Math.max(1.0, Math.min(2.33, rapiMaterial.shading.transmissionIOR))) !== null && _c !== void 0 ? _c : 1.5;
    meshPhysicalMaterial.metalness = (_d = rapiMaterial.shading.metallic) !== null && _d !== void 0 ? _d : 0;
    _setColor(meshPhysicalMaterial.specularColor, rapiMaterial.shading.specularColor);
    meshPhysicalMaterial.specularIntensity =
        (_e = rapiMaterial.shading.specularity) !== null && _e !== void 0 ? _e : 0;
    meshPhysicalMaterial.roughness = (_f = rapiMaterial.shading.roughness) !== null && _f !== void 0 ? _f : 0;
    meshPhysicalMaterial.aoMapIntensity = (_g = rapiMaterial.shading.occlusion) !== null && _g !== void 0 ? _g : 1;
    _setColor(meshPhysicalMaterial.emissive, rapiMaterial.shading.emissiveColor);
    meshPhysicalMaterial.emissiveIntensity =
        (_h = rapiMaterial.shading.emissiveIntensity) !== null && _h !== void 0 ? _h : 1;
    meshPhysicalMaterial.clearcoat = (_j = rapiMaterial.shading.clearcoatIntensity) !== null && _j !== void 0 ? _j : 0;
    meshPhysicalMaterial.clearcoatRoughness =
        (_k = rapiMaterial.shading.clearcoatRoughness) !== null && _k !== void 0 ? _k : 0;
    meshPhysicalMaterial.clearcoatNormalScale.setScalar((_l = rapiMaterial.shading.clearcoatNormalScale) !== null && _l !== void 0 ? _l : 1);
    _setColor(meshPhysicalMaterial.sheenColor, rapiMaterial.shading.sheenColor);
    meshPhysicalMaterial.sheen = (_m = rapiMaterial.shading.sheenIntensity) !== null && _m !== void 0 ? _m : 1;
    meshPhysicalMaterial.sheenRoughness =
        (_o = rapiMaterial.shading.sheenRoughness) !== null && _o !== void 0 ? _o : 1;
    meshPhysicalMaterial.thickness = (_p = rapiMaterial.shading.thicknessFactor) !== null && _p !== void 0 ? _p : 0;
    _setColor(meshPhysicalMaterial.attenuationColor, rapiMaterial.shading.attenuationColor);
    if (rapiMaterial.shading.attenuationDistance) {
        meshPhysicalMaterial.attenuationDistance =
            rapiMaterial.shading.attenuationDistance;
    }
    meshPhysicalMaterial.side =
        forceDoubleSide || rapiMaterial.shading.doubleSided
            ? DoubleSide
            : FrontSide;
    return meshPhysicalMaterial;
};
const createMeshPhysicalMaterial = () => {
    return MaterialCreator.createMeshPhysicalMaterial({});
};
const getMaterialShading = (material, version = 1) => {
    return version === 2
        ? _getMaterialShadingV2(material)
        : _getMaterialShadingV1(material);
};
const _getMaterialShadingV1 = (material) => {
    let shading = {
        alpha: material.opacity,
        metallic: material.reflectivity,
        basecolor: _getColor(material.color),
        roughness: material.roughness,
        doubleSided: material.side === DoubleSide,
        alphaCutoff: material.alphaTest,
        transmission: material.transmission,
    };
    if (material.metalness === 1) {
        shading.metallic = 1;
    }
    else {
        shading.metallic = material.reflectivity;
    }
    return shading;
};
const _getMaterialShadingV2 = (material) => {
    let shading = {
        version: '2.0.0',
        alpha: material.opacity,
        alphaCutoff: material.alphaTest,
        basecolor: _getColor(material.color),
        transmission: material.transmission,
        transmissionIOR: material.ior,
        metallic: material.metalness,
        doubleSided: material.side === DoubleSide,
        specularColor: _getColor(material.specularColor),
        specularity: material.specularIntensity,
        roughness: material.roughness,
        occlusion: material.aoMapIntensity,
        emissiveColor: _getColor(material.emissive),
        emissiveIntensity: material.emissiveIntensity,
        clearcoatIntensity: material.clearcoat,
        clearcoatRoughness: material.clearcoatRoughness,
        clearcoatNormalScale: material.clearcoatNormalScale.x,
        sheenColor: _getColor(material.sheenColor),
        sheenIntensity: material.sheen,
        sheenRoughness: material.sheenRoughness,
        thicknessFactor: material.thickness,
        attenuationColor: _getColor(material.attenuationColor),
        attenuationDistance: material.attenuationDistance,
    };
    return shading;
};
const _setColor = (meshColor, rapiColor) => {
    if (rapiColor !== undefined) {
        const color = new Color$1(rapiColor.r, rapiColor.g, rapiColor.b);
        meshColor.copy(color.convertSRGBToLinear());
    }
};
const _getColor = (meshColor) => {
    const color = meshColor.clone().convertLinearToSRGB();
    return {
        r: color.r,
        g: color.g,
        b: color.b,
    };
};
let textureLoader = null;
const addTexture = (assetUrl, rapiTexture, material, maxAnisotropy, repeatWidth, repeatHeight, maxTextures = 16) => {
    if (!textureLoader) {
        textureLoader = new TextureLoader();
        textureLoader.crossOrigin = '';
    }
    return new Promise((resolve, reject) => {
        if (!assetUrl) {
            console.warn('trying to add a texture without image', rapiTexture);
            // we resolve here because otherwise Promise.all fails
            resolve();
            return;
        }
        textureLoader.load(assetUrl, (texture) => {
            addExistingTexture(texture, rapiTexture, material, maxAnisotropy, repeatWidth, repeatHeight, maxTextures);
            resolve();
        }, reject);
    });
};
const addExistingTexture = (texture, rapiTexture, material, maxAnisotropy, repeatWidth, repeatHeight, maxTextures = 16) => {
    texture.anisotropy = maxAnisotropy;
    texture.wrapS = RepeatWrapping;
    texture.wrapT = RepeatWrapping;
    if (maxTextures <= 8 &&
        [
            "ORM" /* RAPI_TEXTURE_TYPE.ORM */,
            "EMRGB" /* RAPI_TEXTURE_TYPE.EMRGB */,
            "CCRG" /* RAPI_TEXTURE_TYPE.CCRG */,
            "CCXYZ" /* RAPI_TEXTURE_TYPE.CCXYZ */,
            "SHRGBA" /* RAPI_TEXTURE_TYPE.SHRGBA */,
            "SPRGBA" /* RAPI_TEXTURE_TYPE.SPRGBA */,
            "TTRG" /* RAPI_TEXTURE_TYPE.TTRG */,
        ].includes(rapiTexture.mapping)) {
        console.warn('ORM maps are not supported on devices with only ' +
            maxTextures +
            ' texture units');
        return;
    }
    texture.repeat.set(repeatWidth, repeatHeight);
    _setMaterialMaps(texture, rapiTexture, material);
    if (rapiTexture.mapping === "RGBA" /* RAPI_TEXTURE_TYPE.RGBA */) {
        material.transparent = true;
        if (material.userData.materialVersion === 1) {
            const isEmissive = material.name.includes('glow');
            if (isEmissive) {
                material.emissiveIntensity = 0.5;
                material.emissive = new Color$1(0xffffff);
                material.emissiveMap = material.map;
            }
        }
    }
    material.needsUpdate = true;
};
const _setMaterialMaps = (texture, rapiTexture, material) => {
    if (rapiTexture.mapping === "XYZ" /* RAPI_TEXTURE_TYPE.XYZ */) {
        material.normalMap = texture;
        if (material.map === getWhiteTexture()) {
            material.map = null;
        }
    }
    else if (rapiTexture.mapping === "ORM" /* RAPI_TEXTURE_TYPE.ORM */) {
        material.aoMap = texture;
        material.roughnessMap = texture;
        material.metalnessMap = texture;
    }
    else if (rapiTexture.mapping === "EMRGB" /* RAPI_TEXTURE_TYPE.EMRGB */) {
        material.emissiveMap = texture;
    }
    else if (rapiTexture.mapping === "CCRG" /* RAPI_TEXTURE_TYPE.CCRG */) {
        material.clearcoatMap = texture;
        material.clearcoatRoughnessMap = texture;
    }
    else if (rapiTexture.mapping === "CCXYZ" /* RAPI_TEXTURE_TYPE.CCXYZ */) {
        material.clearcoatNormalMap = texture;
    }
    else if (rapiTexture.mapping === "SHRGBA" /* RAPI_TEXTURE_TYPE.SHRGBA */) {
        material.sheenColorMap = texture;
        material.sheenRoughnessMap = texture;
    }
    else if (rapiTexture.mapping === "SPRGBA" /* RAPI_TEXTURE_TYPE.SPRGBA */) {
        material.specularColorMap = texture;
        material.specularIntensityMap = texture;
    }
    else if (rapiTexture.mapping === "TTRG" /* RAPI_TEXTURE_TYPE.TTRG */) {
        material.transmissionMap = texture;
        material.thicknessMap = texture;
    }
    else {
        texture.colorSpace = SRGBColorSpace;
        material.map = texture;
    }
};
const getGUI = (autoplace = true) => {
    if (!window.__RML_GUI__) {
        window.__RML_GUI__ = new GUI$1({ autoPlace: autoplace }); // eslint-disable-line
    }
    return window.__RML_GUI__;
};
const hideWallsBasedOnCamera = (camera, wallPlanElementViewModels) => {
    let anyVisibilityChanged = false;
    for (const wallPlanElementViewModel of wallPlanElementViewModels) {
        const kernelWall = wallPlanElementViewModel.getKernelObject();
        let wallNormal;
        if (kernelWall.wallType.value === 2 /* KernelWallType.OuterWallRight */) {
            wallNormal = convertToTHREE(kernelWall.rightNormal);
        }
        if (kernelWall.wallType.value === 1 /* KernelWallType.OuterWallLeft */) {
            wallNormal = convertToTHREE(kernelWall.leftNormal);
        }
        if (!wallNormal) {
            continue;
        }
        let wallCenter = convertToTHREE(wallPlanElementViewModel.getPlanElement().getCenter());
        wallCenter = wallCenter.applyMatrix4(camera.matrixWorldInverse);
        wallNormal = wallNormal.transformDirection(camera.matrixWorldInverse);
        const cameraDirection = wallCenter;
        const dotProduct = cameraDirection.dot(wallNormal);
        const visible = dotProduct >= 0;
        if (visible !== wallPlanElementViewModel.getContainer().visible) {
            anyVisibilityChanged = true;
        }
        if (visible) {
            wallPlanElementViewModel.show();
        }
        else {
            if (!wallPlanElementViewModel.isSelected) {
                wallPlanElementViewModel.hide();
            }
        }
    }
    return anyVisibilityChanged;
};
const setWallTransparency = (material, transparent, animate = true) => {
    if (material.userData.tween) {
        return;
    }
    if (transparent) {
        material.transparent = true;
        if (!animate) {
            material.opacity = 0.2;
        }
        else {
            let params = { opacity: 1 };
            material.userData.tween = true;
            new TWEEN.Tween(params)
                .to({ opacity: 0.2 }, 400)
                .easing(TWEEN.Easing.Sinusoidal.In)
                .onUpdate(() => {
                material.opacity = params.opacity;
            })
                .onComplete(() => {
                material.userData.tween = false;
            })
                .start();
        }
    }
    else {
        if (!animate) {
            material.opacity = 1;
            material.transparent = false;
        }
        else {
            let params = { opacity: 0.2 };
            material.userData.tween = true;
            new TWEEN.Tween(params)
                .to({ opacity: 1 }, 400)
                .easing(TWEEN.Easing.Sinusoidal.In)
                .onUpdate(() => {
                material.opacity = params.opacity;
            })
                .onComplete(() => {
                material.transparent = false;
                material.userData.tween = false;
            })
                .start();
        }
    }
};
const getColorFromInt = (combinedColor) => {
    let color = new Color$1();
    color.setRGB((combinedColor >> 16) / 255, ((combinedColor >> 8) & 0xff) / 255, ((combinedColor >> 0) & 0xff) / 255);
    return color;
};
const transitionTransparencyOfMaterial = (object, toMaterial) => {
    object.traverse((mesh) => {
        if (mesh instanceof Mesh && TWEEN) {
            const currentMaterial = mesh.material;
            if (mesh.userData.tween) {
                mesh.userData.tween.stop();
            }
            const from = { opacity: currentMaterial.opacity };
            if (toMaterial.transparent) {
                currentMaterial.transparent = toMaterial.transparent;
            }
            mesh.userData.tween = new TWEEN.Tween(from)
                .to(toMaterial, 250)
                .easing(TWEEN.Easing.Linear.None)
                .onUpdate(() => {
                currentMaterial.opacity = from.opacity;
            })
                .onStop(() => {
                if (!toMaterial.transparent) {
                    currentMaterial.transparent = toMaterial.transparent;
                }
                currentMaterial.opacity = toMaterial.opacity;
                currentMaterial.needsUpdate = true;
                mesh.userData.tween = undefined;
            })
                .onComplete(() => {
                if (!toMaterial.transparent) {
                    currentMaterial.transparent = toMaterial.transparent;
                }
                currentMaterial.needsUpdate = true;
                mesh.userData.tween = undefined;
            })
                .start();
        }
    });
};
const fadeIn = (object) => {
    object.traverse((mesh) => {
        if (mesh instanceof Mesh && TWEEN) {
            let material = mesh.material;
            if (material.opacity === 0) {
                return;
            }
            let from = { opacity: 0, transparent: true };
            let to = {
                opacity: material.opacity,
                transparent: material.transparent,
            };
            material.transparent = from.transparent;
            material.opacity = from.opacity;
            new TWEEN.Tween(from)
                .to(to, 500)
                .easing(TWEEN.Easing.Linear.None)
                .onUpdate(() => {
                material.opacity = from.opacity;
            })
                .onComplete(() => {
                material.transparent = to.transparent;
            })
                .start();
        }
    });
};
const checkGLB = (glb, url) => {
    let boundingBox = new Box3().setFromObject(glb);
    let size = boundingBox.getSize(new Vector3());
    let minSize = Math.min(size.x, size.y, size.z);
    let noError = true;
    if (minSize > 5) {
        console.warn('GLB seems to be too big (' + minSize + ')', url);
        noError = false;
    }
    if (boundingBox.min.y < -0.01) {
        console.warn('GLB seems to be under the floor (' + boundingBox.min.y + '): ', url);
        noError = false;
    }
    return noError;
};
const dispose = (object) => {
    if (object.type === 'Mesh') {
        disposeMesh(object);
    }
    else {
        disposeObject(object);
    }
};
const disposeObject = (object) => {
    if (!object || !object.children || object.children.length === 0) {
        return;
    }
    object.children.forEach((child) => {
        disposeMesh(child);
    });
};
const disposeMesh = (mesh) => {
    if (!mesh) {
        return;
    }
    if (mesh.material) {
        disposeMaterial(mesh.material);
    }
    if (mesh.geometry) {
        disposeGeometry(mesh.geometry);
    }
    if (mesh.children && mesh.children.length > 0) {
        disposeObject(mesh);
    }
};
const disposeGeometry = (geometry) => {
    if (geometry) {
        geometry.dispose();
    }
};
const disposeMaterial = (material) => {
    if (material) {
        // if we add more different maps we have to dispose them separately
        if (material.map) {
            material.map.dispose();
        }
        if (material.normalMap) {
            material.normalMap.dispose();
        }
        material.dispose();
    }
};
let boundingBoxMaterial;
const getBoundingBoxMaterial = () => {
    if (!boundingBoxMaterial) {
        boundingBoxMaterial = new MeshBasicMaterial();
        boundingBoxMaterial.visible = false;
    }
    return boundingBoxMaterial;
};
const vectorIsZero = (vector) => {
    return vector.x === 0 && vector.y === 0 && vector.z === 0;
};
const getMaterialId = (material, type) => {
    let materialId = '';
    if (!material && material !== '') {
        return null;
    }
    else if (material.materialId && material.materialId !== '') {
        materialId = material.materialId;
    }
    else if (material.catalogItemId && material.catalogItemId !== '') {
        materialId = material.catalogItemId;
    }
    else if (material.rgbValue > 0) {
        materialId = 'rgb' + JSON.stringify(material.rgbValue);
    }
    else if (material.length > 0) {
        materialId = material;
    }
    else if (type && type.value === 1 /* PlanElementType.WALL */) {
        materialId = 'default_wall_material_' + material.getSourceType().value;
    }
    else if (type && type.value === 7 /* PlanElementType.CEILING */) {
        materialId = 'default_ceiling_material_' + material.getSourceType().value;
    }
    return materialId;
};
const getYRotationOfObject = (object) => {
    let objectDirection = object.getWorldDirection(new Vector3()).clone();
    objectDirection.y = 0;
    if (objectDirection.lengthSq() < 0.01) {
        objectDirection = new Vector3(0, 1, 0);
        objectDirection.applyQuaternion(object.quaternion);
        objectDirection.y = 0;
    }
    objectDirection.normalize();
    let angle = Math.asin(objectDirection.x);
    if (objectDirection.z < 0) {
        angle = Math.PI - angle;
    }
    // clamp to a value between 0 and 2 PI
    if (angle < 0) {
        angle += Math.PI * 2;
    }
    return angle;
};
/**
 * compares x and z and ignores y
 * @param box1
 * @param box2
 */
const compareBox3Size = (box1, box2) => {
    if (!box1 || !box2) {
        return 0;
    }
    const box1ContainsBox2 = box1.clone().expandByScalar(0.001).containsBox(box2);
    const box2ContainsBox1 = box2.clone().expandByScalar(0.001).containsBox(box1);
    if ((box2ContainsBox1 && box1ContainsBox2) ||
        (!box2ContainsBox1 && !box1ContainsBox2)) {
        return 0;
    }
    return box1ContainsBox2 === true ? 1 : -1;
};
const isUVIdentityMatrix = (uvTransform) => {
    return (uvTransform[0] === 1 &&
        uvTransform[1] === 0 &&
        uvTransform[2] === 0 &&
        uvTransform[3] === 1 &&
        uvTransform[4] === 0 &&
        uvTransform[5] === 0);
};
const getDrawingMinBounds = (planBounds, width, height, marginMultiplier = 1) => {
    const landscape = width > height;
    const x = landscape ? 15 : 0;
    const z = landscape ? 0 : 10;
    const currentSize = planBounds.getSize(new Vector3());
    const currentCenter = planBounds.getCenter(new Vector3());
    let newX = currentSize.x > 2 * x ? currentSize.x / 2 : x;
    let newZ = currentSize.z > 2 * z ? currentSize.z / 2 : z;
    // add a margin of 10%
    newX *= marginMultiplier;
    newZ *= marginMultiplier;
    return new Box3(new Vector3(currentCenter.x - newX, currentCenter.y, currentCenter.z - newZ), new Vector3(currentCenter.x + newX, currentCenter.y, currentCenter.z + newZ));
};
const threeVectorToTransferableXY = (vec) => {
    const { x, y } = vec;
    return { x, y };
};
const threeVectorToTransferableXYZ = (vec) => {
    const { x, y, z } = vec;
    return { x, y, z };
};
const viewSpacePositionFromUV = (distance, u, v) => {
    return new Vector3().setFromSphericalCoords(distance, Math.PI * (1 - v), Math.PI * 2 * (1 - u));
};
const createEmptySceneFromCurrent = (currentScene) => {
    const scene = new Scene();
    scene.environment = currentScene.environment.clone();
    scene.userData.environmentDefinition =
        currentScene.userData.environmentDefinition.clone();
    scene.userData.shadowFromEnvironment =
        currentScene.userData.shadowFromEnvironment;
    return scene;
};

class CacheHolder {
    constructor() {
        this._componentCache = new Map();
        this._geometryCache = new Map();
        this._materialCache = new Map();
    }
    get componentCache() {
        return this._componentCache;
    }
    get geometryCache() {
        return this._geometryCache;
    }
    get materialCache() {
        return this._materialCache;
    }
    clear() {
        for (const component of this._componentCache.values()) {
            disposeObject(component);
        }
        for (const material of this._materialCache.values()) {
            disposeMaterial(material);
        }
        for (const geometry of this._geometryCache.values()) {
            disposeGeometry(geometry);
        }
        this._componentCache.clear();
        this._geometryCache.clear();
        this._materialCache.clear();
    }
}

class KernelAccessCallback {
    constructor(creator) {
        this._callbackListener = new Set();
        this._creator_ = creator;
    }
    addListener(listener) {
        this._callbackListener.add(listener);
    }
    removeListener(listener) {
        this._callbackListener.delete(listener);
    }
    isReady() {
        this._callbackListener.forEach((listener) => listener.isReady());
    }
    loadError(error) {
        this._callbackListener.forEach((listener) => listener.loadError(error));
    }
}

class ConfiguratorKernelAccessCallback {
    constructor(creator) {
        this._callbackListener = new Set();
        this._creator_ = creator;
    }
    addListener(listener) {
        this._callbackListener.add(listener);
    }
    removeListener(listener) {
        this._callbackListener.delete(listener);
    }
    isReady() {
        this._callbackListener.forEach((listener) => listener.isReady());
    }
    updatePossibleChildren(elementId, children, parameterUpdateType) {
        this._callbackListener.forEach((listener) => listener.updatePossibleChildren(elementId, children, parameterUpdateType));
    }
    updateParameters(parameters, parameterGroups, elementId, parameterUpdateType) {
        this._callbackListener.forEach((listener) => listener.updateParameters(parameters, parameterGroups, elementId, parameterUpdateType));
    }
    loadError(error) {
        this._callbackListener.forEach((listener) => listener.loadError(error));
    }
}

class ConfiguratorContext {
    constructor() {
        //ConfiguratorPlanObject
        this.planObjectId = 0;
        this.planElementId = 0;
        this.rootComponentId = 0;
        this.dockingRootComponentId = 0;
        this.baseContext = null;
        this.rootComponentParametersAsGlobal = false;
        this.lastLoadedRapiId = null;
        this.lastLoadedPlanId = null;
        this.selectedRuntimeComponentIds = [];
        this.selectionMode = "standard" /* SELECTION_MODE.STANDARD */;
    }
    get selectedRuntimeComponentId() {
        if (this.selectedRuntimeComponentIds.length > 0) {
            return this.selectedRuntimeComponentIds[0];
        }
        return null;
    }
}

var ENV_HDR_256_FILE_NAME = "static/default_256-f1c66a2764f88cc0.exr";

const CopyTransformShader = {
    uniforms: {
        tDiffuse: { value: null },
        colorTransform: { value: new Matrix4() },
        colorBase: { value: new Vector4(0, 0, 0, 0) },
        multiplyChannels: { value: 0 },
        uvTransform: { value: new Matrix3() },
    },
    vertexShader: `
        varying vec2 vUv;
        uniform mat3 uvTransform;
  
        void main() {
            vUv = (uvTransform * vec3(uv, 1.0)).xy;
            gl_Position = (projectionMatrix * modelViewMatrix * vec4(position, 1.0)).xyww;
        }`,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform mat4 colorTransform;
        uniform vec4 colorBase;
        uniform float multiplyChannels;
        varying vec2 vUv;
  
        void main() {
            vec4 color = colorTransform * texture2D(tDiffuse, vUv) + colorBase;
            color.rgb = mix(color.rgb, vec3(color.r * color.g * color.b), multiplyChannels);
            gl_FragColor = color;
        }`,
};
const DEFAULT_TRANSFORM = new Matrix4();
// prettier-ignore
const RGB_TRANSFORM = new Matrix4().set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0);
// prettier-ignore
const ALPHA_TRANSFORM = new Matrix4().set(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0);
// prettier-ignore
const RED_TRANSFORM = new Matrix4().set(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1);
// prettier-ignore
new Matrix4().set(0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
// prettier-ignore
new Matrix4().set(0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1);
// prettier-ignore
const GRAYSCALE_TRANSFORM = new Matrix4().set(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1);
const ZERO_RGBA = new Vector4(0, 0, 0, 0);
const ALPHA_RGBA = new Vector4(0, 0, 0, 1);
const DEFAULT_UV_TRANSFORM = new Matrix3();
// prettier-ignore
const FLIP_Y_UV_TRANSFORM = new Matrix3().set(1, 0, 0, 0, -1, 1, 0, 0, 1);
// prettier-ignore
const interpolationMatrix = (r, g, b, a) => {
    // prettier-ignore
    return new Matrix4().set(r, 0, 0, 1 - r, 0, g, 0, 1 - g, 0, 0, b, 1 - b, 0, 0, 0, a);
};
const COLOR_COPY_BLEND_MODES = {
    DEFAULT: 'default',
    ADDITIVE: 'additive',
};
class CopyTransformMaterial extends ShaderMaterial {
    constructor(parameters, copyBlendMode = COLOR_COPY_BLEND_MODES.ADDITIVE) {
        const blendingParameters = copyBlendMode === COLOR_COPY_BLEND_MODES.ADDITIVE
            ? {
                blendSrc: DstColorFactor,
                blendDst: ZeroFactor,
                blendEquation: AddEquation,
                blendSrcAlpha: DstAlphaFactor,
                blendDstAlpha: ZeroFactor,
                blendEquationAlpha: AddEquation,
            }
            : {};
        super({
            uniforms: UniformsUtils.clone(CopyTransformShader.uniforms),
            vertexShader: CopyTransformShader.vertexShader,
            fragmentShader: CopyTransformShader.fragmentShader,
            transparent: true,
            depthTest: false,
            depthWrite: false,
            ...blendingParameters,
        });
        this.update(parameters);
    }
    update(parameters) {
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.texture) !== undefined) {
            this.uniforms.tDiffuse.value = parameters === null || parameters === void 0 ? void 0 : parameters.texture;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.colorTransform) !== undefined) {
            this.uniforms.colorTransform.value = parameters === null || parameters === void 0 ? void 0 : parameters.colorTransform;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.colorBase) !== undefined) {
            this.uniforms.colorBase.value = parameters === null || parameters === void 0 ? void 0 : parameters.colorBase;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.multiplyChannels) !== undefined) {
            this.uniforms.multiplyChannels.value = parameters === null || parameters === void 0 ? void 0 : parameters.multiplyChannels;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.uvTransform) !== undefined) {
            this.uniforms.uvTransform.value = parameters === null || parameters === void 0 ? void 0 : parameters.uvTransform;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blending) !== undefined) {
            this.blending = parameters === null || parameters === void 0 ? void 0 : parameters.blending;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendSrc) !== undefined) {
            this.blendSrc = parameters === null || parameters === void 0 ? void 0 : parameters.blendSrc;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendDst) !== undefined) {
            this.blendDst = parameters === null || parameters === void 0 ? void 0 : parameters.blendDst;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendEquation) !== undefined) {
            this.blendEquation = parameters === null || parameters === void 0 ? void 0 : parameters.blendEquation;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendSrcAlpha) !== undefined) {
            this.blendSrcAlpha = parameters === null || parameters === void 0 ? void 0 : parameters.blendSrcAlpha;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendDstAlpha) !== undefined) {
            this.blendDstAlpha = parameters === null || parameters === void 0 ? void 0 : parameters.blendDstAlpha;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.blendEquationAlpha) !== undefined) {
            this.blendEquationAlpha = parameters === null || parameters === void 0 ? void 0 : parameters.blendEquationAlpha;
        }
        return this;
    }
}
const BlurShader = {
    uniforms: {
        tDiffuse: { value: null },
        rangeMin: { value: new Vector2(1.0 / 512.0, 1.0 / 512.0) },
        rangeMax: { value: new Vector2(1.0 / 512.0, 1.0 / 512.0) },
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform vec2 rangeMin;
    uniform vec2 rangeMax;
    varying vec2 vUv;
  
    void main() {
        vec4 baseColor = texture2D(tDiffuse, vUv);
        vec2 blur = mix(rangeMax, rangeMin, baseColor.a);
        vec4 sum = vec4( 0.0 );
        sum += texture2D(tDiffuse, vUv - 1.0 * blur) * 0.051;
        sum += texture2D(tDiffuse, vUv - 0.75 * blur) * 0.0918;
        sum += texture2D(tDiffuse, vUv - 0.5 * blur) * 0.12245;
        sum += texture2D(tDiffuse, vUv - 0.25 * blur) * 0.1531;
        sum += baseColor * 0.1633;
        sum += texture2D(tDiffuse, vUv + 0.25 * blur) * 0.1531;
        sum += texture2D(tDiffuse, vUv + 0.5 * blur) * 0.12245;
        sum += texture2D(tDiffuse, vUv + 0.75 * blur) * 0.0918;
        sum += texture2D(tDiffuse, vUv + 1.0 * blur) * 0.051;
        gl_FragColor = sum;
    }`,
};
({
    uniforms: {
        tDiffuse: { value: null },
        blur: { value: 1.0 / 512.0 },
        shadowRange: { value: new Vector2(0.1, 0.9) },
    },
    defines: {
        DEBUG_BLUR_AREA: 0,
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float blur;
    uniform vec2 shadowRange;
    varying vec2 vUv;
  
    void main() {
        vec4 baseColor = texture2D(tDiffuse, vUv);
        float h = blur * step(shadowRange.x, baseColor.r) * step(baseColor.r, shadowRange.y);
        vec4 sum = vec4(0.0);
        sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
        sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
        sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
        sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
        sum += baseColor * 0.1633;
        sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
        sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
        sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
        sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;
  #if DEBUG_BLUR_AREA == 1        
        gl_FragColor = h > 0.001 ? vec4(sum.r, 0.0, 0.0, 1.0) : sum;
  #else
        gl_FragColor = min(sum, baseColor);
  #endif
    }`,
});
({
    uniforms: {
        tDiffuse: { value: null },
        blur: { value: 1.0 / 512.0 },
        shadowRange: { value: new Vector2(0.1, 0.9) },
    },
    defines: {
        DEBUG_BLUR_AREA: 0,
    },
    vertexShader: `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float blur;
    uniform vec2 shadowRange;
    varying vec2 vUv;
  
    void main() {
        vec4 baseColor = texture2D(tDiffuse, vUv);
        float v = blur * step(shadowRange.x, baseColor.r) * step(baseColor.r, shadowRange.y);
        vec4 sum = vec4(0.0);
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
        sum += baseColor * 0.1633;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
        sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;
  #if DEBUG_BLUR_AREA == 1        
        gl_FragColor = v > 0.001 ? vec4(sum.r, 0.0, 0.0, 1.0) : sum;
  #else
        gl_FragColor = min(sum, baseColor);
  #endif
    }`,
});
const glslLinearDepthVertexShader = `varying vec2 vUv;
  void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }`;
const glslLinearDepthFragmentShader = `uniform sampler2D tDepth;
  uniform vec4 depthFilter;
  uniform float cameraNear;
  uniform float cameraFar;
  varying vec2 vUv;
  
  #include <packing>
  
  float getLinearDepth(const in vec2 screenPosition) {
      float fragCoordZ = dot(texture2D(tDepth, screenPosition), depthFilter);
      #if PERSPECTIVE_CAMERA == 1
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
      #else
          return fragCoordZ;
      #endif
  }
  
  void main() {
      float depth = getLinearDepth(vUv);
      gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
  }`;
class LinearDepthRenderMaterial extends ShaderMaterial {
    constructor(parameters) {
        super({
            defines: Object.assign({}, LinearDepthRenderMaterial._linearDepthShader.defines),
            uniforms: UniformsUtils.clone(LinearDepthRenderMaterial._linearDepthShader.uniforms),
            vertexShader: LinearDepthRenderMaterial._linearDepthShader.vertexShader,
            fragmentShader: LinearDepthRenderMaterial._linearDepthShader.fragmentShader,
            blending: NoBlending,
        });
        this.update(parameters);
    }
    update(parameters) {
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.depthTexture) !== undefined) {
            this.uniforms.tDepth.value = parameters === null || parameters === void 0 ? void 0 : parameters.depthTexture;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.camera) !== undefined) {
            const camera = (parameters === null || parameters === void 0 ? void 0 : parameters.camera) ||
                (parameters === null || parameters === void 0 ? void 0 : parameters.camera);
            this.uniforms.cameraNear.value = camera.near;
            this.uniforms.cameraFar.value = camera.far;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.depthFilter) !== undefined) {
            this.uniforms.depthFilter.value = parameters === null || parameters === void 0 ? void 0 : parameters.depthFilter;
        }
        return this;
    }
}
LinearDepthRenderMaterial._linearDepthShader = {
    uniforms: {
        tDepth: { value: null },
        depthFilter: { value: new Vector4(1, 0, 0, 0) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1 },
    },
    defines: {
        PERSPECTIVE_CAMERA: 1,
        ALPHA_DEPTH: 0,
    },
    vertexShader: glslLinearDepthVertexShader,
    fragmentShader: glslLinearDepthFragmentShader,
};

class Pass {

	constructor() {

		this.isPass = true;

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	setSize( /* width, height */ ) {}

	render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

		console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

	}

	dispose() {}

}

// Helper for passes that need to fill the viewport with a single quad.

const _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

class FullscreenTriangleGeometry extends BufferGeometry {

	constructor() {

		super();

		this.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

	}

}

const _geometry = new FullscreenTriangleGeometry();

class FullScreenQuad {

	constructor( material ) {

		this._mesh = new Mesh( _geometry, material );

	}

	dispose() {

		this._mesh.geometry.dispose();

	}

	render( renderer ) {

		renderer.render( this._mesh, _camera );

	}

	get material() {

		return this._mesh.material;

	}

	set material( value ) {

		this._mesh.material = value;

	}

}

// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com
//
// Added 4D noise

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
class SimplexNoise {

	constructor( r = Math ) {

		this.grad3 = [[ 1, 1, 0 ], [ - 1, 1, 0 ], [ 1, - 1, 0 ], [ - 1, - 1, 0 ],
			[ 1, 0, 1 ], [ - 1, 0, 1 ], [ 1, 0, - 1 ], [ - 1, 0, - 1 ],
			[ 0, 1, 1 ], [ 0, - 1, 1 ], [ 0, 1, - 1 ], [ 0, - 1, - 1 ]];

		this.grad4 = [[ 0, 1, 1, 1 ], [ 0, 1, 1, - 1 ], [ 0, 1, - 1, 1 ], [ 0, 1, - 1, - 1 ],
			[ 0, - 1, 1, 1 ], [ 0, - 1, 1, - 1 ], [ 0, - 1, - 1, 1 ], [ 0, - 1, - 1, - 1 ],
			[ 1, 0, 1, 1 ], [ 1, 0, 1, - 1 ], [ 1, 0, - 1, 1 ], [ 1, 0, - 1, - 1 ],
			[ - 1, 0, 1, 1 ], [ - 1, 0, 1, - 1 ], [ - 1, 0, - 1, 1 ], [ - 1, 0, - 1, - 1 ],
			[ 1, 1, 0, 1 ], [ 1, 1, 0, - 1 ], [ 1, - 1, 0, 1 ], [ 1, - 1, 0, - 1 ],
			[ - 1, 1, 0, 1 ], [ - 1, 1, 0, - 1 ], [ - 1, - 1, 0, 1 ], [ - 1, - 1, 0, - 1 ],
			[ 1, 1, 1, 0 ], [ 1, 1, - 1, 0 ], [ 1, - 1, 1, 0 ], [ 1, - 1, - 1, 0 ],
			[ - 1, 1, 1, 0 ], [ - 1, 1, - 1, 0 ], [ - 1, - 1, 1, 0 ], [ - 1, - 1, - 1, 0 ]];

		this.p = [];

		for ( let i = 0; i < 256; i ++ ) {

			this.p[ i ] = Math.floor( r.random() * 256 );

		}

		// To remove the need for index wrapping, double the permutation table length
		this.perm = [];

		for ( let i = 0; i < 512; i ++ ) {

			this.perm[ i ] = this.p[ i & 255 ];

		}

		// A lookup table to traverse the simplex around a given point in 4D.
		// Details can be found where this table is used, in the 4D noise method.
		this.simplex = [
			[ 0, 1, 2, 3 ], [ 0, 1, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 2, 3, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 2, 3, 0 ],
			[ 0, 2, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 3, 1, 2 ], [ 0, 3, 2, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 3, 2, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 1, 2, 0, 3 ], [ 0, 0, 0, 0 ], [ 1, 3, 0, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 3, 0, 1 ], [ 2, 3, 1, 0 ],
			[ 1, 0, 2, 3 ], [ 1, 0, 3, 2 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 2, 0, 3, 1 ], [ 0, 0, 0, 0 ], [ 2, 1, 3, 0 ],
			[ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ],
			[ 2, 0, 1, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 0, 1, 2 ], [ 3, 0, 2, 1 ], [ 0, 0, 0, 0 ], [ 3, 1, 2, 0 ],
			[ 2, 1, 0, 3 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 3, 1, 0, 2 ], [ 0, 0, 0, 0 ], [ 3, 2, 0, 1 ], [ 3, 2, 1, 0 ]];

	}

	dot( g, x, y ) {

		return g[ 0 ] * x + g[ 1 ] * y;

	}

	dot3( g, x, y, z ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z;

	}

	dot4( g, x, y, z, w ) {

		return g[ 0 ] * x + g[ 1 ] * y + g[ 2 ] * z + g[ 3 ] * w;

	}

	noise( xin, yin ) {

		let n0; // Noise contributions from the three corners
		let n1;
		let n2;
		// Skew the input space to determine which simplex cell we're in
		const F2 = 0.5 * ( Math.sqrt( 3.0 ) - 1.0 );
		const s = ( xin + yin ) * F2; // Hairy factor for 2D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const G2 = ( 3.0 - Math.sqrt( 3.0 ) ) / 6.0;
		const t = ( i + j ) * G2;
		const X0 = i - t; // Unskew the cell origin back to (x,y) space
		const Y0 = j - t;
		const x0 = xin - X0; // The x,y distances from the cell origin
		const y0 = yin - Y0;

		// For the 2D case, the simplex shape is an equilateral triangle.
		// Determine which simplex we are in.
		let i1; // Offsets for second (middle) corner of simplex in (i,j) coords

		let j1;
		if ( x0 > y0 ) {

			i1 = 1; j1 = 0;

			// lower triangle, XY order: (0,0)->(1,0)->(1,1)

		}	else {

			i1 = 0; j1 = 1;

		} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6
		const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
		const y1 = y0 - j1 + G2;
		const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
		const y2 = y0 - 1.0 + 2.0 * G2;
		// Work out the hashed gradient indices of the three simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const gi0 = this.perm[ ii + this.perm[ jj ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 ] ] % 12;
		const gi2 = this.perm[ ii + 1 + this.perm[ jj + 1 ] ] % 12;
		// Calculate the contribution from the three corners
		let t0 = 0.5 - x0 * x0 - y0 * y0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot( this.grad3[ gi0 ], x0, y0 ); // (x,y) of grad3 used for 2D gradient

		}

		let t1 = 0.5 - x1 * x1 - y1 * y1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot( this.grad3[ gi1 ], x1, y1 );

		}

		let t2 = 0.5 - x2 * x2 - y2 * y2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot( this.grad3[ gi2 ], x2, y2 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70.0 * ( n0 + n1 + n2 );

	}

	// 3D simplex noise
	noise3d( xin, yin, zin ) {

		let n0; // Noise contributions from the four corners
		let n1;
		let n2;
		let n3;
		// Skew the input space to determine which simplex cell we're in
		const F3 = 1.0 / 3.0;
		const s = ( xin + yin + zin ) * F3; // Very nice and simple skew factor for 3D
		const i = Math.floor( xin + s );
		const j = Math.floor( yin + s );
		const k = Math.floor( zin + s );
		const G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too
		const t = ( i + j + k ) * G3;
		const X0 = i - t; // Unskew the cell origin back to (x,y,z) space
		const Y0 = j - t;
		const Z0 = k - t;
		const x0 = xin - X0; // The x,y,z distances from the cell origin
		const y0 = yin - Y0;
		const z0 = zin - Z0;

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
		// Determine which simplex we are in.
		let i1; // Offsets for second corner of simplex in (i,j,k) coords

		let j1;
		let k1;
		let i2; // Offsets for third corner of simplex in (i,j,k) coords
		let j2;
		let k2;
		if ( x0 >= y0 ) {

			if ( y0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

				// X Y Z order

			} else if ( x0 >= z0 ) {

				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1;

				// X Z Y order

			} else {

				i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1;

			} // Z X Y order

		} else { // x0<y0

			if ( y0 < z0 ) {

				i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1;

				// Z Y X order

			} else if ( x0 < z0 ) {

				i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1;

				// Y Z X order

			} else {

				i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0;

			} // Y X Z order

		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
		const y1 = y0 - j1 + G3;
		const z1 = z0 - k1 + G3;
		const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
		const y2 = y0 - j2 + 2.0 * G3;
		const z2 = z0 - k2 + 2.0 * G3;
		const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
		const y3 = y0 - 1.0 + 3.0 * G3;
		const z3 = z0 - 1.0 + 3.0 * G3;
		// Work out the hashed gradient indices of the four simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const gi0 = this.perm[ ii + this.perm[ jj + this.perm[ kk ] ] ] % 12;
		const gi1 = this.perm[ ii + i1 + this.perm[ jj + j1 + this.perm[ kk + k1 ] ] ] % 12;
		const gi2 = this.perm[ ii + i2 + this.perm[ jj + j2 + this.perm[ kk + k2 ] ] ] % 12;
		const gi3 = this.perm[ ii + 1 + this.perm[ jj + 1 + this.perm[ kk + 1 ] ] ] % 12;
		// Calculate the contribution from the four corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot3( this.grad3[ gi0 ], x0, y0, z0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot3( this.grad3[ gi1 ], x1, y1, z1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot3( this.grad3[ gi2 ], x2, y2, z2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot3( this.grad3[ gi3 ], x3, y3, z3 );

		}

		// Add contributions from each corner to get the final noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * ( n0 + n1 + n2 + n3 );

	}

	// 4D simplex noise
	noise4d( x, y, z, w ) {

		// For faster and easier lookups
		const grad4 = this.grad4;
		const simplex = this.simplex;
		const perm = this.perm;

		// The skewing and unskewing factors are hairy again for the 4D case
		const F4 = ( Math.sqrt( 5.0 ) - 1.0 ) / 4.0;
		const G4 = ( 5.0 - Math.sqrt( 5.0 ) ) / 20.0;
		let n0; // Noise contributions from the five corners
		let n1;
		let n2;
		let n3;
		let n4;
		// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		const s = ( x + y + z + w ) * F4; // Factor for 4D skewing
		const i = Math.floor( x + s );
		const j = Math.floor( y + s );
		const k = Math.floor( z + s );
		const l = Math.floor( w + s );
		const t = ( i + j + k + l ) * G4; // Factor for 4D unskewing
		const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		const Y0 = j - t;
		const Z0 = k - t;
		const W0 = l - t;
		const x0 = x - X0; // The x,y,z,w distances from the cell origin
		const y0 = y - Y0;
		const z0 = z - Z0;
		const w0 = w - W0;

		// For the 4D case, the simplex is a 4D shape I won't even try to describe.
		// To find out which of the 24 possible simplices we're in, we need to
		// determine the magnitude ordering of x0, y0, z0 and w0.
		// The method below is a good way of finding the ordering of x,y,z,w and
		// then find the correct traversal order for the simplex were in.
		// First, six pair-wise comparisons are performed between each possible pair
		// of the four coordinates, and the results are used to add up binary bits
		// for an integer index.
		const c1 = ( x0 > y0 ) ? 32 : 0;
		const c2 = ( x0 > z0 ) ? 16 : 0;
		const c3 = ( y0 > z0 ) ? 8 : 0;
		const c4 = ( x0 > w0 ) ? 4 : 0;
		const c5 = ( y0 > w0 ) ? 2 : 0;
		const c6 = ( z0 > w0 ) ? 1 : 0;
		const c = c1 + c2 + c3 + c4 + c5 + c6;

		// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
		// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
		// impossible. Only the 24 indices which have non-zero entries make any sense.
		// We use a thresholding to set the coordinates in turn from the largest magnitude.
		// The number 3 in the "simplex" array is at the position of the largest coordinate.
		const i1 = simplex[ c ][ 0 ] >= 3 ? 1 : 0;
		const j1 = simplex[ c ][ 1 ] >= 3 ? 1 : 0;
		const k1 = simplex[ c ][ 2 ] >= 3 ? 1 : 0;
		const l1 = simplex[ c ][ 3 ] >= 3 ? 1 : 0;
		// The number 2 in the "simplex" array is at the second largest coordinate.
		const i2 = simplex[ c ][ 0 ] >= 2 ? 1 : 0;
		const j2 = simplex[ c ][ 1 ] >= 2 ? 1 : 0;
		const k2 = simplex[ c ][ 2 ] >= 2 ? 1 : 0;
		const l2 = simplex[ c ][ 3 ] >= 2 ? 1 : 0;
		// The number 1 in the "simplex" array is at the second smallest coordinate.
		const i3 = simplex[ c ][ 0 ] >= 1 ? 1 : 0;
		const j3 = simplex[ c ][ 1 ] >= 1 ? 1 : 0;
		const k3 = simplex[ c ][ 2 ] >= 1 ? 1 : 0;
		const l3 = simplex[ c ][ 3 ] >= 1 ? 1 : 0;
		// The fifth corner has all coordinate offsets = 1, so no need to look that up.
		const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
		const y1 = y0 - j1 + G4;
		const z1 = z0 - k1 + G4;
		const w1 = w0 - l1 + G4;
		const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
		const y2 = y0 - j2 + 2.0 * G4;
		const z2 = z0 - k2 + 2.0 * G4;
		const w2 = w0 - l2 + 2.0 * G4;
		const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
		const y3 = y0 - j3 + 3.0 * G4;
		const z3 = z0 - k3 + 3.0 * G4;
		const w3 = w0 - l3 + 3.0 * G4;
		const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
		const y4 = y0 - 1.0 + 4.0 * G4;
		const z4 = z0 - 1.0 + 4.0 * G4;
		const w4 = w0 - 1.0 + 4.0 * G4;
		// Work out the hashed gradient indices of the five simplex corners
		const ii = i & 255;
		const jj = j & 255;
		const kk = k & 255;
		const ll = l & 255;
		const gi0 = perm[ ii + perm[ jj + perm[ kk + perm[ ll ] ] ] ] % 32;
		const gi1 = perm[ ii + i1 + perm[ jj + j1 + perm[ kk + k1 + perm[ ll + l1 ] ] ] ] % 32;
		const gi2 = perm[ ii + i2 + perm[ jj + j2 + perm[ kk + k2 + perm[ ll + l2 ] ] ] ] % 32;
		const gi3 = perm[ ii + i3 + perm[ jj + j3 + perm[ kk + k3 + perm[ ll + l3 ] ] ] ] % 32;
		const gi4 = perm[ ii + 1 + perm[ jj + 1 + perm[ kk + 1 + perm[ ll + 1 ] ] ] ] % 32;
		// Calculate the contribution from the five corners
		let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if ( t0 < 0 ) n0 = 0.0;
		else {

			t0 *= t0;
			n0 = t0 * t0 * this.dot4( grad4[ gi0 ], x0, y0, z0, w0 );

		}

		let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if ( t1 < 0 ) n1 = 0.0;
		else {

			t1 *= t1;
			n1 = t1 * t1 * this.dot4( grad4[ gi1 ], x1, y1, z1, w1 );

		}

		let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if ( t2 < 0 ) n2 = 0.0;
		else {

			t2 *= t2;
			n2 = t2 * t2 * this.dot4( grad4[ gi2 ], x2, y2, z2, w2 );

		}

		let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if ( t3 < 0 ) n3 = 0.0;
		else {

			t3 *= t3;
			n3 = t3 * t3 * this.dot4( grad4[ gi3 ], x3, y3, z3, w3 );

		}

		let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if ( t4 < 0 ) n4 = 0.0;
		else {

			t4 *= t4;
			n4 = t4 * t4 * this.dot4( grad4[ gi4 ], x4, y4, z4, w4 );

		}

		// Sum up and scale the result to cover the range [-1,1]
		return 27.0 * ( n0 + n1 + n2 + n3 + n4 );

	}

}

new TextureLoader();
const setOrthographicViewVolumeFromBox = (camera, viewBox) => {
    camera.left = viewBox.min.x;
    camera.right = viewBox.max.x;
    camera.bottom = viewBox.min.y;
    camera.top = viewBox.max.y;
    camera.near = Math.min(-viewBox.min.z, -viewBox.max.z);
    camera.far = Math.max(-viewBox.min.z, -viewBox.max.z);
    camera.updateProjectionMatrix();
};
const setPerspectiveViewVolumeFromBox = (camera, viewBox) => {
    const near = Math.min(-viewBox.min.z, -viewBox.max.z);
    const far = Math.max(-viewBox.min.z, -viewBox.max.z);
    if (near < 0.001) {
        return;
    }
    const halfWidth = Math.max(Math.abs(viewBox.min.x), Math.abs(viewBox.max.x));
    const halfHeight = Math.max(Math.abs(viewBox.min.y), Math.abs(viewBox.max.y));
    camera.aspect = halfWidth / halfHeight;
    camera.fov = MathUtils.radToDeg(Math.atan2(halfHeight, near) * 2);
    camera.near = near;
    camera.far = far;
    camera.updateProjectionMatrix();
};
class SceneVolume {
    constructor() {
        this.bounds = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
        this.size = new Vector3(2, 2, 2);
        this.center = new Vector3(0, 0, 0);
        this.maxSceneDistanceFromCenter = Math.sqrt(3);
        this.maxSceneDistanceFrom0 = Math.sqrt(3);
    }
    copyFrom(other) {
        this.bounds.copy(other.bounds);
        this.size.copy(other.size);
        this.center.copy(other.center);
        this.maxSceneDistanceFromCenter = other.maxSceneDistanceFromCenter;
        this.maxSceneDistanceFrom0 = other.maxSceneDistanceFrom0;
    }
    updateFromObject(sceneObject) {
        sceneObject.updateMatrixWorld();
        this.bounds.setFromObject(sceneObject);
        this.updateFromBox(this.bounds);
    }
    updateFromBox(boundingBox) {
        if (this.bounds !== boundingBox) {
            this.bounds.copy(boundingBox);
        }
        this.bounds.getSize(this.size);
        this.bounds.getCenter(this.center);
        this.maxSceneDistanceFromCenter = this.size.length() / 2;
        this.maxSceneDistanceFrom0 = new Vector3(Math.max(Math.abs(this.bounds.min.x), Math.abs(this.bounds.max.x)), Math.max(Math.abs(this.bounds.min.y), Math.abs(this.bounds.max.y)), Math.max(Math.abs(this.bounds.min.z), Math.abs(this.bounds.max.z))).length();
    }
    updateCameraViewVolumeFromBounds(camera) {
        camera.updateMatrixWorld();
        const cameraViewBounds = this.bounds
            .clone()
            .applyMatrix4(camera.matrixWorldInverse);
        if (camera instanceof OrthographicCamera) {
            setOrthographicViewVolumeFromBox(camera, cameraViewBounds);
        }
        else if (camera instanceof PerspectiveCamera) {
            setPerspectiveViewVolumeFromBox(camera, cameraViewBounds);
        }
    }
    getNearAndFarForPerspectiveCamera(cameraPosition, backScale = 1) {
        const distanceFromCenter = cameraPosition.clone().sub(this.center).length();
        const near = Math.max(0.01, distanceFromCenter - this.maxSceneDistanceFromCenter - 0.01);
        const far = distanceFromCenter + this.maxSceneDistanceFromCenter * backScale + 0.01;
        return [near, far];
    }
}
const getMaxSamples = (renderTarget) => {
    const capabilities = renderTarget.capabilities;
    const maxSamples = capabilities.maxSamples;
    return maxSamples;
};
class CameraUpdate {
    changed(camera) {
        var _a, _b;
        const hasChanged = !((_a = this._lastCameraProjection) === null || _a === void 0 ? void 0 : _a.equals(camera.projectionMatrix)) ||
            !((_b = this._lastCameraWorld) === null || _b === void 0 ? void 0 : _b.equals(camera.matrixWorld));
        this._lastCameraProjection = camera.projectionMatrix.clone();
        this._lastCameraWorld = camera.matrixWorld.clone();
        return hasChanged;
    }
}
const generateMagicSquare = (size) => {
    const noiseSize = Math.floor(size) % 2 === 0 ? Math.floor(size) + 1 : Math.floor(size);
    const noiseSquareSize = noiseSize * noiseSize;
    const magicSquare = Array(noiseSquareSize).fill(0);
    let i = Math.floor(noiseSize / 2);
    let j = noiseSize - 1;
    for (let num = 1; num <= noiseSquareSize;) {
        if (i === -1 && j === noiseSize) {
            j = noiseSize - 2;
            i = 0;
        }
        else {
            if (j === noiseSize) {
                j = 0;
            }
            if (i < 0) {
                i = noiseSize - 1;
            }
        }
        if (magicSquare[i * noiseSize + j] !== 0) {
            j -= 2;
            i++;
            continue;
        }
        else {
            magicSquare[i * noiseSize + j] = num++;
        }
        j++;
        i--;
    }
    return magicSquare;
};
const generateMagicSquareDistributedKernelRotations = (size) => {
    const simplex = new SimplexNoise();
    const noiseSize = Math.floor(size) % 2 === 0 ? Math.floor(size) + 1 : Math.floor(size);
    const magicSquare = generateMagicSquare(noiseSize);
    const noiseSquareSize = magicSquare.length;
    const data = new Uint8Array(noiseSquareSize * 4);
    for (let inx = 0; inx < noiseSquareSize; ++inx) {
        const iAng = magicSquare[inx];
        const angle = (2 * Math.PI * iAng) / noiseSquareSize;
        const randomVec = new Vector3(Math.cos(angle), Math.sin(angle), 0).normalize();
        data[inx * 4] = (randomVec.x * 0.5 + 0.5) * 255;
        data[inx * 4 + 1] = (randomVec.y * 0.5 + 0.5) * 255;
        data[inx * 4 + 2] = 127;
        data[inx * 4 + 3] =
            (simplex.noise(inx / size, inx % size) * 0.5 + 0.5) * 255;
    }
    const noiseTexture = new DataTexture(data, noiseSize, noiseSize);
    noiseTexture.wrapS = RepeatWrapping;
    noiseTexture.wrapT = RepeatWrapping;
    noiseTexture.needsUpdate = true;
    return noiseTexture;
};
class PassRenderer {
    constructor() {
        this._originalClearColor = new Color$1();
        this._originalClearAlpha = 0;
        this._originalAutoClear = false;
        this._originalRenderTarget = null;
        this._screenSpaceQuad = new FullScreenQuad(undefined);
        this._emptyScene = new Scene();
        this._defaultCamera = new PerspectiveCamera();
    }
    renderWithOverrideMaterial(renderer, scene, camera, overrideMaterial, renderTarget, clearColor, clearAlpha) {
        this._backup(renderer);
        this._prepareRenderer(renderer, renderTarget, clearColor, clearAlpha);
        const originalOverrideMaterial = scene.overrideMaterial;
        scene.overrideMaterial = overrideMaterial;
        renderer.render(scene, camera);
        scene.overrideMaterial = originalOverrideMaterial;
        this._restore(renderer);
    }
    clear(renderer, renderTarget, clearColor, clearAlpha) {
        this._backup(renderer);
        this._prepareRenderer(renderer, renderTarget, clearColor, clearAlpha);
        renderer.render(this._emptyScene, this._defaultCamera);
        this._restore(renderer);
    }
    render(renderer, scene, camera, renderTarget, clearColor, clearAlpha) {
        this._backup(renderer);
        this._prepareRenderer(renderer, renderTarget, clearColor, clearAlpha);
        renderer.render(scene, camera);
        this._restore(renderer);
    }
    renderScreenSpace(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {
        this._backup(renderer);
        this._prepareRenderer(renderer, renderTarget, clearColor, clearAlpha);
        this._screenSpaceQuad.material = passMaterial;
        this._screenSpaceQuad.render(renderer);
        this._restore(renderer);
    }
    _prepareRenderer(renderer, renderTarget, clearColor, clearAlpha) {
        renderer.setRenderTarget(renderTarget);
        renderer.autoClear = false;
        if (clearColor !== undefined && clearColor !== null) {
            renderer.setClearColor(clearColor);
            renderer.setClearAlpha(clearAlpha || 0.0);
            renderer.clear();
        }
    }
    _backup(renderer) {
        renderer.getClearColor(this._originalClearColor);
        this._originalClearAlpha = renderer.getClearAlpha();
        this._originalAutoClear = renderer.autoClear;
        this._originalRenderTarget = renderer.getRenderTarget();
    }
    _restore(renderer) {
        renderer.setClearColor(this._originalClearColor);
        renderer.setClearAlpha(this._originalClearAlpha);
        renderer.setRenderTarget(this._originalRenderTarget);
        renderer.autoClear = this._originalAutoClear;
    }
}
class BlurPass {
    constructor(blurShaderParameters, parameters) {
        var _a;
        this._passRenderer = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.passRenderer) !== null && _a !== void 0 ? _a : new PassRenderer();
        this._blurMaterial = new ShaderMaterial(blurShaderParameters !== null && blurShaderParameters !== void 0 ? blurShaderParameters : BlurShader);
        this._blurMaterial.depthTest = false;
    }
    dispose() {
        this._blurMaterial.dispose();
    }
    render(renderer, renderTargets, uvMin, uvMax) {
        this._blurMaterial.uniforms.tDiffuse.value = renderTargets[0].texture;
        this._blurMaterial.uniforms.rangeMin.value.x = uvMin[0];
        this._blurMaterial.uniforms.rangeMin.value.y = 0;
        this._blurMaterial.uniforms.rangeMax.value.x = uvMax[0];
        this._blurMaterial.uniforms.rangeMax.value.y = 0;
        this._passRenderer.renderScreenSpace(renderer, this._blurMaterial, renderTargets[1]);
        this._blurMaterial.uniforms.tDiffuse.value = renderTargets[1].texture;
        this._blurMaterial.uniforms.rangeMin.value.x = 0;
        this._blurMaterial.uniforms.rangeMin.value.y = uvMin[1];
        this._blurMaterial.uniforms.rangeMax.value.x = 0;
        this._blurMaterial.uniforms.rangeMax.value.y = uvMax[1];
        this._passRenderer.renderScreenSpace(renderer, this._blurMaterial, renderTargets[2]);
    }
}

const NORMAL_VECTOR_SOURCE_TYPES = {
    INPUT_RGB_NORMAL: 'inputRgbNormal',
    FLOAT_BUFFER_NORMAL: 'floatBufferNormal',
    CONSTANT_Z: 'constantZ',
};
const DEPTH_VALUE_SOURCE_TYPES = {
    SEPARATE_BUFFER: 'separateBuffer',
    NORMAL_VECTOR_ALPHA: 'normalVectorAlpha',
};

const AO_ALGORITHMS = {
    SSAO: 0,
    SAO: 1,
    N8AO: 2,
    HBAO: 3,
    GTAO: 4,
};
const generateAoSampleKernelInitializer = (samples, cosineWeighted) => {
    const poissonDisk = generateAoSamples(samples, cosineWeighted);
    let glslCode = 'vec4[SAMPLES](';
    for (let i = 0; i < samples; i++) {
        const sample = poissonDisk[i];
        glslCode += `vec4(${sample.x}, ${sample.y}, ${sample.z}, ${sample.w})${i < samples - 1 ? ',' : ')'}`;
    }
    return glslCode;
};
const generateAoSamples = (samples, cosineWeighted) => {
    // https://github.com/Rabbid76/research-sampling-hemisphere
    const kernel = [];
    for (let sampleIndex = 0; sampleIndex < samples; sampleIndex++) {
        const spiralAngle = sampleIndex * Math.PI * (3 - Math.sqrt(5));
        const z = 0.01 + (sampleIndex / (samples - 1)) * 0.99;
        const radius = cosineWeighted ? Math.sqrt(1 - z * z) : 1 - z;
        const x = Math.cos(spiralAngle) * radius;
        const y = Math.sin(spiralAngle) * radius;
        const scaleStep = 4;
        const scaleRange = Math.floor(samples / scaleStep);
        const scaleIndex = Math.floor(sampleIndex / scaleStep) +
            (sampleIndex % scaleStep) * scaleRange;
        let scale = 1 - scaleIndex / samples;
        scale = 0.1 + 0.9 * scale;
        kernel.push(new Vector4(x, y, z, scale));
    }
    return kernel;
};
const AOShader = {
    name: 'AOShader',
    defines: {
        PERSPECTIVE_CAMERA: 1,
        SAMPLES: 16,
        SAMPLE_VECTORS: generateAoSampleKernelInitializer(16, false),
        NORMAL_VECTOR_TYPE: 1,
        DEPTH_SWIZZLING: 'x',
        AO_ALGORITHM: AO_ALGORITHMS.GTAO,
        NV_ALIGNED_SAMPLES: 1,
        SCREEN_SPACE_RADIUS: 0,
        SCREEN_SPACE_RADIUS_SCALE: 100.0,
        SCENE_CLIP_BOX: 0,
        NORMAL_VECTOR_ANTIALIAS: 2,
        DEPTH_BUFFER_ANTIALIAS: 1,
    },
    uniforms: {
        tNormal: { value: null },
        tDepth: { value: null },
        tNoise: { value: null },
        resolution: { value: new Vector2() },
        cameraNear: { value: null },
        cameraFar: { value: null },
        cameraProjectionMatrix: { value: new Matrix4() },
        cameraProjectionMatrixInverse: { value: new Matrix4() },
        cameraWorldMatrix: { value: new Matrix4() },
        radius: { value: 1 },
        distanceExponent: { value: 1 },
        thickness: { value: 1 },
        distanceFallOff: { value: 1 },
        bias: { value: 0.001 },
        scale: { value: 1 },
        sceneBoxMin: { value: new Vector3(-1, -1, -1) },
        sceneBoxMax: { value: new Vector3(1, 1, 1) },
    },
    vertexShader: /* glsl */ `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,
    fragmentShader: /* glsl */ `

		varying vec2 vUv;
		uniform highp sampler2D tNormal;
		uniform highp sampler2D tDepth;
		uniform sampler2D tNoise;
		uniform vec2 resolution;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraProjectionMatrixInverse;		
		uniform mat4 cameraWorldMatrix;
		uniform float radius;
		uniform float distanceExponent;
		uniform float thickness;
		uniform float distanceFallOff;
		uniform float bias;
		uniform float scale;
		#if SCENE_CLIP_BOX == 1
			uniform vec3 sceneBoxMin;
			uniform vec3 sceneBoxMax;
		#endif
		
		#include <common>
		#include <packing>

		#ifndef FRAGMENT_OUTPUT
		#define FRAGMENT_OUTPUT vec4(vec3(ao), 1.)
		#endif

		const vec4 sampleKernel[SAMPLES] = SAMPLE_VECTORS;

		vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {
			vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);
			vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;
			return viewSpacePosition.xyz / viewSpacePosition.w;
		}

		float getDepth(const vec2 uv) {  
			#if DEPTH_BUFFER_ANTIALIAS == 1
				vec2 size = vec2(textureSize(tDepth, 0));
				ivec2 p = ivec2(uv * size);
				float d0 = texelFetch(tDepth, p, 0).DEPTH_SWIZZLING;
				vec2 depth = vec2(d0, 1.0);
				float d1 = texelFetch(tDepth, p + ivec2(1, 0), 0).DEPTH_SWIZZLING;
				depth += vec2(d1, 1.0) * step(abs(d1 - d0), 0.1);
				float d2 = texelFetch(tDepth, p - ivec2(1, 0), 0).DEPTH_SWIZZLING;
				depth += vec2(d2, 1.0) * step(abs(d2 - d0), 0.1);
				float d3 = texelFetch(tDepth, p + ivec2(0, 1), 0).DEPTH_SWIZZLING;
				depth += vec2(d3, 1.0) * step(abs(d3 - d0), 0.1);
				float d4 = texelFetch(tDepth, p - ivec2(0, 1), 0).DEPTH_SWIZZLING;
				depth += vec2(d4, 1.0) * step(abs(d4 - d0), 0.1);
				return depth.x / depth.y;
          	#else
              	return textureLod(tDepth, uv.xy, 0.0).DEPTH_SWIZZLING;
          	#endif
		}

		float fetchDepth(const ivec2 uv) {   
			return texelFetch(tDepth, uv.xy, 0).DEPTH_SWIZZLING;
		}

		float getViewZ(const in float depth) {
			#if PERSPECTIVE_CAMERA == 1
				return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
			#else
				return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
			#endif
		}

		vec3 computeNormalFromDepth(const vec2 uv) {
            vec2 size = vec2(textureSize(tDepth, 0));
            ivec2 p = ivec2(uv * size);
            float c0 = fetchDepth(p);
            float l2 = fetchDepth(p - ivec2(2, 0));
            float l1 = fetchDepth(p - ivec2(1, 0));
            float r1 = fetchDepth(p + ivec2(1, 0));
            float r2 = fetchDepth(p + ivec2(2, 0));
            float b2 = fetchDepth(p - ivec2(0, 2));
            float b1 = fetchDepth(p - ivec2(0, 1));
            float t1 = fetchDepth(p + ivec2(0, 1));
            float t2 = fetchDepth(p + ivec2(0, 2));
            float dl = abs((2.0 * l1 - l2) - c0);
            float dr = abs((2.0 * r1 - r2) - c0);
            float db = abs((2.0 * b1 - b2) - c0);
            float dt = abs((2.0 * t1 - t2) - c0);
            vec3 ce = getViewPosition(uv, c0).xyz;
            vec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz
                                  : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;
            vec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz
                                  : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;
            return normalize(cross(dpdx, dpdy));
		}

		vec3 getViewNormal(const vec2 uv) {
			#if NORMAL_VECTOR_TYPE == 2
				return normalize(textureLod(tNormal, uv, 0.).rgb);
			#elif NORMAL_VECTOR_TYPE == 1
				return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);
			#else
				return computeNormalFromDepth(uv);
			#endif
		}

		vec3 getAntiAliasedViewNormal(const in vec2 screenPosition) {
			#if NORMAL_VECTOR_TYPE == 2
				#if NORMAL_VECTOR_ANTIALIAS == 1
					vec2 uv = screenPosition;
					vec2 size = vec2(textureSize(tNormal, 0));
					ivec2 p = ivec2(screenPosition * size);
					float c0 = texelFetch(tNormal, p, 0).a;
					float l2 = texelFetch(tNormal, p - ivec2(2, 0), 0).a;
					float l1 = texelFetch(tNormal, p - ivec2(1, 0), 0).a;
					float r1 = texelFetch(tNormal, p + ivec2(1, 0), 0).a;
					float r2 = texelFetch(tNormal, p + ivec2(2, 0), 0).a;
					float b2 = texelFetch(tNormal, p - ivec2(0, 2), 0).a;
					float b1 = texelFetch(tNormal, p - ivec2(0, 1), 0).a;
					float t1 = texelFetch(tNormal, p + ivec2(0, 1), 0).a;
					float t2 = texelFetch(tNormal, p + ivec2(0, 2), 0).a;
					float dl = abs((2.0 * l1 - l2) - c0);
					float dr = abs((2.0 * r1 - r2) - c0);
					float db = abs((2.0 * b1 - b2) - c0);
					float dt = abs((2.0 * t1 - t2) - c0);
					vec3 ce = getViewPosition(uv, c0).xyz;
					vec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz
										  : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;
					vec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz
										  : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;
					return normalize(cross(dpdx, dpdy));
				#elif NORMAL_VECTOR_ANTIALIAS == 2
					vec2 size = vec2(textureSize(tNormal, 0));
					ivec2 p = ivec2(screenPosition * size);
					vec3 normalVector = texelFetch(tNormal, p, 0).xyz;
					normalVector += texelFetch(tNormal, p + ivec2(1, 0), 0).xyz;
					normalVector += texelFetch(tNormal, p - ivec2(1, 0), 0).xyz;
					normalVector += texelFetch(tNormal, p + ivec2(0, 1), 0).xyz;
					normalVector += texelFetch(tNormal, p - ivec2(0, 1), 0).xyz;
					return normalize(normalVector);
				#else
					return texture2D(tNormal, screenPosition).xyz;
				#endif
			#elif NORMAL_VECTOR_TYPE == 1
				return unpackRGBToNormal(textureLod(tNormal, screenPosition, 0.).rgb);
			#else
				return computeNormalFromDepth(screenPosition);
			#endif
		  }

		vec3 getSceneUvAndDepth(vec3 sampleViewPos) {
			vec4 sampleClipPos = cameraProjectionMatrix * vec4(sampleViewPos, 1.);
			vec2 sampleUv = sampleClipPos.xy / sampleClipPos.w * 0.5 + 0.5;
			float sampleSceneDepth = getDepth(sampleUv);
			return vec3(sampleUv, sampleSceneDepth);
		}

		float sinusToPlane(vec3 pointOnPlane, vec3 planeNormal, vec3 point) {
			vec3 delta = point - pointOnPlane;
			float sinV = dot(planeNormal, normalize(delta));
			return sinV;
		}

		float getFallOff(float delta, float falloffDistance) {
			float fallOff = smoothstep(0., 1., 1. - distanceFallOff * abs(delta) / falloffDistance);
			return fallOff;
		}
		
		void main() {
			float depth = getDepth(vUv.xy);
			if (depth >= 1.0) {
				discard;
				return;
			}
			vec3 viewPos = getViewPosition(vUv, depth);
			vec3 viewNormal = getAntiAliasedViewNormal(vUv);

			float radiusToUse = radius;
			float distanceFalloffToUse = thickness;
			#if SCREEN_SPACE_RADIUS == 1
			    float radiusScale = getViewPosition(vec2(0.5 + float(SCREEN_SPACE_RADIUS_SCALE) / resolution.x, 0.0), depth).x;
				radiusToUse *= radiusScale;
				distanceFalloffToUse *= radiusScale;
			#endif

			#if SCENE_CLIP_BOX == 1
				vec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;
      			float boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));
				if (boxDistance > radiusToUse) {
					discard;
					return;
				}
			#endif
			
			vec2 noiseResolution = vec2(textureSize(tNoise, 0));
			vec2 noiseUv = vUv * resolution / noiseResolution;
			vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);
			vec3 randomVec = noiseTexel.xyz * 2.0 - 1.0;

			#if NV_ALIGNED_SAMPLES == 1
  				vec3 tangent = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
      			vec3 bitangent = cross(viewNormal, tangent);
      			mat3 kernelMatrix = mat3(tangent, bitangent, viewNormal);
			#else
				vec3 tangent = normalize(vec3(randomVec.xy, 0.));
				vec3 bitangent = vec3(-tangent.y, tangent.x, 0.);
				mat3 kernelMatrix = mat3(tangent, bitangent, vec3(0., 0., 1.));
			#endif

		#if AO_ALGORITHM == 4
			const int DIRECTIONS = SAMPLES < 30 ? 3 : 5;
			const int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;
		#elif AO_ALGORITHM == 3
			const int DIRECTIONS = SAMPLES < 16 ? 3 : 5;
			const int STEPS = (SAMPLES + DIRECTIONS - 1) / DIRECTIONS;
		#else
			const int DIRECTIONS = SAMPLES;
			const int STEPS = 1;
		#endif

			float ao = 0.0, totalWeight = 0.0;
			for (int i = 0; i < DIRECTIONS; ++i) {

			#if AO_ALGORITHM == 4
				float angle = float(i) / float(DIRECTIONS) * PI;
				vec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w); 
			#elif AO_ALGORITHM == 3
				float angle = float(i) / float(DIRECTIONS) * 2. * PI;
				vec4 sampleDir = vec4(cos(angle), sin(angle), 0., 0.5 + 0.5 * noiseTexel.w); 
			#else
				vec4 sampleDir = sampleKernel[i];
			#endif
				sampleDir.xyz = normalize(kernelMatrix * sampleDir.xyz);

				vec3 viewDir = normalize(-viewPos.xyz);
				vec3 sliceBitangent = normalize(cross(sampleDir.xyz, viewDir));
				vec3 sliceTangent = cross(sliceBitangent, viewDir);
				vec3 normalInSlice = normalize(viewNormal - sliceBitangent * dot(viewNormal, sliceBitangent));
				
			#if (AO_ALGORITHM == 3 || AO_ALGORITHM == 4)
				vec3 tangentToNormalInSlice = cross(normalInSlice, sliceBitangent);
				#if AO_ALGORITHM == 4
					vec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice), dot(viewDir, -tangentToNormalInSlice));
				#else
					vec2 cosHorizons = vec2(dot(viewDir, tangentToNormalInSlice));
				#endif
				for (int j = 0; j < STEPS; ++j) {
					vec3 sampleViewOffset = sampleDir.xyz * radiusToUse * sampleDir.w * pow(float(j + 1) / float(STEPS), distanceExponent);
					vec3 sampleViewPos = viewPos + sampleViewOffset;
			#else
					vec3 sampleViewPos = viewPos + sampleDir.xyz * radiusToUse * pow(sampleDir.w, distanceExponent);
			#endif	

					vec3 sampleSceneUvDepth = getSceneUvAndDepth(sampleViewPos);
					vec3 sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);
					float sceneSampleDist = abs(sampleSceneViewPos.z);
					float sampleDist = abs(sampleViewPos.z);
					
				#if (AO_ALGORITHM == 3 || AO_ALGORITHM == 4)
					// HBAO || GTAO
					vec3 viewDelta = sampleSceneViewPos - viewPos;
					if (abs(viewDelta.z) < thickness) {
						vec2 clipRangeCheck = step(0., sampleSceneUvDepth.xy) * step(sampleSceneUvDepth.xy, vec2(1.));
						float sampleCosHorizon = dot(viewDir, normalize(viewDelta));
						cosHorizons.x += max(0., (sampleCosHorizon - cosHorizons.x) * mix(1., 2. / float(j + 2), distanceFallOff) * clipRangeCheck.x * clipRangeCheck.y);
					}		
					#if AO_ALGORITHM == 4
						sampleSceneUvDepth = getSceneUvAndDepth(viewPos - sampleViewOffset);
						sampleSceneViewPos = getViewPosition(sampleSceneUvDepth.xy, sampleSceneUvDepth.z);
						viewDelta = sampleSceneViewPos - viewPos;
						if (abs(viewDelta.z) < thickness) {
							vec2 clipRangeCheck = step(0., sampleSceneUvDepth.xy) * step(sampleSceneUvDepth.xy, vec2(1.));
							float sampleCosHorizon = dot(viewDir, normalize(viewDelta));
							cosHorizons.y += max(0., (sampleCosHorizon - cosHorizons.y) * mix(1., 2. / float(j + 2), distanceFallOff) * clipRangeCheck.x * clipRangeCheck.y);	
						}
					#endif
				#elif AO_ALGORITHM == 2
					// N8AO
					float weight = dot(viewNormal, sampleDir.xyz);
					float occlusion = weight * step(sceneSampleDist + bias, sampleDist);
				#elif AO_ALGORITHM == 1
					// SAO
					vec3 viewDelta = sampleSceneViewPos - viewPos;
					float minResolution = 0.; // ?
					float scaledViewDist = length( viewDelta ) / scale;
					float weight = 1.;
					float occlusion = max(0., (dot(viewNormal, viewDelta) - minResolution) / scaledViewDist - bias) / (1. + scaledViewDist * scaledViewDist );
				#else
					// SSAO
					float weight = 1.;
					float occlusion = step(sceneSampleDist + bias, sampleDist);
				#endif

		#if AO_ALGORITHM == 4	
				}
				// GTAO
				vec2 sinHorizons = sqrt(1. - cosHorizons * cosHorizons);
				float nx = dot(normalInSlice, sliceTangent);
				float ny = dot(normalInSlice, viewDir);
				float nxb = 1. / 2. * (acos(cosHorizons.y) - acos(cosHorizons.x) + sinHorizons.x * cosHorizons.x - sinHorizons.y * cosHorizons.y);
				float nyb = 1. / 2. * (2. - cosHorizons.x * cosHorizons.x - cosHorizons.y * cosHorizons.y);
				float occlusion = nx * nxb + ny * nyb;
				ao += occlusion;
			}
			ao = clamp(ao / float(DIRECTIONS), 0., 1.);	
		#elif AO_ALGORITHM == 3
				}
				totalWeight += 1.;
				ao += max(0., cosHorizons.x - max(0., cosHorizons.y));
			}
			ao /= totalWeight + 1. - step(0., totalWeight);
			ao = clamp(1. - ao, 0., 1.);
		#else

				float fallOff = getFallOff(sceneSampleDist - sampleDist, distanceFalloffToUse);
				occlusion *= fallOff;
				vec2 diff = (vUv - sampleSceneUvDepth.xy) * resolution;
				occlusion *= step(1., dot(diff, diff));
				vec2 clipRangeCheck = step(0., sampleSceneUvDepth.xy) * step(sampleSceneUvDepth.xy, vec2(1.));
				occlusion *= clipRangeCheck.x * clipRangeCheck.y;
				weight *= clipRangeCheck.x * clipRangeCheck.y;
				totalWeight += weight;
				ao += occlusion;
			}
			ao /= totalWeight + 1. - step(0., totalWeight);
			ao = clamp(1. - ao, 0., 1.);
		#endif	

		#if SCENE_CLIP_BOX == 1
			ao = mix(ao, 1., smoothstep(0., radiusToUse, boxDistance));
		#endif
		#if AO_ALGORITHM != 1
			ao = pow(ao, scale);
		#endif
			gl_FragColor = FRAGMENT_OUTPUT;
		}`,
};

const defaultAORenderPassParameters = {
    resolutionScale: 1,
    algorithm: AO_ALGORITHMS.SSAO,
    samples: 32,
    radius: 0.25,
    distanceExponent: 2,
    thickness: 0.5,
    distanceFallOff: 0.5,
    scale: 1,
    bias: 0.01,
    screenSpaceRadius: false,
};
class AORenderPass {
    get texture() {
        var _a;
        return this._renderTarget ? (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.texture : null;
    }
    constructor(width, height, parameters) {
        this.needsUpdate = true;
        this.parameters = {
            ...defaultAORenderPassParameters,
        };
        this._width = 0;
        this._height = 0;
        this._normalVectorSourceType = NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL;
        this._depthValueSourceType = DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA;
        this._modulateRedChannel = false;
        this.depthTexture = null;
        this.normalTexture = null;
        this._noiseTexture = null;
        this._renderTarget = null;
        this._passRenderer = new PassRenderer();
        this._sceneClipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1));
        this._sceneScale = 1;
        this._width = width;
        this._height = height;
        this._normalVectorSourceType =
            (parameters === null || parameters === void 0 ? void 0 : parameters.normalVectorSourceType) ||
                NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL;
        this._depthValueSourceType =
            (parameters === null || parameters === void 0 ? void 0 : parameters.depthValueSourceType) ||
                DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA;
        this._modulateRedChannel = (parameters === null || parameters === void 0 ? void 0 : parameters.modulateRedChannel) || false;
        if (parameters === null || parameters === void 0 ? void 0 : parameters.aoParameters) {
            this.parameters = parameters.aoParameters;
        }
        if (parameters) {
            this.updateTextures(parameters);
        }
    }
    _getNoiseTexture(size = 64) {
        if (!this._noiseTexture) {
            const simplex = new SimplexNoise();
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = i;
                    const y = j;
                    data[(i * size + j) * 4] = (simplex.noise(x, y) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 1] =
                        (simplex.noise(x + size, y) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 2] =
                        (simplex.noise(x, y + size) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 3] =
                        (simplex.noise(x + size, y + size) + 1.0) * 127.5;
                }
            }
            this._noiseTexture = new DataTexture(data, size, size, RGBAFormat$1, UnsignedByteType);
            this._noiseTexture.wrapS = RepeatWrapping;
            this._noiseTexture.wrapT = RepeatWrapping;
            this._noiseTexture.needsUpdate = true;
        }
        return this._noiseTexture;
    }
    _getMaterial(camera, needsUpdate) {
        let updateShader = needsUpdate;
        if (!this._aoMaterial) {
            this._aoMaterial = this._newAoMaterial();
            updateShader = true;
        }
        if (updateShader) {
            this._updateShader(this._aoMaterial, camera);
            this._aoMaterial.needsUpdate = true;
        }
        this._updateUniforms(this._aoMaterial, camera, updateShader);
        return this._aoMaterial;
    }
    _newAoMaterial() {
        const aoMaterial = new ShaderMaterial({
            defines: Object.assign({}, AOShader.defines),
            uniforms: UniformsUtils.clone(AOShader.uniforms),
            vertexShader: AOShader.vertexShader,
            fragmentShader: AOShader.fragmentShader,
            depthTest: false,
            depthWrite: false,
        });
        if (this._modulateRedChannel) {
            aoMaterial.blending = CustomBlending;
            aoMaterial.blendEquation = MinEquation;
            aoMaterial.blendEquationAlpha = null;
            aoMaterial.blendSrc = OneFactor;
            aoMaterial.blendSrcAlpha = null;
            aoMaterial.blendDst = OneFactor;
            aoMaterial.blendDstAlpha = null;
        }
        aoMaterial.defines.FRAGMENT_OUTPUT = this._modulateRedChannel
            ? 'vec4(ao, 1., 1., 1.)'
            : undefined;
        //aoMaterial.uniforms.tNoise.value = this._getNoiseTexture();
        aoMaterial.uniforms.tNoise.value =
            generateMagicSquareDistributedKernelRotations(5);
        return aoMaterial;
    }
    _updateShader(aoMaterial, camera) {
        aoMaterial.defines.PERSPECTIVE_CAMERA = camera
            .isPerspectiveCamera
            ? 1
            : 0;
        aoMaterial.defines.SAMPLES = this.parameters.samples;
        aoMaterial.defines.SAMPLE_VECTORS = generateAoSampleKernelInitializer(this.parameters.samples, this.parameters.algorithm === AO_ALGORITHMS.SSAO);
        aoMaterial.defines.NORMAL_VECTOR_TYPE =
            this._normalVectorSourceType ===
                NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL
                ? 2
                : 1;
        aoMaterial.defines.DEPTH_SWIZZLING =
            this._depthValueSourceType ===
                DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
                ? 'a'
                : 'x';
        aoMaterial.defines.AO_ALGORITHM = this.parameters.algorithm;
        aoMaterial.defines.NV_ALIGNED_SAMPLES =
            this.parameters.algorithm === AO_ALGORITHMS.HBAO ||
                this.parameters.algorithm === AO_ALGORITHMS.GTAO
                ? 0
                : 1;
        aoMaterial.defines.SCREEN_SPACE_RADIUS = this.parameters.screenSpaceRadius
            ? 1
            : 0;
        aoMaterial.defines.SCENE_CLIP_BOX = 1;
    }
    _updateUniforms(aoMaterial, camera, updateShader) {
        const sceneScale = this.parameters.screenSpaceRadius ? 1 : this._sceneScale;
        const depthTexture = this._depthValueSourceType ===
            DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
            ? this.normalTexture
            : this.depthTexture;
        aoMaterial.uniforms.tNormal.value = this.normalTexture;
        aoMaterial.uniforms.tDepth.value = depthTexture;
        aoMaterial.uniforms.resolution.value.set(this._width, this._height);
        aoMaterial.uniforms.cameraProjectionMatrix.value.copy(camera.projectionMatrix);
        aoMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
        aoMaterial.uniforms.cameraWorldMatrix.value.copy(camera.matrixWorld);
        const currentCamera = camera;
        aoMaterial.uniforms.cameraNear.value = currentCamera.near;
        aoMaterial.uniforms.cameraFar.value = currentCamera.far;
        if (updateShader) {
            aoMaterial.uniforms.radius.value = this.parameters.radius * sceneScale;
            aoMaterial.uniforms.distanceExponent.value =
                this.parameters.distanceExponent;
            aoMaterial.uniforms.thickness.value =
                this.parameters.thickness * sceneScale;
            aoMaterial.uniforms.distanceFallOff.value =
                this.parameters.distanceFallOff;
            aoMaterial.uniforms.scale.value = this.parameters.scale;
            if (this._sceneClipBox) {
                aoMaterial.uniforms.sceneBoxMin.value.copy(this._sceneClipBox.min);
                aoMaterial.uniforms.sceneBoxMax.value.copy(this._sceneClipBox.max);
            }
        }
    }
    _getRenderTargets() {
        if (!this._renderTarget) {
            this._renderTarget = new WebGLRenderTarget(this._width, this._height, {
                magFilter: LinearFilter,
                minFilter: LinearFilter,
            });
        }
        return this._renderTarget;
    }
    dispose() {
        var _a, _b, _c;
        (_a = this._noiseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._aoMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
        (_c = this._renderTarget) === null || _c === void 0 ? void 0 : _c.dispose();
    }
    setSize(width, height) {
        var _a;
        this._width = width;
        this._height = height;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
        this.needsUpdate = true;
    }
    updateBounds(sceneClipBox, sceneScale) {
        this._sceneClipBox = new Box3().copy(sceneClipBox);
        this._sceneScale = sceneScale !== null && sceneScale !== void 0 ? sceneScale : 1;
        this.needsUpdate = true;
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
                this.needsUpdate = true;
            }
        }
    }
    updateTextures(parameters) {
        if (parameters.depthTexture) {
            this.depthTexture = parameters.depthTexture;
            this.needsUpdate = true;
        }
        if (parameters.normalTexture) {
            this.normalTexture = parameters.normalTexture;
            this.needsUpdate = true;
        }
    }
    clear(renderer, renderTarget) {
        this._passRenderer.clear(renderer, renderTarget ? renderTarget : this._getRenderTargets(), 0xffffff, 1);
    }
    render(renderer, camera, scene, renderTarget) {
        const hbaoMaterial = this._getMaterial(camera, this.needsUpdate);
        this.needsUpdate = false;
        this._passRenderer.renderScreenSpace(renderer, hbaoMaterial, renderTarget ? renderTarget : this._getRenderTargets());
    }
}

const SCENE_SHADING_TYPES = {
    DEFAULT: 'default',
    BRIGHT: 'bright',
};
const brightSceneShadingParameters = {
    shadowType: 'PCFSoftShadowMap',
    shAndAoPassParameters: {
        aoIntensity: 0.3,
        shadow: {
            shadowRadius: 0.1,
        },
        ao: {
            algorithm: AO_ALGORITHMS.SSAO,
            samples: 32,
            radius: 0.02,
            distanceExponent: 2,
            thickness: 0.1,
            distanceFallOff: 1,
            bias: 0.01,
        },
        poissonDenoise: {
            iterations: 2,
            samples: 16,
            radius: 5,
            radiusExponent: 1,
            lumaPhi: 10,
            depthPhi: 0.4,
            normalPhi: 4,
        },
    },
    groundReflectionParameters: {
        brightness: 0.5,
    },
};
const mergeRendererParameters = (...args) => {
    if (args.length === 0) {
        return null;
    }
    if (args.length === 1) {
        return args[0];
    }
    let target = args[0];
    for (let i = 1; i < args.length; i++) {
        target = deepMerge(target, args[i]);
    }
    return target;
};
const getInteractionParameters = (uiInteractionMode) => {
    return uiInteractionMode
        ? {
            groundReflectionParameters: {
                enabled: false,
            },
        }
        : null;
};
const getShadingParameters = (shadingType) => {
    if (!shadingType || shadingType === SCENE_SHADING_TYPES.DEFAULT) {
        return null;
    }
    if (shadingType === SCENE_SHADING_TYPES.BRIGHT) {
        return brightSceneShadingParameters;
    }
    return null;
};

class InitData {
    constructor(creator) {
        // common init data
        this.autoQuality = false;
        this.colors = ROOMLE_COLORS;
        this.unit = null;
        this.unitStringType = null;
        this.meshSelection = true;
        this.stats = false;
        this._measureTraffic = false;
        this.disableDebugGUI = false;
        this.disableEnvMap = false;
        this.envMapUrl = ENV_HDR_256_FILE_NAME;
        this.envMapIntensity = 1.5;
        this.envMapRotation = 0;
        this.maxLightSources = -1;
        this.legacyLight = false;
        this.sceneLight = null;
        this.shading = SCENE_SHADING_TYPES.DEFAULT;
        this.restrictionLevel = 0;
        this.e2e = false;
        this.highlighting = ROOMLE_HIGHLIGHTNG.SMART;
        this.dls = null;
        this.ls = null;
        this.cameraSpacing = 0;
        this.transparentHighlighting = true;
        this.featureFlags = {
            pulsePreview: false,
            reDock: false,
        };
        // planner init data
        this.mode = CAMERA_TYPE.CAMERA_3D;
        this.edit = false;
        this.moc = false;
        /**
         * If true, the callbacks will only be called if the geometry is ready.
         * Before RML-8368 false was the default. For more info see there
         */
        this.callbacksOnlyIfGeometryIsReady = true;
        this._creator_ = creator;
    }
    setOverrides(initData) {
        deepMerge(this, initData);
    }
}

const BROWSER_LANGUAGE_PROPERTY_KEYS_KNOWN = [
    'language',
    'browserLanguage',
    'userLanguage',
    'systemLanguage',
];
const getLanguage = (lang = null) => {
    const navigator = window.navigator;
    if (lang) {
        return lang.substr(0, 2);
    }
    if (Array.isArray(navigator.languages) && navigator.languages.length > 0) {
        return navigator.languages[0].substr(0, 2);
    }
    for (let i = 0, length = BROWSER_LANGUAGE_PROPERTY_KEYS_KNOWN.length; i < length; i++) {
        const language = navigator[BROWSER_LANGUAGE_PROPERTY_KEYS_KNOWN[i]];
        if (language) {
            return language.substr(0, 2);
        }
    }
    return 'en';
};
const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

class GlobalInitData {
    constructor(creator) {
        this.locale = getLanguage() || 'en';
        this.overrideCountry = null;
        this._creator_ = creator;
    }
    setOverrides(globalInitData) {
        deepMerge(this, globalInitData);
    }
}

const UI_CALLBACK_PREFIX = 'on';
const isMuteProperty = '_isMute';
class UiCallback {
    _setMute(isMute) {
        setWriteable(this, isMuteProperty, true);
        this._isMute = isMute;
        setWriteable(this, isMuteProperty, false);
    }
    mute() {
        this._setMute(true);
    }
    unmute() {
        this._setMute(false);
    }
    constructor(creator) {
        this._isMute = false;
        this.cameraStartsMoving = () => undefined;
        this._creator_ = creator;
        setDescriptor(this, isMuteProperty, { enumerable: false, writable: false });
        setDescriptor(UiCallback.prototype, '_setMute', {
            enumerable: false,
            writable: false,
        });
        setDescriptor(UiCallback.prototype, 'mute', {
            enumerable: false,
            writable: false,
        });
        setDescriptor(UiCallback.prototype, 'unmute', {
            enumerable: false,
            writable: false,
        });
        return new Proxy(this, this);
    }
    get(target, prop) {
        if (this._isMute &&
            typeof this[prop] === 'function' &&
            prop.substr(0, 2) === UI_CALLBACK_PREFIX) {
            return () => undefined;
        }
        return this[prop];
    }
}

class GlobalCallback extends UiCallback {
    constructor() {
        super(...arguments);
        /**
         * is called when a network request is made
         * @param url string the fetched url
         * @param data RequestInit what is used to init the request
         * @param options object what additional options do we use
         */
        this.onNetworkRequest = (_url, _data, _options) => undefined;
        /**
         * is called when the Kernel sends us some message
         * @param _type KernelMessageType can either be exception, error or warning
         * @param _message string the message from the Kernel
         * @param _meta KernelMessageMetaInfo optional, adds more information for debugging
         */
        this.onKernelMsg = (_type, _message, _meta = {}) => undefined;
        this.onCheckExternalCache = async (_url, _requestData) => Promise.resolve(null);
        this.onValidateNetworkResponse = (_type, _response) => Promise.resolve(true);
    }
}

const CANVAS_ID = {
    HSC: 'rml-configurator',
    HSP: 'rml-hsp',
    GLB: 'rml-glb',
    RMV: 'rml-mv',
};
const CONTAINER_CSS_CLASS = 'rml-threejs-canvas-container';
class DomHelper {
    get element() {
        return this._container;
    }
    constructor(creator) {
        this._creator_ = creator;
        this._lifeCycleManager.addEventListener(this);
    }
    setDomElement(element) {
        if (!this._container) {
            this._container = document.createElement('div');
            this._container.classList.add(CONTAINER_CSS_CLASS);
            this._container.setAttribute('ondragover', 'return false');
            this._container.style.position = 'relative';
            this._container.style.width = '100%';
            this._container.style.height = '100%';
            const style = document.createElement('style');
            style.innerText =
                '.' +
                    CONTAINER_CSS_CLASS +
                    ' canvas{position:absolute;top:0;left:0;right:0;bottom:0;z-index:100; opacity:1;}';
            this._container.appendChild(style);
            element.appendChild(this._container);
        }
        this._element = element;
    }
    getClientDimensions() {
        return new Vector2(this._element.clientWidth, this._element.clientHeight);
    }
    _removeDomElement(domElement) {
        if (!domElement) {
            return;
        }
        const parent = domElement.parentElement;
        if (parent) {
            parent.removeChild(domElement);
        }
    }
    reset() {
        // this._removeDomElement(this._element);
        this._element = null;
        this._removeDomElement(this._container);
        this._container = null;
    }
    pause() {
        this.reset();
    }
    resume() {
        //Keep TSLint quiet
    }
    destroy() {
        //Keep TSLint quiet
    }
}
__decorate([
    inject
], DomHelper.prototype, "_lifeCycleManager", void 0);

class ScenePluginDefaultImplementation {
    constructor(creator) {
        this._creator_ = creator;
    }
    setScene(scene) {
        //noop
    }
    setUiScene(uiScene) {
        //noop
    }
    updateBounds(bounds) {
        //noop
    }
    clearScene(scene, uiScene) {
        //noop
    }
    moveCameraEnd(position) {
        //noop
    }
    moveCameraStart(position) {
        //noop
    }
    needsUiScene() {
        return false;
    }
}
class PluginSystem {
    constructor(creator) {
        this._plugins = [];
        this._creator_ = creator;
    }
    async init(scene, uiScene, cameraPosition) {
        this._scene = scene;
        this._uiScene = uiScene;
        this._cameraPosition = cameraPosition;
        const { bananaForScale } = this._initData;
        if (bananaForScale) {
            await import('./banana-for-scale-a3b25f52.js').then(({ default: BananaForScale }) => this._plugins.push(new BananaForScale(this._creator_)));
        }
        this._plugins.forEach((plugin) => plugin.setScene(this._scene));
        this._plugins.forEach((plugin) => plugin.setUiScene(this._uiScene));
        this._plugins.forEach((plugin) => plugin.updateBounds(this._bounds));
        this._plugins.forEach((plugin) => plugin.moveCameraEnd(this._cameraPosition));
    }
    addPlugin(plugin) {
        this._plugins.push(plugin);
        plugin.setScene(this._scene);
        plugin.setUiScene(this._uiScene);
        plugin.updateBounds(this._bounds);
        plugin.moveCameraEnd(this._cameraPosition);
    }
    updateBounds(bounds) {
        this._bounds = bounds;
        this._plugins.forEach((plugin) => plugin.updateBounds(bounds));
    }
    clearScene(scene, uiScene) {
        this._plugins.forEach((plugin) => plugin.clearScene(scene, uiScene));
    }
    getActivePlugins() {
        return this._plugins;
    }
    getPlugin(type) {
        for (let plugin of this._plugins) {
            if (plugin instanceof type) {
                return plugin;
            }
        }
        return null;
    }
    moveCameraEnd(position) {
        this._cameraPosition = position;
        this._plugins.forEach((plugin) => plugin.moveCameraEnd(position));
    }
    moveCameraStart(position) {
        this._cameraPosition = position;
        this._plugins.forEach((plugin) => plugin.moveCameraStart(position));
    }
    needsUiScene() {
        return this._plugins
            .map((plugin) => plugin.needsUiScene())
            .reduce((previousValue, currentValue) => previousValue || currentValue, false);
    }
}
__decorate([
    inject
], PluginSystem.prototype, "_initData", void 0);

const checkForAllSettled = () => {
    // polyfill allSettled if needed
    // see: https://caniuse.com/mdn-javascript_builtins_promise_allsettled
    // polyfill inspired by: https://github.com/amrayn/allsettled-polyfill/blob/master/index.js
    Promise.allSettled =
        Promise.allSettled ||
            ((promises) => Promise.all(promises.map((p) => p
                .then((v) => ({
                status: 'fulfilled',
                value: v,
            }))
                .catch((e) => ({
                status: 'rejected',
                reason: e,
            })))));
};
class PromiseQueue {
    constructor(callback, errorCallback) {
        this._waitingPromises = [];
        this._finishPromiseExecutor = [];
        this._errorCallback = () => undefined;
        checkForAllSettled();
        if (callback) {
            this.registerCallback(callback);
        }
        if (errorCallback) {
            this._errorCallback = errorCallback;
        }
    }
    push(promise) {
        this._waitingPromises.push(promise);
        Promise.all(this._waitingPromises).then((args) => {
            if (args.length === this._waitingPromises.length) {
                if (this._callback) {
                    this._callback(args);
                }
                this._waitingPromises = [];
            }
        }, this._errorCallback);
    }
    /**
     * Wait for current queue to finish
     */
    finished(ignoreErrors = false) {
        return new Promise((resolve, reject) => {
            this._finishPromiseExecutor.push({ resolve, reject });
            const method = ignoreErrors ? 'allSettled' : 'all';
            Promise[method](this._waitingPromises).then((result) => {
                if (method === 'allSettled') {
                    const filteredResult = [];
                    result.forEach(({ value, status, }) => {
                        if (status === 'fulfilled') {
                            filteredResult.push(value);
                        }
                    });
                    this._resolveAllExecutors(filteredResult);
                }
                else {
                    this._resolveAllExecutors(result);
                }
            }, (e) => {
                this._rejectAllExecutors(e);
            });
        });
    }
    /**
     * Callback whenever queue is finished
     */
    registerCallback(callback) {
        this._callback = callback;
    }
    unregisterCallback() {
        this._callback = null;
    }
    _resolveAllExecutors(result) {
        this._finishPromiseExecutor.forEach(({ resolve }) => resolve(result));
        this._finishPromiseExecutor = [];
    }
    _rejectAllExecutors(error) {
        this._finishPromiseExecutor.forEach(({ reject }) => reject(error));
        this._finishPromiseExecutor = [];
    }
    clear() {
        const shouldReject = this._waitingPromises.length > 0;
        this._waitingPromises = [];
        if (shouldReject) {
            this._rejectAllExecutors(new Error('Promise queue has been cleared'));
        }
        else {
            this._resolveAllExecutors([]);
        }
    }
    get length() {
        return this._waitingPromises.length;
    }
}

class MeshGenerator {
    constructor(creator) {
        this.materialQueue = new PromiseQueue();
        this._geometryComponentMaterialCache = new Map();
        this._maxAnisotropy = 1;
        this._maxTextures = 16;
        this._textureLoader = new TextureLoader();
        this._configuratorPreviewMaterial = MaterialCreator.createMeshStandardMaterial({
            color: PREVIEW_MATERIAL_COLOR,
            transparent: true,
            opacity: PREVIEW_MATERIAL_OPACITY,
            roughness: PREVIEW_MATERIAL_ROUGHNESS,
            envMap: null,
            polygonOffset: true,
            polygonOffsetFactor: -1,
        });
        this._creator_ = creator;
        this._previewMaterial = MaterialCreator.createMeshStandardMaterial({
            color: PREVIEW_MATERIAL_COLOR,
            roughness: PREVIEW_MATERIAL_ROUGHNESS,
            metalness: PREVIEW_MATERIAL_METALNESS,
        });
    }
    getGeometry(meshId) {
        return meshId && this._cacheHolder.geometryCache.has(meshId)
            ? this._cacheHolder.geometryCache.get(meshId)
            : null;
    }
    _generateGeometry(meshId, vertices, indices, uvCoords, normals) {
        let geometry;
        if (!meshId || !this._cacheHolder.geometryCache.has(meshId)) {
            geometry = new BufferGeometry();
            geometry.setIndex(new Uint32BufferAttribute(indices, 1));
            geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new Float32BufferAttribute(uvCoords, 2));
            geometry.scale(1 / 1000, 1 / 1000, 1 / 1000);
            geometry.rotateX(-Math.PI / 2);
            if (meshId) {
                this._cacheHolder.geometryCache.set(meshId, geometry);
            }
        }
        else {
            geometry = this._cacheHolder.geometryCache.get(meshId);
        }
        return geometry;
    }
    changeMaterialOfMesh(mesh, material, materialAttributes) {
        if (mesh && material) {
            mesh.material = material;
            if (mesh.material.transparent ||
                mesh.material.opacity === 0 ||
                mesh.material.transmission > 0) {
                mesh.castShadow = false;
                mesh.receiveShadow = false;
            }
            else {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
            }
            mesh.material.needsUpdate = true;
            if (this._materialLoaded) {
                this._materialLoaded(material);
            }
            this._updateMaterialProperties(mesh, materialAttributes);
        }
        else {
            console.warn('could not assign material to mesh', { mesh }, { material });
        }
    }
    // eslint-disable-next-line complexity
    _updateMaterialProperties(mesh, materialAttributes) {
        var _a;
        if (materialAttributes &&
            Object.keys(materialAttributes).length > 0 &&
            mesh.material instanceof MeshStandardMaterial) {
            const newMaterial = mesh.material.clone();
            newMaterial.userData.materialAttributes = materialAttributes;
            this._updateStandardMaterialProperties(newMaterial, materialAttributes);
            if (newMaterial instanceof MeshPhysicalMaterial) {
                this._updatePhysicalMaterialProperties(newMaterial, materialAttributes);
            }
            newMaterial.transparent = newMaterial.opacity < 1;
            const currentMaterial = mesh.material;
            mesh.material = newMaterial;
            if ((_a = currentMaterial.userData) === null || _a === void 0 ? void 0 : _a.materialAttributes) {
                currentMaterial.dispose();
            }
        }
    }
    _updateStandardMaterialProperties(material, materialAttributes) {
        if (materialAttributes.color) {
            material.color = new Color$1(materialAttributes.color);
        }
        if (materialAttributes.alpha) {
            material.opacity = parseFloat(materialAttributes.alpha);
        }
        if (materialAttributes.roughness) {
            material.roughness = parseFloat(materialAttributes.roughness);
        }
        if (materialAttributes.metallic) {
            material.metalness = parseFloat(materialAttributes.metallic);
        }
        if (materialAttributes.alphaCutoff) {
            material.alphaTest = parseFloat(materialAttributes.alphaCutoff);
        }
        if (materialAttributes.doubleSided) {
            material.side = materialAttributes.doubleSided ? DoubleSide : FrontSide;
        }
        if (materialAttributes.occlusion) {
            material.aoMapIntensity = parseFloat(materialAttributes.occlusion);
        }
        if (materialAttributes.emissiveColor) {
            material.emissive = new Color$1(materialAttributes.emissiveColor);
        }
        if (materialAttributes.emissiveIntensity) {
            material.emissiveIntensity = parseFloat(materialAttributes.emissiveIntensity);
        }
    }
    _updatePhysicalMaterialProperties(material, materialAttributes) {
        if (materialAttributes.transmission) {
            material.transmission = parseFloat(materialAttributes.transmission);
        }
        if (materialAttributes.specularColor) {
            material.specularColor = new Color$1(materialAttributes.specularColor);
        }
        if (materialAttributes.specularity) {
            material.specularIntensity = parseFloat(materialAttributes.specularity);
        }
        if (materialAttributes.clearcoatIntensity) {
            material.clearcoat = parseFloat(materialAttributes.clearcoatIntensity);
        }
        if (materialAttributes.clearcoatRoughness) {
            material.clearcoatRoughness = parseFloat(materialAttributes.clearcoatRoughness);
        }
        if (materialAttributes.clearcoatNormalScale) {
            material.clearcoatNormalScale.setScalar(parseFloat(materialAttributes.clearcoatNormalScale));
        }
        if (materialAttributes.sheenColor) {
            material.sheenColor = new Color$1(materialAttributes.sheenColor);
        }
        if (materialAttributes.sheenIntensity) {
            material.sheen = parseFloat(materialAttributes.sheenIntensity);
        }
        if (materialAttributes.sheenRoughness) {
            material.sheenRoughness = parseFloat(materialAttributes.sheenRoughness);
        }
        if (materialAttributes.thicknessFactor) {
            material.thickness = parseFloat(materialAttributes.thicknessFactor);
        }
        if (materialAttributes.attenuationColor) {
            material.attenuationColor = new Color$1(materialAttributes.attenuationColor);
        }
        if (materialAttributes.attenuationDistance) {
            material.attenuationDistance = parseFloat(materialAttributes.attenuationDistance);
        }
    }
    _createMaterial(materialId, resolve, reject, width, height) {
        if (this._cacheHolder.materialCache.has(materialId)) {
            resolve();
            return;
        }
        if (materialId.startsWith('benchmarkMaterial')) {
            let rapiMaterial = createBenchmarkMaterial(materialId);
            let material = createMaterial(rapiMaterial);
            this._loadBenchmarkTextures(rapiMaterial, material, width, height).then(resolve, reject);
        }
        else {
            this._rapiAccess
                .getMaterial(materialId)
                .then((rapiMaterial) => {
                let material = createMaterial(rapiMaterial);
                this._loadTextures(rapiMaterial, material, width, height).then(resolve, reject);
            }, reject);
        }
    }
    _loadBenchmarkTextures(rapiMaterial, material, width = 1, height = 1) {
        return new Promise((resolve, reject) => {
            const rapiTexture = createBenchmarkTexture(rapiMaterial.id);
            addTexture(this._dataSyncer.requestAsset(rapiTexture.image, true /* use rapiTexture.image as fallback */), rapiTexture, material, this._maxAnisotropy, width / (rapiTexture.mmWidth === 0 ? 1 : rapiTexture.mmWidth), height / (rapiTexture.mmHeight === 0 ? 1 : rapiTexture.mmHeight), this._maxTextures).then(() => {
                this._cacheHolder.materialCache.set(rapiMaterial.id, material);
                resolve();
            }, reject);
        });
    }
    _loadTextures(rapiMaterial, material, width = 1, height = 1) {
        return new Promise((resolve, reject) => {
            if (!rapiMaterial.textures ||
                (rapiMaterial.textures && rapiMaterial.textures.length === 0)) {
                this._cacheHolder.materialCache.set(rapiMaterial.id, material);
                return resolve();
            }
            this._rapiAccess
                .getTexturesOf(rapiMaterial)
                .then((rapiTextures) => {
                let promises = [];
                rapiTextures.forEach((rapiTexture) => {
                    promises.push(addTexture(this._dataSyncer.requestAsset(rapiTexture.image, true /* use rapiTexture.image as fallback */), rapiTexture, material, this._maxAnisotropy, width / (rapiTexture.mmWidth === 0 ? 1 : rapiTexture.mmWidth), height /
                        (rapiTexture.mmHeight === 0 ? 1 : rapiTexture.mmHeight), this._maxTextures));
                });
                Promise.all(promises).then(() => {
                    this._cacheHolder.materialCache.set(rapiMaterial.id, material);
                    resolve();
                }, reject);
            });
        });
    }
    _loadMaterial(materialId, width, height) {
        return new Promise((resolveMaterialAssignment, rejectMaterialAssignment) => {
            this._singlePromiseFactory
                .create(6 /* PROMISE_CATEGORY.ASSIGN_MATERIAL */, materialId, (resolveCreateMaterial, rejectCreateMaterial) => this._createMaterial(materialId, resolveCreateMaterial, rejectCreateMaterial, width, height))
                .then(() => {
                setTimeout(() => resolveMaterialAssignment(this._cacheHolder.materialCache.get(materialId)), 0); // deferre to the next runloop so we can be sure three.js applied the material
            }, rejectMaterialAssignment);
        });
    }
    _assignMaterial(mesh, materialId, materialAttributes) {
        if (this._cacheHolder.materialCache.has(materialId)) {
            this.changeMaterialOfMesh(mesh, this._cacheHolder.materialCache.get(materialId), materialAttributes);
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            this._loadMaterial(materialId).then((material) => {
                // only change the material if it is the material currently defined by the mesh
                const shouldChangeMaterial = mesh.userData.materialId === materialId;
                if (shouldChangeMaterial) {
                    this.changeMaterialOfMesh(mesh, material, materialAttributes);
                }
                resolve();
            }, reject);
        });
    }
    get maxAnisotropy() {
        return this._maxAnisotropy;
    }
    set maxAnisotropy(maxAnisotropy) {
        this._maxAnisotropy = maxAnisotropy;
    }
    get maxTextures() {
        return this._maxTextures;
    }
    set maxTextures(maxTextures) {
        this._maxTextures = maxTextures;
    }
    clear() {
        this._cacheHolder.clear();
    }
    _assignRGB(mesh, rgbValue) {
        return new Promise((resolve) => {
            let materialId = 'rgb' + JSON.stringify(rgbValue);
            let material;
            if (this._cacheHolder.materialCache.has(materialId)) {
                material = this._cacheHolder.materialCache.get(materialId);
            }
            else {
                material = MaterialCreator.createMeshPhysicalMaterial({
                    color: rgbValue,
                });
                this._cacheHolder.materialCache.set(materialId, material);
            }
            this.changeMaterialOfMesh(mesh, material);
            setTimeout(() => resolve(), 0); // deferre to the next runloop so we can be sure three.js applied the material
        });
    }
    _assignItem(mesh, catalogItemId) {
        return new Promise((resolve, reject) => {
            if (this._cacheHolder.materialCache.has(catalogItemId)) {
                this.changeMaterialOfMesh(mesh, this._cacheHolder.materialCache.get(catalogItemId));
                resolve();
                return;
            }
            this._rapiAccess.getItem(catalogItemId).then((rapiItem) => {
                if (rapiItem.topImage) {
                    this._textureLoader.load(rapiItem.topImage, (texture) => {
                        texture.anisotropy = this._maxAnisotropy;
                        texture.wrapS = RepeatWrapping;
                        texture.wrapT = RepeatWrapping;
                        let scale = new Vector2(1, 1);
                        // UV space is in mm and rapi item size is also mm
                        if (rapiItem.width > 0) {
                            scale.x = 1 / rapiItem.width;
                        }
                        if (rapiItem.depth > 0) {
                            scale.y = 1 / rapiItem.depth;
                        }
                        texture.repeat.set(scale.x, scale.y);
                        const material = MaterialCreator.createMeshPhysicalMaterial({
                            map: texture,
                            roughness: 0.5,
                            metalness: 0.1,
                        });
                        this._cacheHolder.materialCache.set(catalogItemId, material);
                        this.changeMaterialOfMesh(mesh, material);
                        setTimeout(() => resolve(), 0); // deferre to the next runloop so we can be sure three.js applied the material
                    });
                }
                else {
                    const errorMsg = 'can not set material, catalog item top image is not set';
                    console.warn(errorMsg);
                    reject(errorMsg);
                }
            }, reject);
        });
    }
    setMaterialLoadedListener(fun) {
        this._materialLoaded = fun;
    }
    removeMaterialLoadedListener() {
        this._materialLoaded = undefined;
    }
    _createMesh(runtimeComponentId, geometryId, geometry) {
        if (runtimeComponentId && geometryId) {
            const componentMeshId = this._getComponentMeshId(runtimeComponentId, geometryId);
            if (this._geometryComponentMaterialCache.has(componentMeshId)) {
                const materialId = this._geometryComponentMaterialCache.get(componentMeshId);
                if (this._cacheHolder.materialCache.has(materialId)) {
                    const material = this._cacheHolder.materialCache.get(materialId);
                    return new Mesh(geometry, material);
                }
            }
        }
        return new Mesh(geometry, this._configuratorPreviewMaterial.clone());
    }
    _getComponentMeshId(runtimeComponentId, geometryId) {
        return runtimeComponentId + '_' + geometryId;
    }
}
__decorate([
    inject
], MeshGenerator.prototype, "_initData", void 0);
__decorate([
    inject
], MeshGenerator.prototype, "_rapiAccess", void 0);
__decorate([
    inject
], MeshGenerator.prototype, "_dataSyncer", void 0);
__decorate([
    inject
], MeshGenerator.prototype, "_singlePromiseFactory", void 0);
__decorate([
    inject
], MeshGenerator.prototype, "_cacheHolder", void 0);
__decorate([
    inject
], MeshGenerator.prototype, "_plannerMeshGenerator", void 0);

class ConfiguratorMeshGenerator extends MeshGenerator {
    constructor(creator) {
        super(creator);
    }
    generateMesh(runtimeComponentId = 0, geometryId = null, materialId, vertices, indices, uvCoords, normals, newGeometryInstance = false, materialAttributes) {
        let geometry;
        if (newGeometryInstance) {
            geometry = this._generateGeometry(geometryId, vertices, indices, uvCoords, normals).clone();
        }
        else {
            geometry = this._generateGeometry(geometryId, vertices, indices, uvCoords, normals);
        }
        const mesh = this._createMesh(runtimeComponentId, geometryId, geometry);
        mesh.userData.materialId = materialId;
        mesh.layers.set(4 /* LAYER.COMPONENT */);
        if (materialId) {
            this.materialQueue.push(this._assignMaterial(mesh, materialId, materialAttributes).then(() => {
                if (runtimeComponentId && geometryId) {
                    this._geometryComponentMaterialCache.set(this._getComponentMeshId(runtimeComponentId, geometryId), materialId);
                }
            }));
        }
        return mesh;
    }
    setMaterial(mesh, materialId, _type, materialAttributes) {
        return this._assignMaterial(mesh, materialId, materialAttributes);
    }
    loadMaterial(materialId, width, height) {
        return super._loadMaterial(materialId, width, height);
    }
    loadTextures(rapiMaterial, material, width, height) {
        return super._loadTextures(rapiMaterial, material, width, height);
    }
}

class EventDispatcher {
    constructor() {
        this._listeners = {};
        this._disabled = false;
    }
    _addEventListener(eventName, callback, scope) {
        if (!this._listeners[eventName]) {
            this._listeners[eventName] = [];
        }
        this._listeners[eventName].push({ callback, scope });
    }
    addEventListener(eventName, callback, scope) {
        this._addEventListener(eventName, callback, scope);
    }
    dispatchEvent(eventName, arg) {
        if (!this._listeners[eventName] || this._disabled) {
            return;
        }
        const listeners = this._listeners[eventName];
        for (let i = 0; i < this._listeners[eventName].length; i++) {
            const listener = listeners[i];
            if (arg) {
                listener.callback.apply(listener.scope, [arg]);
            }
            else {
                listener.callback.call(listener.scope);
            }
        }
    }
    removeEventListener(eventName, fun) {
        const listeners = this._listeners[eventName];
        if (!listeners) {
            return;
        }
        for (let i = 0, length = listeners.length; i < length; i++) {
            if (listeners[i].callback === fun) {
                listeners.splice(i, 1);
                return;
            }
        }
    }
    enableEvents() {
        this._disabled = false;
    }
    disableEvents() {
        this._disabled = true;
    }
}

const BROWSER_EVENTS = {
    SCROLL: 'scroll',
    MOUSE_MOVE: 'mousemove',
    MOUSE_DOWN: 'mousedown',
    MOUSE_UP: 'mouseup',
    MOUSE_LEAVE: 'mouseleave',
    MOUSE_ENTER: 'mouseenter',
    MOUSE_WHEEL: 'wheel',
    TOUCH_MOVE: 'touchmove',
    TOUCH_START: 'touchstart',
    TOUCH_END: 'touchend',
    CONTEXT_MENU: 'contextmenu',
    DOUBLE_CLICK: 'dblclick',
};
const EVENT_TYPE = {
    CLICK: 1,
    DOUBLE_CLICK: 2,
};
const INPUT_DELAY_TYPE = {
    DRAG: 50,
};
class InputEvent {
    constructor(position, positionRelative, type, rotation, event) {
        this.position = position;
        this.positionRelative = positionRelative;
        this.type = type;
        this.rotation = rotation;
        this.event = event;
    }
}
const MIN_MOVE_DISTANCE = 5 * window.devicePixelRatio;
const MIN_DOLLY_DISTANCE = 3 * window.devicePixelRatio;
class InputManager extends EventDispatcher {
    constructor(creator) {
        super();
        this._elementHit = false;
        this._delta = -1;
        this._state = 0 /* STATE.NONE */;
        this._pinchDistance = -1;
        this._rotationAngle = -1;
        this._lastMouseWheelEvent = null;
        this._lastTouchEvent = null;
        this._events = Object.keys(BROWSER_EVENTS).map((key) => BROWSER_EVENTS[key]);
        this._boundingClientRectInvalid = true;
        this._creator_ = creator;
        this._downPosition = { x: 0, y: 0 };
        this._downPositionRelative = { x: 0, y: 0 };
        this._boundingClientRect = this._getBoundingClientRect();
    }
    enableDragIn(dragEvent) {
        this._setState(1 /* STATE.DOWN */);
        this._dragEnabled = true;
        if (dragEvent) {
            this._dragMV = this._dragM.bind(this);
            this._dragEV = this._dragE.bind(this);
            this._dragTarget = dragEvent.currentTarget || dragEvent.target; // TOUCH START EVENTS DO NOT HAVE CURRENT TARGET THEREFORE USE TARGET
            this._delta = -1;
            this._dragMVName = 'drag';
            this._dragEVName = 'dragend';
            if (window.TouchEvent && dragEvent instanceof TouchEvent) {
                this._dragMVName = 'touchmove';
                this._dragEVName = 'touchend';
            }
            else {
                if (dragEvent.dataTransfer &&
                    dragEvent.dataTransfer.setData) {
                    dragEvent.dataTransfer.setData('text/plain', ' ');
                }
            }
            //drag event in firefox does not set clientX and clientY
            this._firefoxDragPosition = { x: 0, y: 0 };
            document.ondragover = (event) => {
                event = event || window.event;
                this._firefoxDragPosition.x = event.pageX;
                this._firefoxDragPosition.y = event.pageY;
            };
            this._dragTarget.addEventListener(this._dragMVName, this._dragMV, false);
            this._dragTarget.addEventListener(this._dragEVName, this._dragEV, false);
        }
    }
    isMouseUp() {
        return this._state === 0 /* STATE.NONE */;
    }
    _dragM(dragEvent) {
        let event = dragEvent; // cast to any since Touch and DragEvent have no common base class or interface (how its called in TS) for more details see lib.es6.d.ts --> interface Touch
        let position = null;
        let positionRelative = null;
        if (window.TouchEvent && dragEvent instanceof TouchEvent) {
            position = this._getTouchPosition(event);
            positionRelative = this._getTouchPositionRelative(event);
        }
        else {
            position = this._getMousePosition(event);
            positionRelative = this._getMousePositionRelative(event);
        }
        if (position.x > 0 && position.y > 0) {
            this._move(position, positionRelative);
        }
    }
    _dragE(dragEvent) {
        let event = dragEvent;
        document.ondragover = null;
        this._firefoxDragPosition = null;
        this._dragTarget.removeEventListener(this._dragMVName, this._dragMV);
        this._dragTarget.removeEventListener(this._dragEVName, this._dragEV);
        if (window.TouchEvent && dragEvent instanceof TouchEvent) {
            this._onUp(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */);
        }
        else {
            this._onUp(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */);
        }
    }
    addEvents(element) {
        this._events.forEach((evt) => element.addEventListener(evt, this, false));
        window === null || window === void 0 ? void 0 : window.addEventListener('scroll', this, false);
    }
    removeEvents(element) {
        this._events.forEach((evt) => element.removeEventListener(evt, this));
        window === null || window === void 0 ? void 0 : window.removeEventListener('scroll', this);
    }
    _move2(event) {
        if (this._lastTouchEvent &&
            event.timeStamp - this._lastTouchEvent.timeStamp < 16) {
            return;
        }
        const touch0 = event.touches[0];
        const touch1 = event.touches[1];
        const dx = touch0.pageX - touch1.pageX;
        const dy = touch0.pageY - touch1.pageY;
        const distance = Math.abs(dx) + Math.abs(dy);
        if (this._pinchDistance > -1) {
            if (distance > this._pinchDistance + MIN_DOLLY_DISTANCE) {
                this._setState(3 /* STATE.DOLLY */);
                this.dispatchEvent(7 /* INPUT_EVENT.ZOOM_IN */, new InputEvent(this._getTouchPosition(event), this._getTouchPositionRelative(event)));
            }
            else if (distance < this._pinchDistance - MIN_DOLLY_DISTANCE) {
                this._setState(3 /* STATE.DOLLY */);
                this.dispatchEvent(8 /* INPUT_EVENT.ZOOM_OUT */, new InputEvent(this._getTouchPosition(event), this._getTouchPositionRelative(event)));
            }
            else if (distance <= this._pinchDistance + MIN_DOLLY_DISTANCE &&
                distance >= this._pinchDistance - MIN_DOLLY_DISTANCE) {
                this._setState(5 /* STATE.PAN */);
                this.dispatchEvent(11 /* INPUT_EVENT.PAN */, new InputEvent(this._getTouchPosition(event), this._getTouchPositionRelative(event)));
            }
        }
        this._pinchDistance = distance;
        this._lastTouchEvent = event;
    }
    _setState(state) {
        this._state = state;
    }
    _move(position, positionRelative, type, event) {
        if (type === undefined) {
            type = 0 /* INPUT_EVENT_TYPE.UNKNOWN */;
        }
        if (this._dragEnabled === undefined) {
            this._dragEnabled = false;
        }
        if (this._state === 1 /* STATE.DOWN */ && this._canDrag(type)) {
            this._delta = this._getDelta(position);
            if (this._delta > MIN_MOVE_DISTANCE || this._elementHit) {
                this._setState(2 /* STATE.DRAG */);
                if (this._longClickTimer) {
                    clearTimeout(this._longClickTimer);
                }
                this.dispatchEvent(0 /* INPUT_EVENT.DRAG_START */, new InputEvent(this._downPosition, this._downPositionRelative));
            }
        }
        if (this._state === 2 /* STATE.DRAG */) {
            this.dispatchEvent(1 /* INPUT_EVENT.DRAG */, new InputEvent(position, positionRelative));
        }
        this.dispatchEvent(6 /* INPUT_EVENT.MOVE */, new InputEvent(position, positionRelative, type, null, event));
    }
    _longClick(type) {
        if (type !== 2 /* INPUT_EVENT_TYPE.TOUCH */) {
            this._setState(2 /* STATE.DRAG */);
            if (this._longClickTimer) {
                clearTimeout(this._longClickTimer);
            }
            this.dispatchEvent(0 /* INPUT_EVENT.DRAG_START */, new InputEvent(this._downPosition, this._downPositionRelative));
            this.dispatchEvent(1 /* INPUT_EVENT.DRAG */, new InputEvent(this._downPosition, this._downPositionRelative));
        }
        this.dispatchEvent(14 /* INPUT_EVENT.LONG_TOUCH */, new InputEvent(this._downPosition, this._downPositionRelative, 2 /* INPUT_EVENT_TYPE.TOUCH */));
    }
    _onUp(position, positionRelative, type) {
        this.dispatchEvent(4 /* INPUT_EVENT.UP */, new InputEvent(position, positionRelative, type));
        if (this._getDelta(position) <= MIN_MOVE_DISTANCE) {
            this.dispatchEvent(5 /* INPUT_EVENT.CLICK */, new InputEvent(position, positionRelative));
        }
        if (this._state === 2 /* STATE.DRAG */) {
            this.dispatchEvent(2 /* INPUT_EVENT.DRAG_END */, new InputEvent(position, positionRelative));
        }
        if (this._state === 4 /* STATE.ROTATE */) {
            this.dispatchEvent(10 /* INPUT_EVENT.ROTATE_END */, new InputEvent(position, positionRelative));
            this._rotationAngle = -1;
        }
        if (this._state === 3 /* STATE.DOLLY */) {
            this._pinchDistance = -1;
        }
        this._lastTouchEvent = null;
        this._setState(0 /* STATE.NONE */);
        this._dragTarget = null;
        this._elementHit = false;
        if (this._longClickTimer) {
            clearTimeout(this._longClickTimer);
        }
    }
    _getTouchPosition(event) {
        if (event.touches.length) {
            let { clientX, clientY } = event.touches[0];
            if (event.touches.length > 1) {
                const touch1 = event.touches[1];
                const clientX2 = touch1.clientX;
                const clientY2 = touch1.clientY;
                clientX = (clientX + clientX2) / 2;
                clientY = (clientY + clientY2) / 2;
            }
            return { x: clientX, y: clientY };
        }
        const changedTouches0 = event.changedTouches[0];
        return { x: changedTouches0.clientX, y: changedTouches0.clientY };
    }
    _getTouchPositionRelative(event) {
        const rect = this._getBoundingClientRect();
        const { clientWidth, clientHeight } = this._domHelper.element;
        if (event.touches.length) {
            const { clientX, clientY } = event.touches[0];
            return {
                x: ((clientX - rect.left) / clientWidth) * 2 - 1,
                y: -((clientY - rect.top) / clientHeight) * 2 + 1,
            };
        }
        const changedTouch0 = event.changedTouches[0];
        return {
            x: ((changedTouch0.clientX - rect.left) / clientWidth) * 2 - 1,
            y: -((changedTouch0.clientY - rect.top) / clientHeight) * 2 + 1,
        };
    }
    _getMousePosition(event) {
        if (event.clientX !== 0 && event.clientY !== 0) {
            return { x: event.clientX, y: event.clientY };
        }
        else {
            let { x, y } = this._getFireFoxMousePosition(event);
            return { x, y };
        }
    }
    _getFireFoxMousePosition(event) {
        let { x, y } = this._domHelper.getClientDimensions();
        return { x: x - (x + event.offsetX), y: y - (y + event.offsetY) };
    }
    _getMousePositionRelative(event) {
        const rect = this._getBoundingClientRect();
        if (event.clientX !== 0 && event.clientY !== 0) {
            return {
                x: ((event.clientX - rect.left) / this._domHelper.element.clientWidth) *
                    2 -
                    1,
                y: -((event.clientY - rect.top) / this._domHelper.element.clientHeight) *
                    2 +
                    1,
            };
        }
        else if (this._firefoxDragPosition &&
            this._firefoxDragPosition.x !== 0 &&
            this._firefoxDragPosition.y !== 0) {
            return {
                x: ((this._firefoxDragPosition.x - rect.left) /
                    this._domHelper.element.clientWidth) *
                    2 -
                    1,
                y: -((this._firefoxDragPosition.y - rect.top) /
                    this._domHelper.element.clientHeight) *
                    2 +
                    1,
            };
        }
        return { x: 0, y: 0 };
    }
    _getDelta(position) {
        //this calculation is cheaper than pythagoras
        return (Math.abs(this._downPosition.y - position.y) +
            Math.abs(this._downPosition.x - position.x));
    }
    setDragEnabled(enabled) {
        this._dragEnabled = enabled;
    }
    handleEvent(evt) {
        switch (evt.type) {
            case BROWSER_EVENTS.SCROLL:
                this._boundingClientRectInvalid = true;
                break;
            case BROWSER_EVENTS.MOUSE_MOVE:
                this._onMouseMove(evt);
                break;
            case BROWSER_EVENTS.DOUBLE_CLICK:
                this._onDoubleClick(evt);
                break;
            case BROWSER_EVENTS.MOUSE_DOWN:
                this._onMouseDown(evt);
                break;
            case BROWSER_EVENTS.MOUSE_UP:
                this._onMouseUp(evt);
                break;
            case BROWSER_EVENTS.MOUSE_LEAVE:
                this._onMouseLeave(evt);
                break;
            case BROWSER_EVENTS.MOUSE_ENTER:
                this._onMouseEnter(evt);
                break;
            case BROWSER_EVENTS.MOUSE_WHEEL:
                this._onMouseWheel(evt);
                break;
            case BROWSER_EVENTS.TOUCH_MOVE:
                this._onTouchMove(evt);
                break;
            case BROWSER_EVENTS.TOUCH_START:
                this._onTouchStart(evt);
                break;
            case BROWSER_EVENTS.TOUCH_END:
                this._onTouchEnd(evt);
                break;
            case BROWSER_EVENTS.CONTEXT_MENU:
                this._onContextMenu(evt);
                break;
        }
    }
    _onMouseDown(event) {
        event.preventDefault();
        if (event.detail === EVENT_TYPE.DOUBLE_CLICK) {
            return;
        }
        let { x, y } = this._getMousePosition(event);
        this._downPosition = { x, y };
        this._downPositionRelative = this._getMousePositionRelative(event);
        this.dispatchEvent(3 /* INPUT_EVENT.DOWN */, new InputEvent({
            x,
            y,
        }, this._downPositionRelative, 1 /* INPUT_EVENT_TYPE.MOUSE */));
        this._setState(1 /* STATE.DOWN */);
    }
    _onMouseUp(event) {
        event.preventDefault();
        if (event.detail === EVENT_TYPE.DOUBLE_CLICK) {
            return;
        }
        this._onUp(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */);
    }
    _onMouseMove(event) {
        event.preventDefault();
        this._move(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */, event);
    }
    _onDoubleClick(event) {
        event.preventDefault();
        this.dispatchEvent(12 /* INPUT_EVENT.DOUBLE_CLICK */, new InputEvent(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */));
    }
    _onMouseLeave(event) {
        var _a;
        this._delta = -1;
        if ((_a = event.relatedTarget) === null || _a === void 0 ? void 0 : _a.closest('[data-rml-sdk="ignore-mouse-leave"]')) {
            return;
        }
        this._onMouseUp(event);
    }
    _onMouseEnter(event) {
        event.preventDefault();
    }
    _onMouseWheel(event) {
        if (this._lastMouseWheelEvent &&
            event.timeStamp - this._lastMouseWheelEvent.timeStamp < 40) {
            event.preventDefault();
            event.stopPropagation();
            return;
        }
        if (event.deltaY < 0) {
            this.dispatchEvent(7 /* INPUT_EVENT.ZOOM_IN */, new InputEvent(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */, 0, event));
        }
        else {
            this.dispatchEvent(8 /* INPUT_EVENT.ZOOM_OUT */, new InputEvent(this._getMousePosition(event), this._getMousePositionRelative(event), 1 /* INPUT_EVENT_TYPE.MOUSE */, 0, event));
        }
        this._lastMouseWheelEvent = event;
    }
    _onTouchMove(event) {
        event.preventDefault();
        if (this._dragTarget) {
            return;
        }
        if (event.touches.length === 1) {
            this._move(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */);
        }
        else if (event.touches.length === 2) {
            if (this._elementHit || this._state === 4 /* STATE.ROTATE */) {
                const touch0 = event.touches[0];
                const touch1 = event.touches[1];
                let v1 = { x: touch0.pageX, y: touch0.pageY };
                let v2 = { x: touch1.pageX, y: touch1.pageY };
                const degrees = to360Degrees(getAngle(v1, v2));
                if (this._rotationAngle < 0) {
                    this._rotationAngle = degrees;
                }
                const delta = degrees - this._rotationAngle;
                this._rotationAngle = degrees;
                this.dispatchEvent(9 /* INPUT_EVENT.ROTATE */, new InputEvent(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */, toRadiant(delta)));
                this._setState(4 /* STATE.ROTATE */);
            }
            else {
                this._move2(event);
            }
        }
    }
    _onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            let { x, y } = this._getTouchPosition(event);
            this._downPosition = { x, y };
            this._downPositionRelative = this._getTouchPositionRelative(event);
            this.dispatchEvent(3 /* INPUT_EVENT.DOWN */, new InputEvent({
                x,
                y,
            }, this._downPositionRelative, 2 /* INPUT_EVENT_TYPE.TOUCH */));
            this._setState(1 /* STATE.DOWN */);
            this._longClickTimer = window.setTimeout(this._longClick.bind(this, 2 /* INPUT_EVENT_TYPE.TOUCH */), 350);
        }
        else if (event.touches.length === 2) {
            // && !this._elementHit) { @todo find another solution for rotation gesture
            //cancel drag or touch when user uses second finger
            if (this._state === 1 /* STATE.DOWN */ || this._state === 2 /* STATE.DRAG */) {
                this._onUp(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */);
            }
            this._setState(3 /* STATE.DOLLY */);
        }
    }
    _onTouchEnd(event) {
        event.preventDefault();
        if ((event.touches.length > 1 && this._state === 5 /* STATE.PAN */) ||
            this._state === 3 /* STATE.DOLLY */) {
            return;
        }
        this.dispatchEvent(13 /* INPUT_EVENT.TOUCH_END */, new InputEvent(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */));
        this._onUp(this._getTouchPosition(event), this._getTouchPositionRelative(event), 2 /* INPUT_EVENT_TYPE.TOUCH */);
    }
    _onContextMenu(event) {
        event.preventDefault();
    }
    _canDrag(_type) {
        return this._dragEnabled;
    }
    onElementHit() {
        this._elementHit = true;
    }
    _getBoundingClientRect() {
        if (this._boundingClientRectInvalid) {
            this._boundingClientRect =
                this._domHelper.element.getBoundingClientRect();
            this._boundingClientRectInvalid = false;
        }
        return this._boundingClientRect;
    }
    updateSize() {
        this._boundingClientRectInvalid = true;
    }
}
__decorate([
    inject
], InputManager.prototype, "_domHelper", void 0);

class ConfiguratorInputManager extends InputManager {
}

class SelectionHandlerEvent {
    constructor(data) {
        const { component, resetCamera, consecutive } = data;
        this.component = component;
        this.resetCamera = resetCamera === undefined ? true : resetCamera;
        this.consecutive = consecutive === undefined ? true : consecutive;
    }
}
class SelectionHandler extends EventDispatcher {
    constructor() {
        super(...arguments);
        this._selectionMode = "standard" /* SELECTION_MODE.STANDARD */;
        this._selectedComponents = new Map();
    }
    check(component) {
        if (this._selectionMode === "standard" /* SELECTION_MODE.STANDARD */) {
            this._checkStandard(component);
        }
        if (this._selectionMode === "multiselect" /* SELECTION_MODE.MULTISELECT */) {
            this._checkMulti(component);
        }
    }
    cancelSelection() {
        if (this._selectedComponents.size === 0) {
            return;
        }
        this._selectedComponents.forEach((component, roomleId) => {
            component.deselect();
            this._selectedComponents.delete(roomleId);
            this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_COMPONENT */, new SelectionHandlerEvent({ component }));
        });
    }
    _checkStandard(component) {
        let selected = this._selectedComponents.has(component.runtimeId);
        if (selected) {
            this.dispatchEvent(0 /* SELECTION_EVENT.SELECT_COMPONENT */, new SelectionHandlerEvent({
                component,
                consecutive: true,
            }));
            return;
        }
        if (this._selectedComponents.size > 0) {
            this._selectedComponents.forEach((value, roomleId) => {
                this._selectedComponents.delete(roomleId);
                this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_COMPONENT */, new SelectionHandlerEvent({
                    component: value,
                    resetCamera: false,
                }));
            });
        }
        this._selectedComponents.set(component.runtimeId, component);
        this.dispatchEvent(0 /* SELECTION_EVENT.SELECT_COMPONENT */, new SelectionHandlerEvent({
            component,
            consecutive: false,
        }));
    }
    _checkMulti(component) {
        let selected = this._selectedComponents.has(component.runtimeId);
        if (selected) {
            this._selectedComponents.delete(component.runtimeId);
            this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_COMPONENT */, new SelectionHandlerEvent({
                component,
                resetCamera: this._selectedComponents.size === 0,
            }));
            return;
        }
        else {
            this._selectedComponents.set(component.runtimeId, component);
            this.dispatchEvent(0 /* SELECTION_EVENT.SELECT_COMPONENT */, new SelectionHandlerEvent({ component }));
        }
    }
    setSelectionMode(mode) {
        this._selectionMode = mode;
    }
    getSelectionMode() {
        return this._selectionMode;
    }
    hasSelection() {
        return this._selectedComponents.size > 0;
    }
    getSelectedRuntimeComponentIds() {
        let result = [];
        this._selectedComponents.forEach((component) => result.push(component.runtimeId));
        return result;
    }
    isSelected(component) {
        return this._selectedComponents.has(component.runtimeId);
    }
}

class FontLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			const font = scope.parse( JSON.parse( text ) );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new Font( json );

	}

}

//

class Font {

	constructor( data ) {

		this.isFont = true;

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			shapes.push( ...paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

const PROMISE_CALLBACKS = new Map();
const RESOURCES = new Map();
class AsyncDependencyLoader {
    static loadFont(path) {
        if (RESOURCES.has(path)) {
            return new Promise((resolve) => {
                resolve(RESOURCES.get(path));
            });
        }
        if (PROMISE_CALLBACKS.has(path)) {
            return new Promise((resolve, reject) => {
                PROMISE_CALLBACKS.get(path).push({
                    resolve,
                    reject,
                });
            });
        }
        let loader = new FontLoader();
        return new Promise((resolve, reject) => {
            PROMISE_CALLBACKS.set(path, [{ resolve, reject }]);
            loader.load(getAssetPath() + path, (font) => {
                RESOURCES.set(path, font);
                AsyncDependencyLoader._resolveAll(path, font);
            });
        });
    }
    static _resolveAll(path, data) {
        if (PROMISE_CALLBACKS.has(path)) {
            PROMISE_CALLBACKS.get(path).forEach((callback) => callback.resolve(data));
        }
        PROMISE_CALLBACKS.delete(path);
    }
}

var RUBIK_FILE_NAME = "static/rubik_regular-bc008a7de2daee79.json";

class ComponentDimensioningHelper {
    constructor(creator) {
        this._activeComponents = [];
        this._componentDimensioningsExist = new Map();
        this._creator_ = creator;
    }
    setCamera(camera) {
        this._camera = camera;
    }
    add(component) {
        if (this._componentDimensioningsExist.has(component.runtimeId) &&
            !this._componentDimensioningsExist.get(component.runtimeId)) {
            return false;
        }
        const kernelComponent = this._plannerKernelAccess.kernelInstance.getComponent(component.runtimeId);
        const dimensionings = kernelComponent.dimensionings;
        this._componentDimensioningsExist.set(component.runtimeId, dimensionings.length > 0);
        if (!dimensionings ||
            dimensionings.length === 0 ||
            this._camera.position.z < 0) {
            return false;
        }
        const boundingBox = kernelBoxToThreeBox(kernelComponent.boxForMeasurement);
        const cameraPosition = {
            x: this._camera.position.x,
            y: this._camera.position.z,
        };
        import('./component-dimensioning-0c5cac32.js').then((componentdimensioning) => {
            // need as any because otherwise the tests go mad...
            AsyncDependencyLoader.loadFont(RUBIK_FILE_NAME).then((font) => {
                dimensionings.forEach((dimensioning) => {
                    component.add(new componentdimensioning.default(kernelDimensioningToThree(dimensioning), boundingBox, font, cameraPosition));
                });
            });
        });
        this._activeComponents.push(component);
        return true;
    }
    remove(component, remove = true) {
        return new Promise((resolve) => {
            import('./component-dimensioning-0c5cac32.js').then((componentdimensioning) => {
                let removals = [];
                component.children.forEach((child) => {
                    if (child instanceof componentdimensioning.default) {
                        removals.push(child);
                    }
                });
                removals.forEach((child) => {
                    component.remove(child);
                    dispose(child);
                });
                if (remove) {
                    removeItem(this._activeComponents, component);
                }
                resolve();
            });
        });
    }
    hasComponentDimensions() {
        return this._activeComponents.length > 0;
    }
    async reset() {
        for (const component of this._activeComponents) {
            await this.remove(component);
        }
        this._activeComponents = [];
    }
    invalidateDimensioningsCache(componentRuntimeId) {
        if (componentRuntimeId) {
            this._componentDimensioningsExist.delete(componentRuntimeId);
        }
        else {
            this._componentDimensioningsExist.clear();
        }
    }
}
__decorate([
    inject
], ComponentDimensioningHelper.prototype, "_plannerKernelAccess", void 0);

// --experimental-modules does not have support for named exports yet
const INITIAL_SNAP_DISTANCE = 50;

// --experimental-modules does not have support for named exports yet
const WALL_SIDES = {
    LEFT: 0,
    RIGHT: 1,
    MIDDLE: 2,
};

const transformMeasurement = (measurement) => {
    let transformed = {
        ...measurement,
        fromPosition3d: threeVectorToTransferableXYZ(measurement.fromPosition3d),
        toPosition3d: threeVectorToTransferableXYZ(measurement.toPosition3d),
        textPosition3d: threeVectorToTransferableXYZ(measurement.textPosition3d),
        fromPosition2d: threeVectorToTransferableXY(measurement.fromPosition2d),
        toPosition2d: threeVectorToTransferableXY(measurement.toPosition2d),
        textPosition2d: threeVectorToTransferableXY(measurement.textPosition2d),
        textDirection: threeVectorToTransferableXYZ(measurement.textDirection),
        textRotation: measurement.textRotation,
        length: measurement.length,
    };
    return transformed;
};
const calculateWallPlanPoints = (planObject, preferredSide) => {
    let from;
    let to;
    if (preferredSide.value === WALL_SIDES.LEFT) {
        from = convertToTHREE(planObject.getCornerFromLeft());
        to = convertToTHREE(planObject.getCornerToLeft());
    }
    else if (preferredSide.value === WALL_SIDES.RIGHT) {
        from = convertToTHREE(planObject.getCornerFromRight());
        to = convertToTHREE(planObject.getCornerToRight());
    }
    const middle = from.clone().add(to).divideScalar(2);
    return { from, to, middle };
};
const getConstructionElemMiddlePoints = (planObject) => {
    const leftFrom = convertToTHREE(planObject.getCornerFromLeft());
    const leftTo = convertToTHREE(planObject.getCornerToLeft());
    const rightFrom = convertToTHREE(planObject.getCornerFromRight());
    const rightTo = convertToTHREE(planObject.getCornerToRight());
    const centerFrom = leftFrom.clone().add(rightFrom).divideScalar(2);
    const centerTo = leftTo.clone().add(rightTo).divideScalar(2);
    return { centerFrom, centerTo };
};
const getTextDirectionAndRotation = (direction) => {
    const textDirection = direction.clone();
    if (direction.dot(new Vector3(1, 0, 0)) < 0) {
        textDirection.multiplyScalar(-1);
    }
    const textRotation = Math.atan2(textDirection.z, textDirection.x);
    return { textDirection, textRotation };
};
const calculateShiftingFactor = (zoomFactor) => {
    const maxZoomIn = Math.max(0.7, zoomFactor);
    const factorConfig = {
        maxZoomedIn: maxZoomIn,
        maxZoomedOut: 0.01,
        minPadding: 0.05,
        maxPadding: 0.25,
    };
    return transformRange(zoomFactor, factorConfig.maxZoomedIn, factorConfig.maxZoomedOut, factorConfig.minPadding, factorConfig.maxPadding);
};
const convertToStandardArray = (emscriptenArray) => {
    const standardArray = [];
    for (let i = 0; i < emscriptenArray.size(); i++) {
        standardArray.push(emscriptenArray.get(i));
    }
    return standardArray;
};

class Waiter {
    constructor() {
        this._promiseExecutors = [];
    }
    create() {
        return new Promise((resolve, reject) => {
            this._promiseExecutors.push({ resolve, reject });
        });
    }
    resolve(value) {
        return new Promise((resolve) => {
            this._promiseExecutors.forEach((promise) => promise.resolve(value));
            this._promiseExecutors = [];
            resolve(value);
        });
    }
    reject(reason) {
        return new Promise((_resolve, reject) => {
            this._promiseExecutors.forEach((promise) => promise.reject(reason));
            this._promiseExecutors = [];
            reject(reason);
        });
    }
}

class KernelViewModel {
    constructor(reference) {
        this._coreReference = reference.clone();
    }
    clearReference() {
        this._coreReference.delete();
        this._coreReference = null;
    }
    getKernelObject() {
        return this._coreReference;
    }
}

const WALL_SELECTION_COLOR = 0xa0a0a0;
class PlanElementViewModel extends KernelViewModel {
    constructor(planObject) {
        super(planObject);
        this._objectWaiter = new Waiter();
        this._topView = false;
        const position = convertToTHREE(planObject.getCenter());
        this._container = new Object3D();
        this._container.position.copy(position);
        this._boundingBox = this._generateBoundingBox();
        fadeIn(this._boundingBox);
        this._container.add(this._boundingBox);
        if (this.getPlanElement().getType().value !== 2 /* PlanElementType.OBJECT */) {
            this._object = new Object3D();
            this._container.add(this._object);
        }
    }
    getSize() {
        if (this._object) {
            return new Box3().setFromObject(this._object).getSize(new Vector3());
        }
        return new Vector3();
    }
    update() {
        this._container.position.copy(convertToTHREE(this.getPlanElement().getMeshCenter()));
        if (this._boundingBox) {
            this._updateBoundingBox();
        }
    }
    _updateBoundingBox() {
        const size = this.getSize();
        this._boundingBox.geometry = new BoxGeometry(size.x, size.y, size.z);
        this._boundingBox.position.y = size.y / 2;
    }
    getPosition() {
        return this._container.position;
    }
    getRotation() {
        return this._container.rotation.y;
    }
    getBounds() {
        let box;
        if (this.getPlanElement().boxForMeasurement) {
            box = kernelBoxToThreeBox(this.getPlanElement().boxForMeasurement);
            box.applyMatrix4(this.getContainer().matrix);
        }
        else {
            box = new Box3();
            box.setFromObject(this._container);
        }
        return box;
    }
    getBoundingBox() {
        return this._boundingBox;
    }
    getPlanElement() {
        return this._coreReference;
    }
    setObject(object) {
        this._object = object;
        this._objectWaiter.resolve(object);
    }
    getObject() {
        return this._object;
    }
    async getObjectAsync() {
        if (this._object) {
            return Promise.resolve(this._object);
        }
        return this._objectWaiter.create();
    }
    addMesh(mesh) {
        this._object.add(mesh);
        this.hidePreviewBox();
    }
    getMesh(material) {
        if (!this._object || this._object.children.length === 0) {
            return null;
        }
        const materialId = getMaterialId(material, this.getPlanElement().getType());
        return this._object.children.find((mesh) => mesh.userData.material === materialId);
    }
    getContainer() {
        return this._container;
    }
    getId() {
        return this.getPlanElement().getId();
    }
    clear() {
        dispose(this._container);
        if (this._selectionMesh) {
            dispose(this._selectionMesh);
        }
    }
    remove() {
        var _a;
        (_a = this._container.parent) === null || _a === void 0 ? void 0 : _a.remove(this._container);
        this.clear();
    }
    hidePreviewBox() {
        if (this._container && this._boundingBox) {
            this._boundingBox.material = getBoundingBoxMaterial();
        }
    }
    _generateBoundingBox() {
        const size = this.getSize();
        const geometry = new BoxGeometry(size.x, size.y, size.z);
        let boxColor = new Color$1(PREVIEW_MATERIAL_COLOR);
        const color = this.getPlanElement().customColor;
        if (color > 0) {
            boxColor = getColorFromInt(color);
        }
        let material = MaterialCreator.createMeshStandardMaterial({
            color: boxColor,
            opacity: PREVIEW_MATERIAL_OPACITY,
            transparent: true,
        });
        let mesh = new Mesh(geometry, material);
        mesh.name = 'bounding box';
        mesh.position.y = size.y / 2;
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.layers.set(6 /* LAYER.UI */);
        return mesh;
    }
    select() {
        this._isSelected = true;
        if (this._selectionMesh) {
            this._container.add(this._selectionMesh);
        }
    }
    deselect() {
        this._isSelected = false;
        if (this._selectionMesh) {
            this._container.remove(this._selectionMesh);
        }
    }
    hoverOn() {
        // override by subclass if needed
    }
    hoverOff() {
        // override by subclass if needed
    }
    setTopView(enabled) {
        this._topView = enabled;
    }
}

const objectToWallDimensionToTransferable = (objectWallDimension) => {
    const transformedCommon = transformMeasurement(objectWallDimension);
    return {
        ...transformedCommon,
    };
};
class PlanObjectViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        this._initDone = false;
        this._initFailed = null;
        this._initWaiter = new Waiter();
        this._container.rotation.y = planObject.rotation;
    }
    finishInit() {
        this._initDone = true;
        this._initFailed = null;
        return this._initWaiter.resolve();
    }
    failInit(error) {
        this._initFailed = error;
        this._initDone = false;
        return this._initWaiter.reject(this._initFailed);
    }
    isInitDone() {
        if (this._initDone) {
            return Promise.resolve();
        }
        if (this._initFailed) {
            return Promise.reject(this._initFailed);
        }
        return this._initWaiter.create();
    }
    getPlanObject() {
        return this.getPlanElement();
    }
    getSize() {
        return convertToThreeDimensions(this.getPlanObject().size);
    }
    getObjectMeasurements(zoomFactor) {
        const planObject = this.getPlanObject();
        const rectangle = planObject.getRectangle();
        const { referencePoints, size, center } = rectangle;
        if (!referencePoints) {
            return null;
        }
        const calculateDimension = (fromPoint, toPoint, applyPadding = false, lengthOverride = 0) => {
            const startPoint = convertToTHREE(fromPoint);
            const endPoint = convertToTHREE(toPoint);
            let textMiddle = startPoint.clone().add(endPoint).divideScalar(2);
            const objectDirection = startPoint.clone().sub(endPoint);
            const { textDirection, textRotation } = getTextDirectionAndRotation(objectDirection);
            if (applyPadding) {
                const normalVector = objectDirection
                    .clone()
                    .cross(new Vector3(0, 1, 0))
                    .normalize();
                const middleRelativeToCenter = textMiddle
                    .clone()
                    .sub(convertToTHREE(center));
                if (normalVector.dot(middleRelativeToCenter) < 0) {
                    normalVector.multiplyScalar(-1);
                }
                const shiftingFactor = calculateShiftingFactor(zoomFactor);
                const paddingDirection = normalVector.multiplyScalar(shiftingFactor);
                textMiddle.add(paddingDirection);
            }
            return {
                fromPosition3d: startPoint,
                toPosition3d: endPoint,
                textPosition3d: textMiddle,
                textDirection,
                textRotation,
                length: lengthOverride,
            };
        };
        const rectMeasurements = [
            { from: referencePoints.topLeft, to: referencePoints.topRight },
            { from: referencePoints.topRight, to: referencePoints.bottomRight },
            { from: referencePoints.bottomRight, to: referencePoints.bottomLeft },
            { from: referencePoints.bottomLeft, to: referencePoints.topLeft },
        ].map((edge) => calculateDimension(edge.from, edge.to));
        const objectMeasurements = [
            {
                from: referencePoints.topLeft,
                to: referencePoints.topRight,
                length: size.x,
            },
            {
                from: referencePoints.topRight,
                to: referencePoints.bottomRight,
                length: size.y,
            },
        ].map((edge) => {
            const dimension = calculateDimension(edge.from, edge.to, true);
            dimension.length = edge.length;
            return dimension;
        });
        const wallDistances = convertToStandardArray(planObject.getWallDistances());
        const objectToWallsMeasurements = wallDistances
            ? wallDistances.map((line) => calculateDimension(line.startPoint, line.endPoint, false, line.length))
            : null;
        return { rectMeasurements, objectMeasurements, objectToWallsMeasurements };
    }
    update() {
        super.update();
        this._container.rotation.y = this.getPlanObject().rotation;
    }
}

const ERROR = 'Construction of configuration failed';
class ConfiguratorPlanObjectViewModel extends PlanObjectViewModel {
    constructor(planObject) {
        super(planObject);
        this._container.name = 'Configurable ' + this._container.name;
    }
    addRootComponent(component) {
        this.setObject(component);
        this._rootComponentId = component.id;
        this._rootComponentRuntimeId = component.runtimeId;
        this._container.add(this.getObject());
    }
    getConfigurationRuntimeId() {
        return this.getPlanObject().getConfigurationRuntimeId();
    }
    getRootComponentId() {
        return this._rootComponentId;
    }
    getRootComponentRuntimeId() {
        return this._rootComponentRuntimeId;
    }
    finishConstruction() {
        return this.finishInit();
    }
    failConstruction() {
        return this.failInit(new Error(ERROR));
    }
}

var isProduction = true;
var isUnitTesting = false;
var environment = "development";
var detailEnvironment = "development";
var features = {
};
var APP$1 = {
	RAPI: {
		server: "/api/v2",
		localReverseProxy: "https://www.roomle.com/api/v2",
		liveServer: "https://www.roomle.com/api/v2",
		testServer: "https://www.test.roomle.com/api/v2",
		headers: {
			apiKey: "roomle_portal_v2",
			currentTenant: 9,
			locale: "en",
			language: "en",
			device: 1,
			token: "anonymous",
			platform: "web"
		},
		itemHeaders: {
			assetRevision: "glb",
			assetFileFormat: "glb"
		}
	},
	SHORTENER_URL: "http://rml.co/"
};
var environments = {
	PRODUCTION: "production",
	DEVELOPMENT: "development",
	TEST: "test",
	TEST_SERVER: "test_server",
	ALPHA: "alpha"
};
var defaultSettings = {
	isProduction: isProduction,
	isUnitTesting: isUnitTesting,
	environment: environment,
	detailEnvironment: detailEnvironment,
	features: features,
	APP: APP$1,
	environments: environments
};

// Remarks for settings.json
let settings = JSON.parse(JSON.stringify(defaultSettings));
// @ts-ignore -- the "false" is replaced during build with true/false
settings.isUnitTesting = 'false' === 'true'; // eslint-disable-line
const isNode = typeof module !== 'undefined' && module.exports; // eslint-disable-line
if (!isNode) {
    window.IS_DEBUG = true;
}
const getDebugConfig = function (forceDebug = false) {
    const isDebug = !isNode && window.IS_DEBUG;
    if (isDebug || forceDebug) {
        let debugConfig = JSON.parse(JSON.stringify(settings));
        const debugAppConfig = {
            ...debugConfig.APP,
            SHORTENER_URL: 'http://localhost:4747/?isItem=false&id=',
        };
        const debugFeaturesConfig = { ...debugConfig.features };
        return {
            ...debugConfig,
            isProduction: false,
            APP: debugAppConfig,
            features: debugFeaturesConfig,
        };
    }
};
const getProductionConfig = function () {
    // JSON.parse JSON.stringify needed because otherwise rollup strips away getProductionConfig completely which breaks the build
    // I think it's a bug from rollup but I didn't figure out why rollup think it's save to remove this statement
    return JSON.parse(JSON.stringify(settings));
};

const configs = {
    ENV_DEBUG: getDebugConfig(),
    ENV_PRODUCTION: getProductionConfig(), // eslint-disable-line
};
// @ts-ignore -- will be replaced during built time
var Env = configs['ENV_DEBUG']; // eslint-disable-line

class StaticPlanObjectViewModel extends PlanObjectViewModel {
    constructor(planObject) {
        super(planObject);
        this._originalSize = new Vector3();
        this._container.name = 'Static ' + this._container.name;
    }
    setRapiItem(rapiItem) {
        if (this._rapiItem) {
            return Promise.resolve();
        }
        return this._addStaticItem(rapiItem);
    }
    async _addStaticItem(rapiItem) {
        this._rapiItem = rapiItem;
        let planObject = this.getPlanObject();
        this._glbUrl = getGlbUrl(rapiItem);
        if (!this._glbUrl) {
            return Promise.reject('No glb url found');
        }
        let size = rapiItem.scaleable
            ? convertToThreeDimensions(planObject.size)
            : undefined;
        let scale = new Vector3(1, 1, 1);
        if (planObject.flipX) {
            scale.x *= -1;
        }
        if (planObject.flipY) {
            scale.z *= -1;
        }
        try {
            const object = await this._staticItemLoader.loadGLB(this._glbUrl, undefined, undefined, size, scale, planObject.customColor, rapiItem.colorable);
            this._originalSize.copy(object.boundingBox.getSize(new Vector3()));
            object.scene.name = rapiItem.label;
            this.setObject(object.scene);
            checkGLB(object.scene, this._glbUrl);
            fadeIn(object.scene);
            this._container.add(this.getObject());
            this.hidePreviewBox();
            await this.finishInit();
        }
        catch (error) {
            await this.failInit(error);
        }
    }
    getRapiItem() {
        return this._rapiItem;
    }
    needsRapiItem() {
        return !this._glbUrl;
    }
    getGLBUrl() {
        return this._glbUrl;
    }
    update() {
        const size = convertToThreeDimensions(this.getPlanElement().size);
        const object = this.getObject();
        if (!object) {
            return;
        }
        if (size) {
            const { x, y, z } = this._originalSize;
            let calculatedScale = new Vector3(size.x / x, size.y / y, size.z / z);
            object.scale.copy(calculatedScale);
        }
        if (this.getPlanElement().flipX) {
            object.scale.x *= -1;
        }
        if (this.getPlanElement().flipY) {
            object.scale.z *= -1;
        }
        const customColor = this.getPlanElement().customColor;
        object.traverse((node) => {
            if (node instanceof Mesh) {
                if (node.material instanceof MeshStandardMaterial) {
                    const material = node.material;
                    if (this._rapiItem.colorable && customColor && customColor > 0) {
                        let materialColor = new Color$1(customColor);
                        material.color = materialColor.copySRGBToLinear(materialColor);
                    }
                    material.needsUpdate = true;
                }
            }
        });
        super.update();
    }
}
__decorate([
    inject
], StaticPlanObjectViewModel.prototype, "_staticItemLoader", void 0);

const wallDimensionToTransferable = (wallDimension) => {
    const transformedCommon = transformMeasurement(wallDimension);
    return {
        ...transformedCommon,
        id: wallDimension.id,
        fromWithoutPadding: threeVectorToTransferableXYZ(wallDimension.fromWithoutPadding),
        toWithoutPadding: threeVectorToTransferableXYZ(wallDimension.toWithoutPadding),
        lengthFormatted: wallDimension.lengthFormatted,
    };
};
let WALL_TOP_VIEW_MATERIAL;
const getTopViewMaterial = () => {
    if (!WALL_TOP_VIEW_MATERIAL) {
        WALL_TOP_VIEW_MATERIAL = MaterialCreator.createMeshPhysicalMaterial({
            color: 0x000000,
        });
    }
    return WALL_TOP_VIEW_MATERIAL;
};
class WallPlanElementViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        this._container.name = 'Wall Plan Element';
    }
    get isSelected() {
        return this._isSelected;
    }
    getWallDimension(zoomFactor) {
        const planElement = this.getPlanElement();
        const center = convertToTHREE(planElement.getCenter());
        const preferredSide = planElement.getPreferredSide();
        const { from, to, middle } = calculateWallPlanPoints(planElement, preferredSide);
        const wallDirection = from.clone().sub(to);
        const normalVectorOfWall = wallDirection
            .clone()
            .cross(new Vector3(0, 1, 0))
            .normalize();
        if (normalVectorOfWall.clone().dot(middle.clone().sub(center)) < 0) {
            normalVectorOfWall.multiplyScalar(-1);
        }
        const shiftingFactor = calculateShiftingFactor(zoomFactor);
        const { textDirection, textRotation } = getTextDirectionAndRotation(wallDirection);
        const movePointsToSurfaceFactor = normalVectorOfWall
            .clone()
            .multiplyScalar(shiftingFactor / 2);
        const fromWithoutPadding = from.clone().add(movePointsToSurfaceFactor);
        const toWithoutPadding = to.clone().add(movePointsToSurfaceFactor);
        const paddingDirection = normalVectorOfWall.multiplyScalar(shiftingFactor);
        const fromWithPadding = from.add(paddingDirection);
        const toWithPadding = to.add(paddingDirection);
        const textMiddle = fromWithPadding
            .clone()
            .add(toWithPadding)
            .divideScalar(2);
        const wallDimension = {
            id: planElement.getId(),
            fromPosition3d: fromWithPadding,
            toPosition3d: toWithPadding,
            textPosition3d: textMiddle,
            textDirection,
            textRotation,
            length: planElement.getLength(preferredSide),
            fromWithoutPadding,
            toWithoutPadding,
        };
        return wallDimension;
    }
    addMesh(mesh) {
        mesh.traverse((obj) => {
            this._setMaterial(obj);
        });
        mesh.layers.set(9 /* LAYER.CONSTRUCTION */);
        super.addMesh(mesh);
        const size = new Box3()
            .setFromObject(this.getObject())
            .getSize(new Vector3());
        this._boundingBox.geometry = new BoxGeometry(size.x, size.y, size.z);
        this._boundingBox.position.y = size.y / 2;
    }
    show() {
        var _a, _b;
        this.getContainer().visible = true;
        (_a = this.getObject()) === null || _a === void 0 ? void 0 : _a.traverse((mesh) => {
            mesh.layers.set(9 /* LAYER.CONSTRUCTION */);
        });
        (_b = this.getBoundingBox()) === null || _b === void 0 ? void 0 : _b.layers.set(6 /* LAYER.UI */);
    }
    hide() {
        var _a, _b;
        this.getContainer().visible = false;
        (_a = this.getObject()) === null || _a === void 0 ? void 0 : _a.traverse((mesh) => {
            mesh.layers.disableAll();
        });
        (_b = this.getBoundingBox()) === null || _b === void 0 ? void 0 : _b.layers.disableAll();
    }
    _enableTopView() {
        this._container.traverse((obj) => {
            this._setTopMaterial(obj);
        });
    }
    _setTopMaterial(obj) {
        if (obj instanceof Mesh &&
            !obj.userData.originalMaterial &&
            obj.material &&
            obj !== this._boundingBox) {
            obj.userData.originalMaterial = obj.material;
            obj.material = getTopViewMaterial();
        }
    }
    _disableTopView() {
        this._container.traverse((obj) => {
            if (obj instanceof Mesh && obj.userData.originalMaterial) {
                obj.material = obj.userData.originalMaterial;
                delete obj.userData.originalMaterial;
            }
        });
    }
    setTopView(enabled) {
        super.setTopView(enabled);
        if (enabled) {
            this._enableTopView();
        }
        else {
            this._disableTopView();
        }
    }
    getKernelObject() {
        return super.getKernelObject();
    }
    _setMaterial(obj) {
        if (obj instanceof Mesh && obj.material && obj !== this._boundingBox) {
            if (!obj.userData.originalMaterial) {
                obj.userData.originalMaterial = obj.material;
            }
            if (this._topView && this._isSelected) {
                obj.material = new MeshBasicMaterial({
                    color: WALL_SELECTION_COLOR,
                    side: DoubleSide,
                });
            }
            else if (this._topView && !this._isSelected) {
                obj.material = getTopViewMaterial();
            }
            else {
                obj.material = obj.userData.originalMaterial;
                delete obj.userData.originalMaterial;
            }
        }
    }
    select() {
        super.select();
        this._container.traverse((obj) => {
            this._setMaterial(obj);
        });
    }
    deselect() {
        super.deselect();
        this._container.traverse((obj) => {
            this._setMaterial(obj);
        });
    }
}

class FloorPlanElementViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        this._container.name = 'Floor Plan Element';
    }
    addMesh(mesh) {
        // this is a quick fix to remove all meshes when we add a new material
        // it should be properly fixed for all plan elements
        // see addMesh in plan-view-model
        this.getObject().clear();
        super.addMesh(mesh);
        mesh.layers.set(9 /* LAYER.CONSTRUCTION */);
        mesh.castShadow = false;
        // fix to not use this mesh for baked floor shadow calculation
        mesh.position.y = -0.001;
    }
}

class CeilingPlanElementViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        this._container.name = 'Ceiling Plan Element';
    }
    addMesh(mesh) {
        super.addMesh(mesh);
        mesh.castShadow = false;
        const size = new Box3()
            .setFromObject(this.getObject())
            .getSize(new Vector3());
        this._boundingBox.geometry = new BoxGeometry(size.x, 0.01, size.z);
    }
}

const START_SUFFIX = '_start';
const META_INFO = new Map();
class Benchmark {
    // DONT CALL IT PERFORMANCE BECAUSE OF NAME CLASH WITH GLOBAL OBJECT ON WINDOW
    static start(name) {
        if (!window.performance || !window.performance.getEntriesByName) {
            // otherwise iphone 5C crashes!
            return '';
        }
        let marks = window.performance.getEntriesByName(name).length++;
        let prefix = '';
        if (marks < 100) {
            prefix = '0';
        }
        if (marks < 10) {
            prefix = '0' + prefix;
        }
        const concreteMark = marks > 0 ? name + '_' + prefix + marks : name;
        const concreteMarkStart = concreteMark + START_SUFFIX;
        window.performance.mark(concreteMarkStart);
        return concreteMark;
    }
    static addMeta(name, data) {
        const meta = Benchmark.getMeta(name);
        META_INFO.set(name, Object.assign(meta, data));
    }
    static getMeta(name) {
        let meta = META_INFO.get(name);
        if (!meta) {
            return {};
        }
        return meta;
    }
    static end(_name) {
        // @todo check this;
        // dirty quick fix to prevent HSC from crashing when loaded in HSP
        return;
        // if (!window.performance || !window.performance.getEntriesByName) {
        //     // nothing started!
        //     return;
        // }
        // if (!window.performance.mark || !window.performance.measure) {
        //     // can not measure
        //     return;
        // }
        // window.performance.mark(name + END_SUFFIX);
        // window.performance.measure(name, name + START_SUFFIX, name + END_SUFFIX);
    }
    static getMeasure(_name) {
        // @todo check this;
        // dirty quick fix to prevent HSC from crashing when loaded in HSP
        return [];
        // if (!window.performance) {
        //     return [];
        // }
        // if (!window.performance.getEntriesByName) {
        //     return [];
        // }
        // return window.performance.getEntriesByName(name);
    }
    static showBenchmarks(filter) {
        const items = window.performance.getEntriesByType('measure');
        items.sort(function (a, b) {
            return a.startTime - b.startTime;
        });
        const rows = [];
        for (let i = 0, length = items.length; i < length; i++) {
            const measure = items[i];
            if (filter && measure.name.indexOf(filter) === -1) {
                continue;
            }
            rows.push({
                Start: parseFloat(measure.startTime.toFixed(2)),
                Name: measure.name,
                Duration: parseFloat(measure.duration.toFixed(2)),
            });
        }
        console.table(rows);
    }
}

// @todo planner and configurator need their own context object
//       otherwise properties are mixed together
class AppContext {
    static init(appState = {}) {
        const { kernelInstance, kernelContainer, planObjectId } = appState;
        AppContext.kernelInstance = kernelInstance;
        AppContext.kernelContainer = kernelContainer;
        AppContext.planObjectId = planObjectId;
    }
    static cleanUp() {
        AppContext.useHDGeometry = false;
        AppContext.kernelInstance = null; // @todo create correct typings here
        AppContext.kernelContainer = null; // @todo create correct typings here
        AppContext.planObjectId = null;
    }
}
AppContext.useHDGeometry = false;
AppContext.kernelInstance = null; // @todo create correct typings here
AppContext.kernelContainer = null; // @todo create correct typings here
AppContext.planObjectId = null;

const WAITERS = new Map();
const _endOperation = function (operationType, success, data) {
    let resolves = WAITERS.get(operationType);
    if (resolves) {
        const args = data ? [data] : undefined;
        resolves.forEach(({ resolve, reject }) => success ? resolve.apply(resolve, args) : reject.apply(reject, args));
        WAITERS.delete(operationType);
    }
};
class AsyncHelper {
    static finishOperation(operationType, data) {
        _endOperation(operationType, true, data);
    }
    static failOperation(operationType, data) {
        _endOperation(operationType, false, data);
    }
    static waitFor(operationType, startCommand) {
        return new Promise((resolve, reject) => {
            let waiters = WAITERS.get(operationType);
            if (!waiters) {
                WAITERS.set(operationType, []);
                waiters = WAITERS.get(operationType);
            }
            waiters.push({ resolve, reject });
            if (typeof startCommand === 'function') {
                startCommand.apply(startCommand);
            }
        });
    }
}

// Structured Cloning is removed from browsers
// so we remove it also from our code
// see: https://developer.mozilla.org/en-US/docs/WebAssembly/Caching_modules
//      https://bugzilla.mozilla.org/show_bug.cgi?id=1469395
//      https://github.com/WebAssembly/spec/issues/821
const loadWebAssemblyFromFile = (wasmUrl, importObject, receiveInstanceCallback) => {
    const isInstantiateStreamingSupported = typeof WebAssembly.instantiateStreaming === 'function';
    Benchmark.addMeta("kernel_is_ready" /* MARKS.KERNEL_IS_READY */, { cachedInIndexedDB: false });
    let instantiatePromise = null;
    if (isInstantiateStreamingSupported) {
        // Streaming supported
        Benchmark.start("kernel_stream_compile" /* MARKS.KERNEL_STREAM_COMPILE_INSTANCE */);
        instantiatePromise = WebAssembly.instantiateStreaming(fetch(getAssetPath() + wasmUrl), importObject);
    }
    else {
        Benchmark.start("kernel_legacy_compile" /* MARKS.KERNEL_LEGACY_COMPILE_INSTANCE */);
        instantiatePromise = fetch(getAssetPath() + wasmUrl)
            .then((response) => response.arrayBuffer())
            .then((buffer) => WebAssembly.instantiate(buffer, importObject));
    }
    Benchmark.addMeta("kernel_is_ready" /* MARKS.KERNEL_IS_READY */, {
        instantiateStreaming: isInstantiateStreamingSupported,
    });
    instantiatePromise.then((results) => {
        receiveInstanceCallback(results.instance);
    }, (instantiateError) => console.error(instantiateError));
};

var CONFIGURATOR_WASM_FILE_NAME = "static/ConfiguratorKernel-87be41eb6f0ad18a.wasm";

var CONFIGURATOR_LOADER_FILE_NAME = "static/ConfiguratorKernel-c7987e6b1d0cf6fa.js";

var PLANNER_WASM_FILE_NAME = "static/RoomleCore-89efbc98841d6388.wasm";

var PLANNER_LOADER_FILE_NAME = "static/RoomleCore-ef159334dece54a5.js";

var CONFIGURATOR_MEM_FILE_NAME = "static/ConfiguratorKernelJs-40410094345ec9a8.mem";

var CONFIGURATOR_ASM_LOADER_FILE_NAME = "static/ConfiguratorKernelJs-e76a418dfbcc3d0e.js";

var PLANNER_MEM_FILE_NAME = "static/RoomleCoreJs-08add358730b3dc2.mem";

var PLANNER_ASM_LOADER_FILE_NAME = "static/RoomleCoreJs-6971f172c6a0b1bf.js";

var TOOLS_CORE_WASM_FILE_NAME = "static/RoomleToolsCore-ab6117f5b5c79d91.wasm";

var TOOLS_CORE_LOADER_FILE_NAME = "static/RoomleToolsCore-3a5c996bc6ecdfbc.js";

var CONFIGURATOR_WASM_MODERN_FILE_NAME = "static/ConfiguratorKernel-9c94096c94aa494b.wasm";

var CONFIGURATOR_LOADER_MODERN_FILE_NAME = "static/ConfiguratorKernel-c6f61cc7a2f4811e.js";

var PLANNER_WASM_MODERN_FILE_NAME = "static/RoomleCore-556b1ddba48f6a88.wasm";

var PLANNER_LOADER_MODERN_FILE_NAME = "static/RoomleCore-4c0522dd4d2993c9.js";

const isRange = function (parameter) {
    return parameter.validRange && typeof parameter.validRange.type === 'string';
};
const isOptions = function (parameter) {
    return parameter.validValues && parameter.validValues.length > 0;
};
const hasUnits = function (parameter) {
    return (parameter.unitType === "length" /* PARAMETER_UNIT_TYPES.LENGTH */ ||
        parameter.unitType === "area" /* PARAMETER_UNIT_TYPES.AREA */);
};
const isThumbnail = function (parameter) {
    if (!isOptions(parameter)) {
        return false;
    }
    return (Array.isArray(parameter.validValues) &&
        parameter.validValues.length > 0 &&
        typeof parameter.validValues[0].thumbnail === 'string');
};
const isBoolean = function (parameter) {
    return parameter.type === "Boolean" /* PARAMETER_KERNEL_TYPE.BOOLTYPE */;
};
const isMaterial = function (parameter) {
    return parameter.type === "Material" /* PARAMETER_KERNEL_TYPE.MATERIAL */;
};

// for more details see: https://github.com/GoogleChromeLabs/wasm-feature-detect
// for now just use this without the whole package, for more details see:
// https://roomle.atlassian.net/browse/RML-8824?atlOrigin=eyJpIjoiMDdhOGIyZDNmNjZlNGRkY2I5NzgzNjE0Mzc5ZTZlYzEiLCJwIjoiaiJ9
const wasmExceptionsSupported = () => WebAssembly.validate(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6,
    0, 6, 64, 25, 11, 11,
]));

let MEM_URL;
let WASM_URL;
let WASM_LOADER;
let ASM_LOADER;
let CACHE_COMPILATION;
const KERNEL_PATHS = {
    WASM: {
        CONFIGURATOR: {
            URL: CONFIGURATOR_WASM_FILE_NAME,
            LOADER: CONFIGURATOR_LOADER_FILE_NAME,
        },
        PLANNER: {
            URL: PLANNER_WASM_FILE_NAME,
            LOADER: PLANNER_LOADER_FILE_NAME,
        },
    },
    WASM_MODERN: {
        CONFIGURATOR: {
            URL: CONFIGURATOR_WASM_MODERN_FILE_NAME,
            LOADER: CONFIGURATOR_LOADER_MODERN_FILE_NAME,
        },
        PLANNER: {
            URL: PLANNER_WASM_MODERN_FILE_NAME,
            LOADER: PLANNER_LOADER_MODERN_FILE_NAME,
        },
    },
    ASM: {
        CONFIGURATOR: {
            MEM_URL: CONFIGURATOR_MEM_FILE_NAME,
            LOADER: CONFIGURATOR_ASM_LOADER_FILE_NAME,
        },
        PLANNER: {
            MEM_URL: PLANNER_MEM_FILE_NAME,
            LOADER: PLANNER_ASM_LOADER_FILE_NAME,
        },
    },
};
const USE_WASM = !!window.WebAssembly;
const USE_DELTA_COMPONENT_UPDATES = true;
class CommonKernelAccess {
    _utilityToLongArray(longArray) {
        const newArray = new this._kernelContainer.LongArray();
        longArray.forEach((value) => newArray.push_back(value));
        return newArray;
    }
    constructor(creator) {
        this._requestedItemIds = [];
        this._requestedMaterialIds = [];
        this._configuratorKernelCallbackListener = new Set();
        this._cachedGroupIds = [];
        this._waitingForGroups = false;
        this._subComponentsWaiters = new Map();
        this._shouldWait = true;
        this._creator_ = creator;
        window.KernelCallback = {
            isReady: this.isReady.bind(this),
        };
        this._lifeCycleManager.addEventListener(this);
    }
    init(kernelType) {
        this._kernelType = kernelType;
        this._setupKernelPaths(kernelType);
        this._setupEmsModule(kernelType);
        this._useWASM = USE_WASM;
        this._kernelPath = USE_WASM ? WASM_LOADER : ASM_LOADER;
    }
    _initKernel() {
        const { restrictionLevel } = this._initData;
        const callbacksOnlyIfGeometryIsReady = this._initData.callbacksOnlyIfGeometryIsReady !== false ? true : false;
        this._kernelInstance.setUpdateCallbacksOnlyIfGeometryIsReady(callbacksOnlyIfGeometryIsReady);
        this._kernelInstance.setLevel(restrictionLevel);
        this._unitFormatter.init(this._kernelContainer);
        this._kernelInstance.setEnvironmentVariable('unit', this._unitFormatter._actualUnitString || 'cm');
        this._kernelInstance.setEnvironmentVariable('unitString', 'short');
        this._kernelInstance.useEnvironmentGeometry(this._kernelType === 1 /* KERNEL_TYPE.CONFIGURATOR */);
        const { overrideCountry, locale } = this._globalInitData;
        if (overrideCountry) {
            this._kernelInstance.resetPriceListIds();
            this._kernelInstance.addPriceList(overrideCountry);
        }
        this._kernelInstance.setEnvironmentVariable('language', locale);
    }
    get kernelContainer() {
        return this._kernelContainer;
    }
    get kernelInstance() {
        return this._kernelInstance;
    }
    get configurationExporter() {
        if (!this._configurationExporter) {
            this._configurationExporter =
                this._kernelContainer.newConfigurationExporter();
        }
        return this._configurationExporter;
    }
    _setupKernelPaths(kernelType) {
        const KERNEL_TYPE_STRING = kernelType === 0 /* KERNEL_TYPE.PLANNER */ ? 'PLANNER' : 'CONFIGURATOR';
        MEM_URL = KERNEL_PATHS.ASM[KERNEL_TYPE_STRING].MEM_URL;
        ASM_LOADER = KERNEL_PATHS.ASM[KERNEL_TYPE_STRING].LOADER;
        if (wasmExceptionsSupported()) {
            WASM_URL = KERNEL_PATHS.WASM_MODERN[KERNEL_TYPE_STRING].URL;
            WASM_LOADER = KERNEL_PATHS.WASM_MODERN[KERNEL_TYPE_STRING].LOADER;
        }
        else {
            WASM_URL = KERNEL_PATHS.WASM[KERNEL_TYPE_STRING].URL;
            WASM_LOADER = KERNEL_PATHS.WASM[KERNEL_TYPE_STRING].LOADER;
        }
        CACHE_COMPILATION = true;
    }
    _setupEmsModule(kernelType) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this._kernelContainer = {
            locateFile(filename) {
                const regex = kernelType === 0 /* KERNEL_TYPE.PLANNER */
                    ? /RoomleCoreJs[\-a-z0-9]*\.js\.mem/
                    : /ConfiguratorKernelJs[\-a-z0-9]*\.js\.mem/;
                if (filename.match(regex)) {
                    // NEED TO TRICK FINGERPRINTING
                    return getAssetPath() + MEM_URL;
                }
                return filename;
            },
            wasmBinaryFile: getAssetPath() + WASM_URL,
            preRun: [],
            postRun: [],
            setStatus: null,
            print(msg) {
                self._kernelIo.log(msg);
            },
            printErr(err) {
                self._kernelIo.error(err);
            },
            quit(errorCode) {
                if (errorCode === 0) {
                    return;
                }
                self._kernelIo.throw(errorCode && errorCode.toString
                    ? errorCode.toString()
                    : 'Unknown error while C/C++ main executes');
            },
        };
        if (CACHE_COMPILATION && USE_WASM) {
            this._kernelContainer.instantiateWasm = function (importObject, receiveInstanceCallback) {
                loadWebAssemblyFromFile(WASM_URL, importObject, receiveInstanceCallback);
                return {};
            };
        }
    }
    _passSubComponentsToKernel(componentDefinition, map) {
        const componentId = componentDefinition.id;
        const waiters = map.get(componentId);
        if (waiters) {
            for (let i = 0, length = waiters.length; i < length; i++) {
                const { parentId, partId } = waiters[i];
                this._kernelIo.setMeta({ componentId });
                this._kernelInstance.loadedSubComponent(parentId, partId, componentId, componentDefinition.configuration);
            }
        }
    }
    _fetchSubComponents(waiters) {
        let keys = [...waiters.keys()];
        if (!keys.length) {
            return;
        }
        this._rapiAccess
            .getComponents(keys)
            .then((componentDefinitions) => {
            for (let i = 0, length = componentDefinitions.length; i < length; i++) {
                this._passSubComponentsToKernel(componentDefinitions[i], waiters);
            }
            this._flushSubComponentsWaiters();
        });
    }
    _flushSubComponentsWaiters() {
        this._fetchSubComponents(this._subComponentsWaiters);
        this._subComponentsWaiters = new Map();
        this._shouldWait = false;
    }
    isReady() {
        this._kernelContainer.setExternalHelpers(this._kernelIo, {
            convertCObject,
        });
        if (!Env.isProduction && !Env.isUnitTesting) {
            this.addDebugInfo();
        }
        if (window.KernelCallback) {
            // could be called in HSP when open HSC then this is already deleted
            window.KernelCallback = null;
            delete window.KernelCallback;
        }
    }
    addDebugInfo() {
        const getAllProperties = function (instance, props = []) {
            const prototype = Object.getPrototypeOf(instance);
            const prototypeProperties = prototype
                ? Object.getOwnPropertyNames(prototype)
                : [];
            const ownProperties = instance
                ? Object.getOwnPropertyNames(instance)
                : [];
            if (!prototype) {
                return [...ownProperties, ...prototypeProperties, ...props];
            }
            return getAllProperties(prototype, [
                ...props,
                ...ownProperties,
                ...prototypeProperties,
            ]);
        };
        const properties = getAllProperties(this);
        const exclude = [
            'constructor',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'toString',
            'valueOf',
        ];
        [...new Set(properties)].forEach((key) => {
            if (!key.startsWith('_') &&
                typeof this[key] === 'function' &&
                exclude.indexOf(key) === -1) {
                try {
                    const currentMethod = this[key].bind(this);
                    this[key] = function (...args) {
                        this._kernelIo.log('[ KernelCommunication ]: ' + key);
                        return currentMethod(...args);
                    };
                }
                catch (e) {
                    // TSLINT QUITE
                }
            }
        });
    }
    getConfigurationData(planObjectId) {
        return new Promise((resolve /*, reject*/) => {
            var _a;
            const planObject = this.kernelInstance.getPlanObject(planObjectId);
            const today = new Date().toISOString();
            const rootComponentId = this.kernelInstance.getComponentId(planObjectId);
            const catalog = getCatalogIdFromItemOrConfigurationId(rootComponentId);
            const boxForMeasurementSize = (_a = planObject.boxForMeasurement) === null || _a === void 0 ? void 0 : _a.size;
            const boxToUse = boxForMeasurementSize
                ? boxForMeasurementSize
                : planObject.bounds;
            const data = {
                created: today,
                lastAccess: today,
                configuration: this.kernelInstance.getSerializedConfiguration(planObjectId),
                configurationHash: this.kernelInstance.getHashOfConfiguration(planObjectId),
                parts: JSON.stringify(this.kernelInstance.getPartList(planObjectId)),
                rootComponentId,
                width: boxToUse.x,
                height: boxToUse.z,
                depth: boxToUse.y,
                catalog,
                orderable: false,
                requestable: false,
            };
            resolve(data);
        });
    }
    loadComponent(conversationId, configuration, parentId) {
        this._rapiAccess.getComponent(configuration.componentId).then((componentDefinition) => {
            var _a;
            let componentConfiguration = componentDefinition.configuration;
            if (!componentConfiguration) {
                componentConfiguration = 'error';
                (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onContentProblem({
                    rapiPath: "components" /* RAPI_PATHS.COMPONENTS */,
                    ids: [configuration.componentId],
                    message: configuration.componentId + ' has no configuration',
                });
            }
            this._kernelIo.setMeta({ componentId: configuration.componentId });
            this._kernelInstance.loadComponent(conversationId, componentConfiguration, configuration, parentId);
            this._flushSubComponentsWaiters();
        }, (e) => {
            var _a;
            this._kernelInstance.loadComponent(conversationId, 'error', configuration, parentId);
            this.onLoadComponentError(e, configuration.componentId);
            (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onError(new Error(`Component with id "${configuration.componentId}" can not be loaded. "${e}"`));
            this._flushSubComponentsWaiters();
        });
    }
    loadSubComponent(parentId, partId, componentId) {
        if (this._shouldWait) {
            let componentWait = this._subComponentsWaiters.get(componentId);
            if (!componentWait) {
                this._subComponentsWaiters.set(componentId, []);
            }
            componentWait = this._subComponentsWaiters.get(componentId);
            componentWait.push({ parentId, partId });
            this._subComponentsWaiters.set(componentId, componentWait);
        }
        else {
            this._rapiAccess
                .getComponent(componentId)
                .then((componentDefinition) => {
                var _a;
                let componentConfiguration = componentDefinition.configuration;
                if (!componentConfiguration) {
                    componentConfiguration = 'error';
                    (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onContentProblem({
                        rapiPath: "components" /* RAPI_PATHS.COMPONENTS */,
                        ids: [componentId],
                        message: 'SubComponent ' + componentId + ' has no configuration',
                    });
                }
                this._kernelIo.setMeta({ componentId, parentId });
                this._kernelInstance.loadedSubComponent(parentId, partId, componentId, componentConfiguration);
            });
        }
    }
    async loadItemConfigurations(conversationId, itemIds) {
        let ids = Array.isArray(itemIds) ? itemIds : [itemIds];
        this._requestedItemIds.push(...ids);
        await wait(0);
        if (!this._requestedItemIds.length) {
            return;
        }
        const idsToUse = [...this._requestedItemIds];
        this._requestedItemIds = [];
        const items = await this._rapiAccess.getItems(idsToUse);
        items.forEach((item) => {
            this._kernelInstance.loadedItemConfiguration(conversationId, item.id, item.configuration);
        });
    }
    requestDeleteComponent(componentId) {
        var _a, _b;
        if (!componentId) {
            return;
        }
        if ((_b = (_a = this._initData) === null || _a === void 0 ? void 0 : _a.featureFlags) === null || _b === void 0 ? void 0 : _b.reDock) {
            this._kernelInstance.deletePlanComponent(componentId);
        }
        else {
            this._kernelInstance.deleteComponent(componentId);
        }
    }
    dockComponentWithPosition(parentId, parentDockId, childId, childDockId, position) {
        var _a;
        this._kernelInstance.dockComponentWithPosition(childId, childDockId, parentId, parentDockId, position);
        const childDbId = this._kernelInstance.getComponentId(childId);
        const parentDbId = this._kernelInstance.getComponentId(parentId);
        (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onUserInitiatedDockDone(childDbId, childDockId, parentDbId, parentDockId, position);
    }
    Editor3dAddBakedMesh(runtimeComponentId, materialId, vertices, indices, uvCoords, normals, environmentGeometry, materialAttributes) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dAddBakedMesh(runtimeComponentId, materialId, vertices, indices, uvCoords, normals, environmentGeometry, materialAttributes));
    }
    Editor3dAddNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, vertices, indices, uvCoords, normals, environmentGeometry, uvTransform, materialAttributes) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dAddNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, vertices, indices, uvCoords, normals, environmentGeometry, uvTransform, materialAttributes));
    }
    Editor3ChangedNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, materialAttributes) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3ChangedNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, materialAttributes));
    }
    Editor3dRemoveNamedMesh(runtimeComponentId, geometryId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dRemoveNamedMesh(runtimeComponentId, geometryId));
    }
    Editor3dBeginConstruction(id, isDeltaUpdate) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dBeginConstruction(id, isDeltaUpdate));
    }
    Editor3dEndConstruction(id) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dEndConstruction(id));
    }
    Editor3dComponentCreated(id, position, eulerAngles, parentObjectRuntimeId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dComponentCreated(id, position, eulerAngles, parentObjectRuntimeId, false));
    }
    Editor3dComponentDocked(componentId, parentId, componentPosition, componentRotation) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dComponentDocked(componentId, parentId, componentPosition, componentRotation));
    }
    Editor3dGeometryReady(id) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dGeometryReady(id));
        this.requestPlanComponentConstruction(id);
        this._configuratorUiCallbacks.onGeometryReady(id);
    }
    Editor3dGeometryNotReady(id) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dGeometryNotReady(id));
        this._configuratorUiCallbacks.onGeometryNotReady(id);
    }
    componentDeleted(componentId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.componentDeleted(componentId));
    }
    componentMetaUpdated(componentId) {
        let kernelComponent = this._kernelInstance.getComponent(componentId);
        this._configuratorKernelCallbackListener.forEach((listener) => listener.componentMetaUpdated(kernelComponent));
    }
    sceneCleared() {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.sceneCleared());
    }
    requestMaterialsInGroup(groupIds) {
        let ids = Array.isArray(groupIds) ? groupIds : [groupIds];
        ids.forEach((groupId) => {
            if (this._cachedGroupIds.indexOf(groupId) === -1) {
                this._cachedGroupIds.push(groupId);
            }
        });
        if (this._waitingForGroups) {
            return;
        }
        this._waitingForGroups = true;
        AsyncHelper.waitFor(4 /* ASYNC_OPERATIONS.CONFIGURATION_LOADED */).then(( /* data: KernelConfigurationLoadedData */) => {
            this._rapiAccess.getMaterialsByGroup(this._cachedGroupIds).then((materialGroups) => {
                let materialGroupsCollection = [];
                materialGroups.forEach((materialGroup) => {
                    const stringArray = [];
                    materialGroup.materials.forEach((material) => stringArray.push(material.id));
                    const idToUse = materialGroup.legacyId || materialGroup.id;
                    if (!materialGroup.legacyId) {
                        console.warn('Material group has no legacy id, please check content why this is the case');
                    }
                    materialGroupsCollection.push({
                        group: idToUse,
                        materials: stringArray,
                    });
                });
                if (materialGroupsCollection.length) {
                    this._kernelInstance.setMaterialsInGroup(materialGroupsCollection);
                }
                this._cachedGroupIds = [];
            }, (e) => {
                var _a;
                console.error(e);
                (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onError(new Error(`Material group with ids "${this._cachedGroupIds.join(',')}" can not be loaded. "${e}"`));
                this._cachedGroupIds = [];
            });
        });
    }
    requestPlanComponentConstruction(id, useDeltaUpdates = USE_DELTA_COMPONENT_UPDATES) {
        if (useDeltaUpdates) {
            this._kernelInstance.requestDeltaPlanComponentConstruction(id);
        }
        else {
            this._kernelInstance.requestPlanComponentConstruction(id);
        }
    }
    addConfiguratorListener(listener) {
        this._configuratorKernelCallbackListener.add(listener);
    }
    removeConfiguratorListener(listener) {
        this._configuratorKernelCallbackListener.delete(listener);
    }
    cleanUpCallbacks() {
        if (typeof this._kernelContainer.unregisterConfiguratorCallback === 'function') {
            this._kernelContainer.unregisterConfiguratorCallback(this);
        }
    }
    async requestMaterialProperties(materialIds) {
        // materialIds could be a single Id if sdk is still attached to an old Core
        let ids = Array.isArray(materialIds) ? materialIds : [materialIds];
        this._requestedMaterialIds.push(...ids);
        await wait(0);
        if (!this._requestedMaterialIds.length) {
            // already requested materials from last event loop do not need to do anything :-)
            return;
        }
        const idsToUse = [...this._requestedMaterialIds];
        this._requestedMaterialIds = [];
        const materials = await this._rapiAccess.getMaterials(idsToUse);
        let propertiesOfMaterials = [];
        materials.forEach((material) => {
            const materialProperties = new this._kernelContainer.StringStringMap();
            const properties = material.properties || {};
            for (let key in properties) {
                if (properties.hasOwnProperty(key)) {
                    materialProperties.set(key, properties[key]);
                }
            }
            if (materialProperties.size()) {
                propertiesOfMaterials.push({
                    id: material.id,
                    properties: materialProperties,
                });
            }
        });
        if (propertiesOfMaterials.length) {
            this._kernelInstance.setMaterialProperties(propertiesOfMaterials);
        }
    }
    registerCallbacks() {
        this._kernelContainer.registerConfiguratorCallback(this);
    }
    pause() {
        this.cleanUpCallbacks();
    }
    resume() {
        this.cleanUpCallbacks();
        this.registerCallbacks();
    }
    destroy() {
        return undefined;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _handleCortoMesh(buffer, meshId, quality) {
        var _a;
        try {
            this._kernelInstance.addMeshCorto(meshId, quality, new Uint8Array(buffer));
        }
        catch (e) {
            console.error(e);
            (_a = this._configuratorUiCallbacks) === null || _a === void 0 ? void 0 : _a.onMemoryCorruption();
        }
    }
    _handleInvalidMesh(meshId) {
        try {
            this._kernelInstance.setExternalMeshInvalid(meshId);
        }
        catch (e) {
            console.error(e);
        }
    }
    calcPartsPriceSum(partList) {
        return this._calcPrice(partList);
    }
    _calcPrice(partList) {
        const partMap = new Map();
        if (!partList) {
            partList = this._kernelInstance.getFullPartList();
        }
        const hasPartList = !!partList && !!partList.fullList && !!partList.fullList.length;
        if (this._initData.useRoomlePrice && hasPartList) {
            const currencySymbol = partList.fullList[0].currencySymbol;
            const reducedSum = partList.fullList.reduce((sum, component) => sum +
                (component.count ? component.count : 0) *
                    (component.price ? component.price : 0), 0);
            const totalSum = roundWithPrecision(reducedSum, 2);
            this._configuratorUiCallbacks.onUpdatePrice(currencySymbol, totalSum);
            return Promise.resolve({ totalSum, partMap });
        }
        else if (this._initData.usePriceService && hasPartList) {
            const articleNumbers = partList.fullList.reduce((acc, component) => {
                const priceId = kernelPartToPriceId(component);
                if (priceId) {
                    partMap.set(priceId, component);
                    acc.push(priceId);
                }
                return acc;
            }, []);
            return new Promise((resolve, reject) => {
                this._rapiAccess.getPrices(articleNumbers).then((prices) => {
                    if (!prices.length) {
                        return reject(new Error('prices are empty'));
                    }
                    let totalSum = 0;
                    const priceMap = objectArrayToMap(prices, 'priceId');
                    for (const kernelPart of partList.fullList) {
                        const priceId = kernelPartToPriceId(kernelPart);
                        if (!priceMap.has(priceId)) {
                            console.warn('PriceId: ' + priceId + ' has no corresponding kernel-part');
                            continue;
                        }
                        const { price, currencySymbol } = priceMap.get(priceId);
                        kernelPart.price = price;
                        kernelPart.currencySymbol = currencySymbol;
                        totalSum += price * kernelPart.count;
                    }
                    totalSum = roundWithPrecision(totalSum, 2);
                    // sidenote: we only support single currency so if there are mixed currencies in the price service we keep it to "shit in shit out"
                    this._configuratorUiCallbacks.onUpdatePrice(prices[0].currencySymbol, totalSum);
                    return resolve({
                        totalSum,
                        partMap,
                    });
                }, (error) => {
                    console.error(error);
                    reject(error);
                });
            });
        }
        return Promise.resolve({ totalSum: 0, partMap });
    }
    async addUiDataAndPriceToPartList(partList, hash) {
        const { fullList, originPart } = partList;
        const perMainComponent = partList.perMainComponent;
        this.addUiDataToPartList(fullList, hash);
        let partMap;
        try {
            const priceResult = await this._calcPrice(partList);
            partMap = priceResult.partMap;
        }
        catch (e) {
            console.error(e);
            partMap = new Map();
        }
        const useAPrice = this._initData.usePriceService || this._initData.useRoomlePrice;
        const addPrice = (kernelPart) => {
            if (!useAPrice) {
                kernelPart.price = null;
                kernelPart.currencySymbol = null;
            }
            const priceId = kernelPartToPriceId(kernelPart);
            if (!priceId) {
                return;
            }
            if (!partMap.has(priceId)) {
                return;
            }
            const { price, currencySymbol } = partMap.get(priceId);
            if (typeof price !== 'number') {
                return;
            }
            kernelPart.price = price;
            kernelPart.currencySymbol = currencySymbol;
        };
        fullList.forEach(addPrice);
        perMainComponent.forEach(({ fullList: perMainComponentFullList, perMainComponent: perMainComponentPerMainComponent, }) => {
            if (perMainComponentPerMainComponent.length > 0) {
                console.error('Not implemented! perMainComponent is deeper than one level');
            }
            this.addUiDataToPartList(perMainComponentFullList, hash);
            perMainComponentFullList.forEach(addPrice);
        });
        return { fullList, perMainComponent, originPart };
    }
    addUiDataToPartList(partList, hash) {
        const asyncMaterials = [];
        partList.forEach((part) => {
            const componentDefinition = this._rapiAccess.peekComponent(part.componentId);
            if (componentDefinition && (!part.labelIsCalculated || !part.label)) {
                part.label = componentDefinition.label;
            }
            part.parameters.forEach((parameter) => {
                this._unitFormatter.formatPartListParameter(parameter);
                if (isMaterial(parameter)) {
                    const material = this._rapiAccess.peekMaterial(parameter.value);
                    if (material) {
                        parameter.valueLabel =
                            material.label || material.name || parameter.value;
                    }
                    else if (asyncMaterials.indexOf(parameter.value) === -1) {
                        asyncMaterials.push(parameter.value);
                    }
                }
            });
        });
        if (asyncMaterials.length) {
            this._rapiAccess.getMaterials(asyncMaterials).then((materialsFromDb) => {
                const uiNeedsUpdate = this._lastPartListHash !== hash;
                if (Array.isArray(materialsFromDb) &&
                    materialsFromDb.length &&
                    uiNeedsUpdate) {
                    this._lastPartListHash = hash;
                    this.requestPartListAndUpdatePricesOfParts();
                }
            });
        }
        return partList;
    }
    async requestPartListAndUpdatePricesOfParts(hash, _prices) {
        let partList = this._kernelInstance.getFullPartList();
        if (!hash) {
            hash = this._kernelInstance.getHashOfConfiguration(this._configuratorContext.planObjectId);
        }
        const enhancedPartList = await this.addUiDataAndPriceToPartList(partList, hash);
        this._configuratorUiCallbacks.onPartListUpdate(enhancedPartList, btoa(hash));
    }
}
__decorate([
    inject
], CommonKernelAccess.prototype, "_rapiAccess", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_scriptLoader", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_kernelIo", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_dataSyncer", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_lifeCycleManager", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_configuratorUiCallbacks", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_globalCallback", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_initData", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_unitFormatter", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_configuratorContext", void 0);
__decorate([
    inject
], CommonKernelAccess.prototype, "_globalInitData", void 0);

const { APP } = Env;
const { RAPI } = APP;
const headers = RAPI.headers;
const itemHeaders = RAPI.itemHeaders;
const TOKEN_IDENTIFIER = headers.token;
const LIVE_RAPI = 'live';
const MAX_URL_LENGTH = 1500;
const MESH_DEFAULT_FORMAT = 'crt';
const MESH_DEFAULT_QUALITY = 50;
const TENANT_ME_CACHE_KEY = '0';
const HTTP_VERBS = {
    GET: 'GET',
    POST: 'POST',
    PUT: 'PUT',
};
const isPlanSnapshotId = (id) => id.startsWith('ps_');
const LEGACY_GROUP_INDICATOR = uuid();
const RETRY_AFTER = 60000; // Retry after a minute!
let RAPI_MATERIAL_GROUP_CACHE = new Map();
let ITEM_ADDITIONAL_CONTENT_CACHE = new Map();
let RAPI_RELATIONS_CACHE = new Map();
let RAPI_CACHE = new Map();
let MESHES_TO_CATALOG_CACHE = new Map();
let RAPI_PACKAGE_CACHE = new Map();
let RAPI_PRELOAD_CACHE = new Map();
let WAITERS_FOR_URL = new Map();
const LOCAL_STORAGE_QUEUE_KEY = 'hsc_configurations_offline_queue_v1';
let RAPI_ERROR_CACHE = new Map();
const getCachedMaterialGroup = (id) => RAPI_MATERIAL_GROUP_CACHE.get(id) ||
    RAPI_MATERIAL_GROUP_CACHE.get(LEGACY_GROUP_INDICATOR + id);
const hasMaterialTags = (material) => material && material.tags && material.tags.length;
const materialHasNoTagsButGroup = (material) => !hasMaterialTags(material) && material.group;
const RAPI_PATH_KEY = '__rapi_path__';
class RapiAccess {
    constructor(creator) {
        this._itemLoaded = false;
        this._currentToken = null;
        this._creator_ = creator;
        window.addEventListener('online', this._flushOfflineQueue.bind(this));
    }
    getPreloadForItem(id) {
        return this._getPreload(id, true);
    }
    getPreloadForConfiguration(id) {
        return this._getPreload(id, false);
    }
    _getPreload(id, isItem) {
        return new Promise((resolve, reject) => {
            if (!navigator.onLine) {
                return resolve();
            }
            if (this._dataSyncer.getIsCatalogSynced(getCatalogIdFromItemOrConfigurationId(id))) {
                return resolve();
            }
            let packageCache = RAPI_PRELOAD_CACHE.get(id);
            if (packageCache) {
                return resolve();
            }
            const filter = isItem ? '?itemId=' : '?configurationId=';
            this._get('/' + "preloads/components" /* RAPI_PATHS.PRELOAD */ + '/' + filter + id, "preloads/components" /* RAPI_PATHS.PRELOAD */).then((preload) => {
                if (RAPI_PRELOAD_CACHE.get(id)) {
                    return resolve();
                }
                preload.forEach((component) => {
                    this._prepareData(component, "components" /* RAPI_PATHS.COMPONENTS */);
                });
                RAPI_PRELOAD_CACHE.set(id, true);
                resolve();
            }, reject);
        });
    }
    changeUseOfHDGeometry() {
        const cache = RAPI_CACHE.get("components" /* RAPI_PATHS.COMPONENTS */);
        RAPI_PRELOAD_CACHE.clear();
        RAPI_PACKAGE_CACHE.clear();
        if (cache) {
            RAPI_CACHE.delete("components" /* RAPI_PATHS.COMPONENTS */);
        }
    }
    getHSCPackage(id) {
        return new Promise((resolve, reject) => {
            let packageCache = RAPI_PACKAGE_CACHE.get(id);
            if (packageCache) {
                return resolve();
            }
            this._get('/catalogs/' + id + '/' + "package" /* RAPI_PATHS.PACKAGE */, "package" /* RAPI_PATHS.PACKAGE */).then((rapiPackage) => {
                if (RAPI_PACKAGE_CACHE.get(id)) {
                    return resolve(rapiPackage);
                }
                rapiPackage.components.forEach((component) => {
                    this._prepareData(component, "components" /* RAPI_PATHS.COMPONENTS */);
                });
                rapiPackage.materials.forEach((material) => {
                    this._prepareData(material, "materials" /* RAPI_PATHS.MATERIALS */);
                    this._prepareGroups(material);
                });
                rapiPackage.textures.forEach((texture) => {
                    this._prepareData(texture, "textures" /* RAPI_PATHS.TEXTURES */);
                });
                RAPI_PACKAGE_CACHE.set(id, true);
                resolve(rapiPackage);
            }, reject);
        });
    }
    getComponent(id) {
        return this._getById(id, "components" /* RAPI_PATHS.COMPONENTS */);
    }
    getConfiguration(id) {
        return this._getById(id, "configurations" /* RAPI_PATHS.CONFIGURATIONS */);
    }
    getConfigurations(ids) {
        return this._getByIds(ids, "configurations" /* RAPI_PATHS.CONFIGURATIONS */);
    }
    getItem(id) {
        return this._getById(id, "items" /* RAPI_PATHS.ITEMS */, {
            additionalHeaders: itemHeaders,
        });
    }
    getComponents(ids) {
        return this._getByIds(ids, "components" /* RAPI_PATHS.COMPONENTS */);
    }
    getItems(ids) {
        return this._getByIds(ids, "items" /* RAPI_PATHS.ITEMS */, {
            additionalHeaders: itemHeaders,
        });
    }
    getTag(id) {
        return this._getById(id, "tags" /* RAPI_PATHS.TAG */);
    }
    getTags(ids) {
        return this._getByIds(ids, "tags" /* RAPI_PATHS.TAG */);
    }
    getTexture(id) {
        return this._getById(id, "textures" /* RAPI_PATHS.TEXTURES */);
    }
    getCatalog(id) {
        return this._getById(id, "catalogs" /* RAPI_PATHS.CATALOGS */);
    }
    getMesh(id, format = MESH_DEFAULT_FORMAT, quality = MESH_DEFAULT_QUALITY) {
        //@todo BUST THE CACHE IF format or quality changes!
        return this._getById(id, "meshes" /* RAPI_PATHS.MESHES */, {
            pathSuffix: '/data?format=' + format + '&targetQuality=' + quality.toString(),
        });
    }
    getMeshesOfCatalog(catalogId) {
        return new Promise((resolve, reject) => {
            const cached = MESHES_TO_CATALOG_CACHE.get(catalogId);
            if (cached) {
                resolve(cached);
            }
            else {
                this._get('/meshes?catalog=' + catalogId, "catalogMeshes" /* RAPI_PATHS.CATALOG_MESHES */).then((meshes) => {
                    MESHES_TO_CATALOG_CACHE.set(catalogId, meshes);
                    resolve(meshes);
                }, reject);
            }
        });
    }
    getTexturesOf(rapiJson) {
        return this._getRelationData(rapiJson, {
            rapiPath: "textures" /* RAPI_PATHS.TEXTURES */ /*, key: 'material' */,
        });
    }
    getItemsOf(rapiJson) {
        return this._getRelationData(rapiJson, {
            rapiPath: "items" /* RAPI_PATHS.ITEMS */ /*, key: 'catalog' */,
        });
    }
    async getMaterialsOf(rapiJson) {
        const materials = await this._getRelationData(rapiJson, { rapiPath: "materials" /* RAPI_PATHS.MATERIALS */ /*, key: 'materials' */ }, { embed: ["textures" /* RAPI_PATHS.TEXTURES */] });
        return materials.filter((material) => material.active);
    }
    getComponentsOf(rapiJson) {
        return this._getRelationData(rapiJson, {
            rapiPath: "components" /* RAPI_PATHS.COMPONENTS */ /*, key: 'catalog' */,
        });
    }
    getAdditionalContentsOfItems(rapiItems) {
        const idsToCheck = [];
        const rapiPath = "itemAdditionalContents" /* RAPI_PATHS.ITEM_ADDITIONAL_CONTENTS */;
        const dataInCache = [];
        rapiItems.forEach((item) => {
            const cachedAdditionalItems = ITEM_ADDITIONAL_CONTENT_CACHE.get(item.id.toString());
            if (cachedAdditionalItems) {
                dataInCache.push(...cachedAdditionalItems);
            }
            else {
                idsToCheck.push(item.id.toString());
            }
        });
        return new Promise((resolve, reject) => {
            if (idsToCheck.length === 0) {
                resolve(dataInCache);
                return;
            }
            const filterKey = 'itemIds';
            this._getByIdsPackets(idsToCheck, rapiPath, {
                filterKey,
            }).then((data) => {
                data.forEach((additionalItemContent) => {
                    let additionalContentsOfItemCache = ITEM_ADDITIONAL_CONTENT_CACHE.get(additionalItemContent.itemId);
                    if (!additionalContentsOfItemCache) {
                        additionalContentsOfItemCache = [];
                    }
                    for (let i = 0, length = additionalContentsOfItemCache.length; i < length; i++) {
                        const additionalContentFromCache = additionalContentsOfItemCache[i];
                        if (additionalContentFromCache.id === additionalItemContent.id) {
                            return;
                        }
                    }
                    additionalContentsOfItemCache.push(additionalItemContent);
                    ITEM_ADDITIONAL_CONTENT_CACHE.set(additionalItemContent.itemId, additionalContentsOfItemCache);
                });
                resolve([...data, ...dataInCache]);
            }, reject);
        });
    }
    getMaterial(id) {
        return this._getById(id, "materials" /* RAPI_PATHS.MATERIALS */, {
            embed: ["textures" /* RAPI_PATHS.TEXTURES */],
        });
    }
    peekMaterial(id) {
        return this._peekData(id, "materials" /* RAPI_PATHS.MATERIALS */);
    }
    peekComponent(id) {
        return this._peekData(id, "components" /* RAPI_PATHS.COMPONENTS */);
    }
    peekItem(id) {
        return this._peekData(id, "items" /* RAPI_PATHS.ITEMS */);
    }
    peekConfiguration(id) {
        return this._peekData(id, "configurations" /* RAPI_PATHS.CONFIGURATIONS */);
    }
    async getMaterials(ids) {
        const materials = await this._getByIds(ids, "materials" /* RAPI_PATHS.MATERIALS */, { embed: ["textures" /* RAPI_PATHS.TEXTURES */] });
        return materials.filter((material) => material.active);
    }
    getPlan(id) {
        return this._getById(id, "plans" /* RAPI_PATHS.PLANS */);
    }
    getPlanSnapshot(id) {
        return this._getById(id, "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */);
    }
    // eslint-disable-next-line:member-ordering
    static clearCaches() {
        RAPI_MATERIAL_GROUP_CACHE = new Map();
        RAPI_RELATIONS_CACHE = new Map();
        RAPI_CACHE = new Map();
        RAPI_PACKAGE_CACHE = new Map();
        RAPI_PRELOAD_CACHE = new Map();
        WAITERS_FOR_URL = new Map();
        ITEM_ADDITIONAL_CONTENT_CACHE = new Map();
    }
    cleanUp() {
        RapiAccess.clearCaches();
    }
    getMaterialsByGroup(groupIdsToCheck) {
        const groupIds = groupIdsToCheck.slice();
        const dataInCache = [];
        const rapiPath = "materials" /* RAPI_PATHS.MATERIALS */;
        let length = groupIds.length;
        for (let i = 0; i < length; i++) {
            const cachedMaterialGroup = getCachedMaterialGroup(groupIds[i]);
            if (cachedMaterialGroup) {
                const materialIdsLength = cachedMaterialGroup.length;
                for (let j = 0; j < materialIdsLength; j++) {
                    let dataCache = this._getCache(rapiPath);
                    const material = dataCache.get(cachedMaterialGroup[j]);
                    dataInCache.push(material);
                }
                groupIds.splice(i, 1);
                length--;
                i--;
            }
        }
        return new Promise((resolve, reject) => {
            if (groupIds.length === 0 || !navigator.onLine) {
                resolve(this.combineMaterialsToGroups(dataInCache));
                return;
            }
            const filterKey = 'groups';
            this._getByIdsPackets(groupIds, rapiPath, {
                filterKey,
                embed: ["textures" /* RAPI_PATHS.TEXTURES */],
            }).then((data) => {
                resolve(this.combineMaterialsToGroups([
                    ...data,
                    ...dataInCache,
                ]));
            }, reject);
        });
    }
    _flushOfflineQueue() {
        return new Promise((resolve, reject) => {
            const cachedData = this._localStorage.getItem(LOCAL_STORAGE_QUEUE_KEY);
            const allPromises = [];
            for (let key in cachedData) {
                if (cachedData.hasOwnProperty(key)) {
                    const queuedConfiguration = cachedData[key];
                    allPromises.push(new Promise((resolveConfiguration, rejectConfiguration) => {
                        this.saveConfiguration(queuedConfiguration.data).then((configurationFromDb) => {
                            const promises = [];
                            if (queuedConfiguration.perspectiveImage &&
                                !configurationFromDb.perspectiveImage) {
                                promises.push(this.savePerspectiveImage(configurationFromDb, queuedConfiguration.perspectiveImage));
                            }
                            if (queuedConfiguration.topImage &&
                                !configurationFromDb.topImage) {
                                promises.push(this.savePerspectiveImage(configurationFromDb, queuedConfiguration.topImage));
                            }
                            Promise.all(promises).then(resolveConfiguration, rejectConfiguration);
                        }, rejectConfiguration);
                    }));
                }
            }
            Promise.all(allPromises).then(() => {
                this._localStorage.setItem(LOCAL_STORAGE_QUEUE_KEY, {});
                resolve();
            }, reject);
        });
    }
    _setQueuedConfiguration(configuration, assets = {}) {
        const configurationHash = configuration.configurationHash;
        const { perspectiveImage, topImage } = assets;
        let offlineQueue = this._localStorage.getItem(LOCAL_STORAGE_QUEUE_KEY) || {};
        let queuedConfiguration = offlineQueue[configurationHash] || {};
        queuedConfiguration.data = configuration;
        queuedConfiguration.perspectiveImage = perspectiveImage;
        queuedConfiguration.topImage = topImage;
        offlineQueue[configurationHash] = queuedConfiguration;
        this._localStorage.setItem(LOCAL_STORAGE_QUEUE_KEY, offlineQueue);
    }
    async saveConfiguration(configuration) {
        if (!navigator.onLine) {
            configuration.perspectiveImage = null; // FORCE REGENERATION OF PERSPECTIVE IMAGE
            configuration.topImage = null; // FORCE REGENERATION OF TOP IMAGE
            this._setQueuedConfiguration(configuration);
            this._markConfigurationAsLocally(configuration);
            return Promise.resolve(configuration);
        }
        const savedConfiguration = await this._save('/' + "configurations" /* RAPI_PATHS.CONFIGURATIONS */, { configuration }, "configurations" /* RAPI_PATHS.CONFIGURATIONS */, {
            accept: 'application/json',
            contentType: 'application/json; charset=UTF-8',
        });
        return savedConfiguration;
    }
    saveTopImage(configuration, topImage) {
        return this._saveConfigurationImage(configuration, topImage, 'topImage');
    }
    savePerspectiveImage(configuration, perspectiveImage) {
        return this._saveConfigurationImage(configuration, perspectiveImage, 'perspectiveImage');
    }
    savePlanSnapshotTopImage(planSnapshot, topImage) {
        return this._savePlanSnapshotImage(planSnapshot, topImage, 'topImage');
    }
    savePlanSnapshotPerspectiveImage(planSnapshot, perspectiveImage) {
        return this._savePlanSnapshotImage(planSnapshot, perspectiveImage, 'perspectiveImage');
    }
    getShortUrl(referencedId, type) {
        return new Promise((resolve, reject) => {
            return this._fetchJson('/' + "shortIds" /* RAPI_PATHS.SHORT_IDS */, "shortIds" /* RAPI_PATHS.SHORT_IDS */, {
                method: HTTP_VERBS.POST,
                resolve,
                reject,
                data: JSON.stringify({
                    shortId: {
                        type,
                        referencedId,
                    },
                }),
                accept: 'application/json',
                contentType: 'application/json; charset=UTF-8',
            });
        });
    }
    _peekData(id, rapiPath) {
        const cache = RAPI_CACHE.get(rapiPath);
        if (!cache) {
            return null;
        }
        const data = cache.get(id);
        if (data) {
            return data;
        }
        return null;
    }
    _saveConfigurationImage(configuration, image, type) {
        if (!navigator.onLine) {
            const assets = {};
            assets[type] = image;
            this._setQueuedConfiguration(configuration, assets);
            this._markConfigurationAsLocally(configuration);
            configuration[type] = image.image;
            return Promise.resolve(configuration);
        }
        const formData = this._formDataUtil.create(image.image, configuration.configurationHash, IMAGE_FORMATS.PNG, type);
        return this._save('/' + "configurations" /* RAPI_PATHS.CONFIGURATIONS */ + '/' + configuration.id + '/' + type, formData, "configurations" /* RAPI_PATHS.CONFIGURATIONS */, { accept: 'application/json' });
    }
    _savePlanSnapshotImage(planSnapshot, image, type) {
        const formData = this._formDataUtil.create(image.image, planSnapshot.id, IMAGE_FORMATS.PNG, 'file');
        formData.append('type', type);
        return this._save('/' + "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */ + '/' + planSnapshot.id, formData, "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */, { accept: 'application/json', method: HTTP_VERBS.PUT });
    }
    _markConfigurationAsLocally(data) {
        data.isLocally = true;
        data.id = data.configurationHash;
    }
    _save(url, dataIn, rapiPath, options = {}) {
        const data = dataIn instanceof FormData ? dataIn : JSON.stringify(dataIn);
        return new Promise((resolve, reject) => {
            const method = options.method || HTTP_VERBS.POST;
            const params = {
                // @todo -- this is not super nice :-)
                // we should change to PUT if the data has an ID set
                // but then we would need to change the URL and this
                // could become problematic... let's keep it for now
                method,
                data,
                resolve,
                reject,
            };
            if (options.contentType) {
                params.contentType = options.contentType;
            }
            if (options.accept) {
                params.accept = options.accept;
            }
            this._fetchJson(url, rapiPath, params);
        });
    }
    combineMaterialsToGroups(materials) {
        return new Promise((resolve, reject) => {
            const processedGroups = new Map();
            const noGroup = {
                id: null,
                label: null,
                materials: [],
            };
            const neededTags = [];
            for (let i = 0, length = materials.length; i < length; i++) {
                const material = materials[i];
                const materialGroupIds = material.tags && material.tags.length
                    ? material.tags.map((tag) => ({
                        isTag: true,
                        id: tag,
                    }))
                    : [];
                if (material.group) {
                    materialGroupIds.push({
                        isTag: false,
                        id: LEGACY_GROUP_INDICATOR + material.group,
                        legacyId: material.group,
                    });
                }
                if (!materialGroupIds.length) {
                    materialGroupIds.push({ isTag: false, id: null });
                }
                if (material.tags && material.tags.length) {
                    material.tags.forEach((neededTag) => neededTags.indexOf(neededTag) === -1
                        ? neededTags.push(neededTag)
                        : null);
                }
                materialGroupIds.forEach(({ isTag, id: materialGroupId, legacyId }) => {
                    const materialId = material.id;
                    const noGroupMaterials = [];
                    let materialGroupCache = materialGroupId
                        ? getCachedMaterialGroup(materialGroupId)
                        : noGroupMaterials;
                    if (!materialGroupCache) {
                        RAPI_MATERIAL_GROUP_CACHE.set(materialGroupId, []);
                        materialGroupCache = getCachedMaterialGroup(materialGroupId);
                    }
                    if (materialGroupCache.indexOf(materialId.toString()) === -1) {
                        materialGroupCache.push(materialId.toString());
                    }
                    const hasTags = hasMaterialTags(material);
                    const hasTagsAndIsTag = hasTags && isTag;
                    const hasNoTagsButGroup = materialHasNoTagsButGroup(material);
                    const hasNoTagsButGroupAndIsGroup = hasNoTagsButGroup && !isTag;
                    const hasNoGroupAtAll = !hasTags && !hasNoTagsButGroup && !materialGroupId;
                    if (hasTagsAndIsTag ||
                        hasNoTagsButGroupAndIsGroup ||
                        hasNoGroupAtAll) {
                        let group = materialGroupId
                            ? processedGroups.get(materialGroupId)
                            : noGroup;
                        if (!group) {
                            processedGroups.set(materialGroupId, {
                                id: materialGroupId,
                                label: material.groupLabel,
                                legacyId,
                                materials: [],
                            });
                            group = processedGroups.get(materialGroupId);
                        }
                        group.materials.push(material);
                    }
                });
            }
            const materialGroups = noGroup.materials.length
                ? [noGroup]
                : [];
            this.getTags(neededTags).then((tags) => {
                const tagMap = tags.reduce((acc, tag) => ((acc[tag.id] = tag), acc), {});
                processedGroups.forEach((group, key) => {
                    materialGroups.push({
                        id: key,
                        label: tagMap[key] ? tagMap[key].label : group.label,
                        materials: group.materials,
                        legacyId: group.legacyId,
                        sort: tagMap[key] ? tagMap[key].sort : undefined,
                    });
                });
                return resolve(materialGroups);
            }, reject);
        });
    }
    _getByIds(idsToCheck, rapiPath, options = {}) {
        const cache = this._getCache(rapiPath);
        const errorCache = this._getErrorCache(rapiPath);
        const dataInCache = [];
        const ids = [...new Set(idsToCheck)];
        let length = ids.length;
        if (cache && cache.size) {
            const timestamp = new Date().getTime();
            for (let i = 0; i < length; i++) {
                const id = ids[i];
                const cached = cache.get(id);
                const errored = errorCache.get(id);
                let isDataOnClient = false;
                if (cached !== undefined && cached !== null) {
                    dataInCache.push(cached);
                    isDataOnClient = true;
                }
                else {
                    // don't recheck if there was and error and this error occured before retry time OR we are offline
                    isDataOnClient =
                        errored !== undefined &&
                            (timestamp - errored.timestamp < RETRY_AFTER ||
                                navigator.onLine === false);
                }
                if (isDataOnClient) {
                    ids.splice(i, 1);
                    length--;
                    i--;
                }
            }
        }
        return new Promise((resolve, reject) => {
            if (ids.length === 0 || !navigator.onLine) {
                resolve(dataInCache);
                return;
            }
            this._getByIdsPackets(ids, rapiPath, options).then((data) => {
                resolve([...data, ...dataInCache]);
            }, reject);
        });
    }
    _getByIdsPackets(ids, rapiPath, options = {}) {
        const filterKey = options.filterKey || 'ids';
        let i;
        let filter = '/' + rapiPath + '/';
        let seperator = '?';
        let packetUrls = [];
        const idsLength = ids.length;
        if (!idsLength) {
            return new Promise((resolve) => resolve([]));
        }
        let isPushed = true;
        let usedIds = [];
        for (i = 0; i < idsLength; i++) {
            isPushed = false;
            const actualId = ids[i];
            const toAppend = seperator + filterKey + '[]=' + actualId;
            const nextLength = toAppend.length + filter.length;
            usedIds.push(actualId);
            seperator = '&';
            if (nextLength <= MAX_URL_LENGTH) {
                filter += toAppend;
            }
            else {
                if (nextLength > MAX_URL_LENGTH) {
                    usedIds.pop();
                    i--;
                }
                packetUrls.push({ url: filter, ids: usedIds });
                isPushed = true;
                filter = '/' + rapiPath + '/';
                seperator = '?';
                usedIds = [];
            }
        }
        if (!isPushed) {
            packetUrls.push({ url: filter, ids: usedIds });
        }
        const packets = [];
        packetUrls.forEach((packetDefinition) => packets.push(this._getByIdsSingle(packetDefinition.ids, packetDefinition.url, rapiPath, options)));
        return new Promise((resolve, reject) => {
            Promise.all(packets).then((packetsFromDb) => {
                const data = [];
                if (packetsFromDb.length) {
                    packetsFromDb.forEach((packet) => data.push(...packet));
                }
                resolve(data);
            }, reject);
        });
    }
    _getByIdsSingle(ids, url, rapiPath, options = {}) {
        return new Promise((resolve, reject) => {
            this._get(url, rapiPath, options).then((data) => {
                for (let j = 0, dataLength = data.length; j < dataLength; j++) {
                    const cacheId = options && options.cacheKey
                        ? data[j][options.cacheKey]
                        : data[j].id;
                    const index = ids.indexOf(cacheId.toString());
                    if (index !== -1) {
                        ids.splice(index, 1);
                    }
                }
                const idsLength = ids.length;
                if (idsLength) {
                    const matchingCache = this._getCache(rapiPath);
                    const errorCache = this._getErrorCache(rapiPath);
                    const timestamp = new Date().getTime();
                    for (let k = 0; k < idsLength; k++) {
                        errorCache.set(ids[k], { code: 0 /* RAPI_ERRORS.UNKNOWN */, timestamp });
                        matchingCache.delete(ids[k]);
                    }
                    this._errorHandler.dispatch(2 /* ERROR_CODES.CONTENT_PROBLEM */, [
                        rapiPath,
                        ids.map((a) => '"' + a + '"').join(','),
                    ]);
                }
                resolve(data);
            }, reject);
        });
    }
    _getById(id, rapiPath, optionsIn = {}) {
        if (!id || id === '' || typeof id !== 'string') {
            console.error('no id passed to _getById');
            return Promise.reject(new Error('no id passed to _getById'));
        }
        const cache = this._getCache(rapiPath);
        const cachedData = cache.get(id);
        if (cachedData) {
            return new Promise((resolve) => resolve(cachedData));
        }
        if (!navigator.onLine) {
            return Promise.reject('Nothing cached but tried to fetch in offline mode');
        }
        const options = { ...optionsIn, id };
        const suffix = optionsIn.pathSuffix || '';
        return this._get('/' + rapiPath + '/' + id + suffix, rapiPath, options);
    }
    _get(url, rapiPath, options = {}) {
        const suffix = AppContext.useHDGeometry ? 'includeGeometryHD=true' : '';
        let seperator = url.indexOf('?') === -1 ? '?' : '&';
        if (suffix !== '') {
            url += seperator + suffix;
        }
        if (options.embed && Array.isArray(options.embed)) {
            options.embed.forEach((embedRapiPath) => {
                url +=
                    seperator +
                        'embed' +
                        (embedRapiPath[0].toUpperCase() + embedRapiPath.substr(1)) +
                        '=true';
                seperator = '&';
            });
        }
        return new Promise((resolve, reject) => {
            const waiters = WAITERS_FOR_URL.get(url);
            if (Array.isArray(waiters) && waiters.length > 0) {
                waiters.push({ resolve, reject });
            }
            else {
                WAITERS_FOR_URL.set(url, [{ resolve, reject }]);
                this._fetchJson(url, rapiPath, options);
            }
        });
    }
    _fetchJson(url, rapiPath, options = {}) {
        this._fetch(url, options)
            .then(handleJsonResponse.bind(this))
            .then(this._handleJson(url, rapiPath, options).bind(this))
            .catch(this._handleError(url, options).bind(this));
    }
    async _fetch(url, options) {
        const method = options.method ? options.method : HTTP_VERBS.GET;
        const headersObj = this._createHeaders(options);
        const requestData = {
            method,
            headers: headersObj,
            mode: 'cors',
            cache: 'default',
        };
        if (options.data) {
            requestData.body = options.data;
        }
        let rapiServer = RAPI.server;
        const overrideRapi = this._globalInitData.overrideRapi;
        if (overrideRapi) {
            rapiServer =
                overrideRapi === LIVE_RAPI ? RAPI.liveServer : RAPI.testServer;
        }
        // add  "|| this._customApiUrl === ''" for testing, otherwise checking urls is quite tedious
        if (this._globalInitData.customApiUrl ||
            this._globalInitData.customApiUrl === '') {
            rapiServer = this._globalInitData.customApiUrl;
        }
        const request = new Request(rapiServer + url, requestData);
        this._globalCallback.onNetworkRequest(url, requestData, options);
        const externalData = await this._globalCallback.onCheckExternalCache(url, requestData);
        if (externalData) {
            return {
                headers: {
                    get: () => 'application/json',
                },
                json: () => Promise.resolve(externalData),
            };
        }
        return this._networkLayer.fetch(request, {}, {
            checkResponse: (response) => this._globalCallback.onValidateNetworkResponse('rapi-access', response),
        });
    }
    _createHeaders(options = {}) {
        const headersToAttach = { ...headers };
        if (this._globalInitData.overrideTenant) {
            headersToAttach.currentTenant = this._globalInitData.overrideTenant;
        }
        if (this._globalInitData.overrideCountry) {
            headersToAttach.country = this._globalInitData.overrideCountry;
        }
        const locale = this._globalInitData.locale || 'en';
        headersToAttach.language = locale;
        headersToAttach.locale = locale;
        const { contentType, accept, additionalHeaders, data } = options;
        if (contentType) {
            headersToAttach['content-type'] = options.contentType;
        }
        if (accept) {
            headersToAttach.accept = options.accept;
        }
        if (additionalHeaders) {
            for (let header in additionalHeaders) {
                if (additionalHeaders.hasOwnProperty(header)) {
                    headersToAttach[header] = additionalHeaders[header];
                }
            }
        }
        if (this._globalInitData.configuratorId) {
            headersToAttach.configurator = this._globalInitData.configuratorId;
        }
        const token = this._currentToken || TOKEN_IDENTIFIER;
        headersToAttach.token =
            '03-' +
                window.btoa(new Date().toISOString() + ';' + token + ';' + headers.apiKey);
        const headersObj = new Headers(headersToAttach);
        if (data instanceof FormData) {
            headersObj.delete('content-type');
        }
        return headersObj;
    }
    _handleJson(url, rapiPath, options = {}) {
        return (json) => {
            let data = null;
            let usedKey = null;
            // Tenants Me call only returns a number :-p
            if (typeof json === 'number') {
                data = json;
            }
            for (let key in json) {
                if (key !== 'meta' && json.hasOwnProperty(key)) {
                    data = json[key];
                    usedKey = key;
                }
            }
            if (usedKey === 'error') {
                return this._handleError(url, options)(new Error(JSON.stringify(data)));
            }
            if (!data) {
                throw new TypeError('RAPI returned empty JSON');
            }
            if (Array.isArray(data)) {
                for (let i = 0, length = data.length; i < length; i++) {
                    this._prepareData(data[i], rapiPath, options);
                    this._prepareEmbeddedData(data[i], rapiPath, options);
                }
            }
            else {
                this._prepareData(data, rapiPath, options);
                this._prepareEmbeddedData(data, rapiPath, options);
            }
            if (options.resolve) {
                options.resolve(data);
            }
            else {
                this._notifyWaiters(url, null, data);
            }
        };
    }
    _prepareEmbeddedData(data, rapiPath, options = {}) {
        if (!options.embed || !Array.isArray(options.embed)) {
            return;
        }
        options.embed.forEach((embedRapiPath) => {
            const embedData = data[embedRapiPath.slice(0, -1) + 'Objects'];
            if (Array.isArray(embedData)) {
                for (let i = 0, length = embedData.length; i < length; i++) {
                    this._prepareData(embedData[i], embedRapiPath, options);
                }
                this._prepareRelationalData(rapiPath, embedRapiPath, data.id, embedData);
            }
            else if (embedData) {
                this._prepareData(embedData, embedRapiPath, options);
                this._prepareRelationalData(rapiPath, embedRapiPath, data.id, [
                    embedData,
                ]);
            }
        });
    }
    _getCache(rapiPath) {
        return this._getCacheFrom(rapiPath, RAPI_CACHE);
    }
    _getErrorCache(rapiPath) {
        return this._getCacheFrom(rapiPath, RAPI_ERROR_CACHE);
    }
    _getCacheFrom(rapiPath, completeCache) {
        let cache = completeCache.get(rapiPath);
        if (!cache) {
            completeCache.set(rapiPath, new Map());
            cache = completeCache.get(rapiPath);
        }
        return cache;
    }
    _setCache(id, data, cache) {
        cache.set(id.toString(), data);
    }
    _prepareData(data, rapiPath, options = null) {
        let cache = this._getCache(rapiPath);
        const cacheId = options && options.cacheKey ? data[options.cacheKey] : data.id;
        if (!cacheId &&
            (!options || !options.id) &&
            rapiPath !== "tenants/me" /* RAPI_PATHS.TENANT_ME */) {
            if (rapiPath !== "shortIds" /* RAPI_PATHS.SHORT_IDS */) {
                console.error('Can not cache because there is no ID!');
            }
            return;
        }
        if (rapiPath !== "tenants/me" /* RAPI_PATHS.TENANT_ME */) {
            const id = cacheId ? cacheId : options.id;
            this._setCache(id, data, cache);
        }
        else {
            // as any because RAPI returns in this case only a number...
            this._setCache(TENANT_ME_CACHE_KEY, data, cache);
            return; // do not prepare data since its only a number... IDK why rapi sends only a number in this case
        }
        data[RAPI_PATH_KEY] = rapiPath;
    }
    _getRelationsCacheFor(id, rapiType, relationType) {
        let relationCache = RAPI_RELATIONS_CACHE.get(rapiType);
        if (!relationCache) {
            const emptyElementRelations = new Map();
            const emptyTextureRelation = new Map();
            emptyTextureRelation.set(relationType, undefined);
            emptyElementRelations.set(id, emptyTextureRelation);
            RAPI_RELATIONS_CACHE.set(rapiType, emptyElementRelations);
            relationCache = RAPI_RELATIONS_CACHE.get(rapiType);
        }
        let relationCacheItem = relationCache.get(id);
        if (!relationCacheItem) {
            const emptyTextureRelation = new Map();
            emptyTextureRelation.set(relationType, undefined);
            relationCache.set(id, emptyTextureRelation);
            relationCacheItem = relationCache.get(id);
        }
        return relationCacheItem.get(relationType);
    }
    _prepareGroups(material) {
        const groupId = material.group;
        const materialId = material.id;
        let cachedMaterialGroup = getCachedMaterialGroup(groupId);
        if (!cachedMaterialGroup) {
            RAPI_MATERIAL_GROUP_CACHE.set(groupId, []);
            cachedMaterialGroup = getCachedMaterialGroup(groupId);
        }
        if (cachedMaterialGroup.indexOf(materialId.toString()) === -1) {
            cachedMaterialGroup.push(materialId.toString());
        }
    }
    _handleError(url, options = {}) {
        return (error) => {
            if (!navigator.onLine) {
                error.rmlErrorCode = 0 /* ERROR_CODES.OFFLINE */;
                error.message =
                    'Failed to load  "' + url + '" because of "' + error.message + '"';
                this._errorHandler.dispatch(0 /* ERROR_CODES.OFFLINE */, [error]);
            }
            else {
                error.rmlErrorCode = 1 /* ERROR_CODES.GENERIC_RAPI_ERROR */;
                error.message =
                    'Failed to load  "' + url + '" because of "' + error.message + '"';
                this._errorHandler.dispatch(1 /* ERROR_CODES.GENERIC_RAPI_ERROR */, [error]);
            }
            if (options.reject) {
                options.reject(error);
            }
            else {
                this._notifyWaiters(url, error, null);
            }
        };
    }
    _getRelationData(rapiJson, relation, options = {}) {
        const id = rapiJson.id;
        if (!id) {
            // if we pass in a material from Rubens Admin while it's not
            // saved it can happen that material has no ID
            return Promise.resolve([]);
        }
        const rapiType = rapiJson[RAPI_PATH_KEY];
        const relationRapiPath = relation.rapiPath;
        let cache = this._getCache(relationRapiPath);
        let cachedIds = this._getRelationsCacheFor(id.toString(), rapiType, relationRapiPath);
        let relationAllData = [];
        if (cachedIds) {
            cachedIds.forEach((cachedId) => relationAllData.push(cache.get(cachedId)));
            return new Promise((resolve) => resolve(relationAllData));
        }
        if (!navigator.onLine) {
            return Promise.resolve([]);
        }
        return new Promise((resolve, reject) => {
            this._get('/' + rapiType + '/' + id + '/' + relationRapiPath, relationRapiPath, options).then((relationDataFromRapi) => {
                this._prepareRelationalData(rapiType, relationRapiPath, id, relationDataFromRapi);
                resolve(relationDataFromRapi);
            }, reject);
        });
    }
    _prepareRelationalData(rapiPath, relationRapiPath, id, relationData) {
        if (!RAPI_RELATIONS_CACHE.has(rapiPath)) {
            RAPI_RELATIONS_CACHE.set(rapiPath, new Map());
        }
        let relationCache = RAPI_RELATIONS_CACHE.get(rapiPath);
        const idString = id.toString();
        if (!relationCache.has(idString)) {
            relationCache.set(idString, new Map());
        }
        let relationCacheItem = relationCache.get(idString);
        let dataCache = this._getCache(relationRapiPath);
        let actualCachedIds = [];
        for (let i = 0, length = relationData.length; i < length; i++) {
            const relationEntry = relationData[i];
            const dataId = relationEntry.id;
            const idToUse = dataId.toString();
            actualCachedIds.push(idToUse);
            dataCache.set(idToUse, relationEntry);
        }
        relationCacheItem.set(relationRapiPath, actualCachedIds);
    }
    _notifyWaiters(url, error, data) {
        const waiters = WAITERS_FOR_URL.get(url);
        if (!waiters || !waiters.length) {
            return;
        }
        for (let i = 0, length = waiters.length; i < length; i++) {
            if (error) {
                waiters[i].reject(error);
            }
            else {
                waiters[i].resolve(data);
            }
        }
        WAITERS_FOR_URL.delete(url);
    }
    _tenantMe() {
        return new Promise((resolvePromise, reject) => {
            const cache = this._getCache("tenants/me" /* RAPI_PATHS.TENANT_ME */);
            const tenantId = this._globalInitData.overrideTenant
                ? this._globalInitData.overrideTenant
                : cache.get(TENANT_ME_CACHE_KEY);
            if (tenantId) {
                // as any because rapi returns number and no json in this case
                return resolvePromise(tenantId);
            }
            this._fetchJson('/' + "tenants/me" /* RAPI_PATHS.TENANT_ME */, "tenants/me" /* RAPI_PATHS.TENANT_ME */, {
                // as any because rapi returns number and no json in this case
                resolve: (tenantIdFromRapi) => resolvePromise(tenantIdFromRapi),
                reject,
            });
        });
    }
    /**
     * Returns info about the tenant with the provided ID. If the ID is not set it tries to use the current tenant.
     * @param tenantId
     */
    async getTenant(tenantId) {
        if (!tenantId) {
            tenantId = await this._tenantMe();
        }
        return this._getById(tenantId.toString(), "tenants" /* RAPI_PATHS.TENANT */);
    }
    getCurrentSkin() {
        return this._tenantMe().then((tenantMeId) => this._getById(tenantMeId.toString(), "tenants" /* RAPI_PATHS.TENANT */).then((tenant) => this._getById(tenant.skin.toString(), "skins" /* RAPI_PATHS.SKIN */)));
    }
    getPrices(pricesIds) {
        return this._getByIds(pricesIds, "prices" /* RAPI_PATHS.PRICE */, {
            filterKey: 'priceIds',
            cacheKey: 'priceId',
        });
    }
    async getConfiguratorSettings(id) {
        const rapiData = await this._getById(id, "configurators" /* RAPI_PATHS.CONFIGURATORS */);
        if (!rapiData.allowedHosts) {
            rapiData.allowedHosts = [];
        }
        if (rapiData.allowedHosts && !Array.isArray(rapiData.allowedHosts)) {
            rapiData.allowedHosts = rapiData.allowedHosts.split(' ');
        }
        return rapiData;
    }
    sendUserAction(userAction) {
        return this._save('/' + "userActions" /* RAPI_PATHS.USER_ACTIONS */, { userAction }, "userActions" /* RAPI_PATHS.USER_ACTIONS */, {
            accept: 'application/json',
            contentType: 'application/json; charset=UTF-8',
        });
    }
    _share(id, email, type, rapiPath) {
        const url = '/' + rapiPath + '/' + id + '/shares';
        const data = new FormData();
        data.append('email', email);
        data.append('type', type.toString());
        return new Promise((resolve, reject) => {
            const params = {
                method: HTTP_VERBS.POST,
                data,
                resolve,
                reject,
            };
            params.accept = 'application/json';
            params.contentType = 'application/json; charset=UTF-8';
            this._fetch(url, params).then(params.resolve, params.reject);
        });
    }
    /**
     * Export a configuration or plansnapshot id into a given file format and send it via email
     * Shares a configuration id using email
     * @param id
     * @param email
     * @param type the email template to use
     */
    shareConfiguration(id, email, type) {
        return this._share(id, email, type, "configurations" /* RAPI_PATHS.CONFIGURATIONS */);
    }
    /**
     * Shares a sharePlanSnapshot id using email
     * @param id
     * @param email
     * @param type the email template to use
     */
    sharePlanSnapshot(id, email, type) {
        return this._share(id, email, type, "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */);
    }
    /**
     * Export a configuration id into a given file format and send it via email
     * @param id
     * @param email
     * @param fileFormat check API documentation for valid formats
     */
    export3D(id, email, fileFormat, options = {}) {
        const endpoint = isPlanSnapshotId(id)
            ? "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */
            : "configurations" /* RAPI_PATHS.CONFIGURATIONS */;
        const url = '/' + endpoint + '/' + id + '/3d-exports';
        const exportParams = {
            formats: [
                {
                    // eslint-disable-next-line
                    file_format: fileFormat,
                    // eslint-disable-next-line
                    pack_external_data: true,
                    ...options,
                },
            ],
        };
        const exportSettings = JSON.stringify(exportParams);
        const data = new FormData();
        data.append('email', email);
        data.append('settings', exportSettings);
        return new Promise((resolve, reject) => {
            const params = {
                method: HTTP_VERBS.POST,
                data,
                resolve,
                reject,
            };
            this._fetch(url, params).then(params.resolve, params.reject);
        });
    }
    async trackView(id) {
        if (this._itemLoaded || isDemoHostname(getHostname())) {
            return;
        }
        const { configuratorId } = this._globalInitData;
        const loadProductUserAction = {
            module: 3,
            action: 1,
            actionId: id,
            actionLabel: configuratorId,
        };
        await this.sendUserAction(loadProductUserAction);
        this._itemLoaded = true;
    }
    signinUser(email, passwordMD5) {
        return new Promise((resolve, reject) => {
            const params = {
                method: HTTP_VERBS.POST,
                accept: 'application/json',
                contentType: 'application/json; charset=UTF-8',
                data: JSON.stringify({
                    identification: email,
                    passwordMD5,
                }),
                cacheKey: 'token',
                resolve,
                reject,
            };
            const url = '/' + "auth" /* RAPI_PATHS.AUTH */ + '/signin';
            this._fetchJson(url, "auth" /* RAPI_PATHS.AUTH */, params);
        });
    }
    async signoutUser(token) {
        const lastCurrentToken = this._currentToken;
        if (lastCurrentToken !== token) {
            this.setCurrentToken(token);
        }
        await this._fetch('/' + "auth" /* RAPI_PATHS.AUTH */ + '/signout', {});
        if (lastCurrentToken && lastCurrentToken !== token) {
            this.setCurrentToken(lastCurrentToken);
        }
        else {
            this.removeCurrentToken();
        }
    }
    async savePlan(plan) {
        // Probably this logic POST vs PUT should happen in
        // the this._save method but this would change everything
        // in the SDK because until now we didn't have PUT at all
        // I think we should do this refactor in a separate MR
        const path = '/' + "plans" /* RAPI_PATHS.PLANS */;
        const url = plan.id ? path + '/' + plan.id : '/' + "plans" /* RAPI_PATHS.PLANS */;
        return this._save(url, { plan }, "plans" /* RAPI_PATHS.PLANS */, {
            method: plan.id ? HTTP_VERBS.PUT : HTTP_VERBS.POST,
            accept: 'application/json',
            contentType: 'application/json; charset=UTF-8',
        });
    }
    async savePlanSnapshot(planSnapshot) {
        const url = '/' + "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */;
        return this._save(url, { planSnapshot }, "planSnapshots" /* RAPI_PATHS.PLAN_SNAPSHOTS */, {
            accept: 'application/json',
            contentType: 'application/json; charset=UTF-8',
        });
    }
    setCurrentToken(token) {
        this._currentToken = token;
    }
    removeCurrentToken() {
        this._currentToken = null;
    }
    createNewPlan() {
        return {
            name: '',
            description: '',
            changeDate: new Date().toISOString(),
            created: new Date().toISOString(),
            draftId: null,
            thumbnail: 'data:image/png;base64,missing',
            planObjects: null,
            active: true,
            open: 0,
            planDirectory: 0,
            changed: 0,
            version: 2,
            floorLevel: 0,
            visibility: 9,
            user: null,
            tenant: null,
            assets: [],
            parent: null,
            setting: null,
        };
    }
}
__decorate([
    inject
], RapiAccess.prototype, "_formDataUtil", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_errorHandler", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_dataSyncer", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_networkLayer", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_localStorage", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_globalInitData", void 0);
__decorate([
    inject
], RapiAccess.prototype, "_globalCallback", void 0);

const DEBUG_BOUNDING_BOX = false;
const PULSE_DURATION = 1500;
const PULSE_LOOPS = 5;
function RoomleComponentFactoryInitializer () {
    class HRoomleComponent extends Object3D {
        static _generateOutline(geometryCube, translateBy) {
            let line = new LineSegments(new EdgesGeometry(geometryCube), new LineDashedMaterial({
                color: '#000000',
                dashSize: 0.03,
                gapSize: 0.01,
                linewidth: 1,
            }));
            line.translateOnAxis(translateBy, 1);
            line.userData.ignoreComponentRaycast = true;
            return line;
        }
        static cloneDockLine(line, boundingBox) {
            let clone = new LineSegments(line.geometry, line.material);
            clone.translateOnAxis(boundingBox.getCenter(new Vector3()), 1);
            clone.name = 'dockline';
            clone.layers.set(5 /* LAYER.PREVIEW */);
            clone.userData.ignoreComponentRaycast = true;
            return clone;
        }
        _setValues(id, position, eulerAngles, parentObjectId) {
            if (id) {
                this.runtimeId = id;
                this.name = id.toString();
            }
            if (position) {
                this.roomlePosition = Object.assign({}, position);
            }
            if (eulerAngles) {
                this.roomleRotation = Object.assign({}, eulerAngles);
            }
            if (parentObjectId) {
                this.parentObjectId = parentObjectId;
            }
        }
        constructor(id, position, roomleRotation, parentObjectId) {
            super();
            this._selected = false;
            this.geometryChanged = true;
            this.meshes = [];
            this.castShadow = false;
            this.receiveShadow = true;
            this._setValues(id, position, roomleRotation, parentObjectId);
        }
        get loadingMesh() {
            return this._loadingMesh;
        }
        get boundingBoxMesh() {
            return this._boundingBoxMesh;
        }
        get boundingBox() {
            return this._boundingBox;
        }
        set roomlePosition(position) {
            this._roomlePosition = position;
            if (position) {
                this.position.set(position.x / 1000, position.z / 1000, position.y / -1000);
            }
        }
        get roomlePosition() {
            return this._roomlePosition;
        }
        set roomleRotation(rotation) {
            this._roomleRotation = rotation;
            if (rotation) {
                this.rotation.set(rotation.x, rotation.z, -rotation.y);
            }
        }
        get roomleRotation() {
            return this._roomleRotation;
        }
        replaceMeshes(meshes) {
            // for (let i = this.meshes.length - 1; i >= 0; i--) {
            //     this.removeMesh(this.meshes[i]);
            // }
            this.removeAllMeshes();
            meshes.forEach((mesh) => {
                this.addMesh(new Mesh(mesh.geometry, mesh.material));
            });
        }
        addMesh(mesh, transform) {
            mesh.renderOrder = 2;
            mesh.userData.meshType = 0 /* MeshType.ROOMLE_MESH */;
            if (transform) {
                mesh.applyMatrix4(convertToThreeMatrix(transform));
            }
            this.add(mesh);
            this.meshes.push(mesh);
        }
        getMeshById(meshId) {
            return this.meshes.find((m) => m.userData.meshId === meshId);
        }
        removeMeshById(meshId) {
            const mesh = this.getMeshById(meshId);
            if (!mesh) {
                console.warn('Could not remove mesh with id ' + meshId, this.runtimeId, this.meshes);
                return;
            }
            this.removeMesh(mesh);
        }
        removeMesh(mesh) {
            const index = this.meshes.indexOf(mesh);
            this.remove(mesh);
            disposeMesh(mesh);
            if (index < 0) {
                return;
            }
            this.meshes.splice(index, 1);
        }
        removeAllMeshes(dispose = true) {
            this.meshes.forEach((mesh) => {
                this.remove(mesh);
                if (dispose) {
                    disposeMesh(mesh);
                }
            });
            this.meshes = [];
            this._removeLoadingMesh();
            this.remove(this._boundingBoxMesh);
            disposeMesh(this._boundingBoxMesh);
            this._boundingBoxMesh = null;
        }
        _hideAllMeshes() {
            this.meshes.forEach((mesh) => (mesh.visible = false));
        }
        _showAllMeshes() {
            this.meshes.forEach((mesh) => (mesh.visible = true));
        }
        select() {
            this._selected = true;
        }
        loading() {
            if (!this._kernelBoundingBox) {
                console.warn('Bounding box (box for measurements) for component ' +
                    this.runtimeId +
                    ' not set, can not show external mesh loading box!');
                return;
            }
            this._removeLoadingMesh();
            this._hideAllMeshes();
            const { x, y, z } = this._kernelBoundingBox.getSize(new Vector3());
            let geometry = new BoxGeometry(x, y, z);
            this._loadingMesh = new Mesh(geometry, MaterialCreator.createMeshStandardMaterial({
                transparent: true,
                opacity: PREVIEW_MATERIAL_OPACITY,
                color: new Color$1(PREVIEW_MATERIAL_COLOR),
            }));
            this._loadingMesh.name = 'loading mesh';
            this._loadingMesh.receiveShadow = false;
            this._loadingMesh.castShadow = false;
            this._loadingMesh.layers.set(5 /* LAYER.PREVIEW */);
            this._loadingMesh.translateOnAxis(this._kernelBoundingBox.getCenter(new Vector3()), 1);
            this._loadingMesh.renderOrder = 3;
            this.add(this._loadingMesh);
        }
        _removeLoadingMesh() {
            if (this._loadingMesh) {
                this.remove(this._loadingMesh);
                disposeMesh(this._loadingMesh);
                this._loadingMesh = null;
            }
        }
        loadingFinished() {
            this._removeLoadingMesh();
            this._showAllMeshes();
        }
        deselect() {
            this._selected = false;
        }
        hoverOn() {
            setCursor("pointer" /* CURSOR_STYLE.HOVER */);
        }
        hoverOff() {
            setCursor("default" /* CURSOR_STYLE.DEFAULT */);
        }
        removeFromParent() {
            if (this.parent) {
                this.parent.remove(this);
                this.removeAllMeshes();
            }
            return this;
        }
        computeBoundingBox(boxForMeasurements, useMeshes = false) {
            if (this._boundingBoxMesh) {
                this.remove(this._boundingBoxMesh);
            }
            if (!useMeshes &&
                boxForMeasurements &&
                boxForMeasurements.size.x === 0 &&
                boxForMeasurements.size.y === 0 &&
                boxForMeasurements.size.z === 0) {
                return;
            }
            let geometry;
            if (!boxForMeasurements || useMeshes) {
                this._boundingBox = new Box3();
                let v1 = new Vector3();
                this.meshes.forEach((mesh) => {
                    if (mesh.geometry instanceof BufferGeometry) {
                        let attribute = mesh.geometry.attributes
                            .position;
                        if (attribute !== undefined) {
                            for (let i = 0, l = attribute.count; i < l; i++) {
                                v1.fromBufferAttribute(attribute, i).applyMatrix4(mesh.matrix);
                                this._boundingBox.expandByPoint(v1);
                            }
                        }
                    }
                });
                this._kernelBoundingBox = this._boundingBox.clone();
                let width = this._boundingBox.max.x - this._boundingBox.min.x;
                let height = this._boundingBox.max.y - this._boundingBox.min.y;
                let depth = this._boundingBox.max.z - this._boundingBox.min.z;
                geometry = new BoxGeometry(width, height, depth);
            }
            else {
                this._kernelBoundingBox = kernelBoxToThreeBox(boxForMeasurements);
                this._boundingBox = this._kernelBoundingBox.clone();
                let { x, y, z } = this._boundingBox.getSize(new Vector3());
                geometry = new BoxGeometry(x, y, z);
            }
            this._boundingBoxMesh = new Mesh(geometry, MaterialCreator.createMeshStandardMaterial({
                color: '#FFFFFF',
                transparent: true,
                opacity: 0.0,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                visible: DEBUG_BOUNDING_BOX,
            }));
            this._boundingBoxMesh.name = 'bounding box mesh';
            // this.boundingBoxMesh.userData.ignoreComponentRaycast = true;
            let center = this._boundingBox.getCenter(new Vector3());
            this._boundingBoxMesh.position.add(center);
            this._boundingBoxMesh.layers.set(5 /* LAYER.PREVIEW */);
            this._boundingBoxMesh.renderOrder = 3;
            this._boundingBoxMesh.castShadow = false;
            this._boundingBoxMesh.receiveShadow = false;
            this.add(this._boundingBoxMesh);
            this._dockline = HRoomleComponent._generateOutline(geometry, center);
            this._dockline.name = 'bounding box outline';
            this._dockline.layers.set(5 /* LAYER.PREVIEW */);
            if (this._selected) {
                this.add(this._dockline);
            }
        }
        recursiveMeshes() {
            let recursiveMeshes = this.meshes.slice();
            this.children.forEach((children) => {
                if (children instanceof HRoomleComponent) {
                    recursiveMeshes.push(...children.recursiveMeshes());
                }
            });
            return recursiveMeshes;
        }
        isChild(componentId) {
            let isChild = false;
            this.children.forEach((children) => {
                if (children instanceof HRoomleComponent && !isChild) {
                    if (children.runtimeId === componentId) {
                        isChild = true;
                    }
                    else {
                        isChild = children.isChild(componentId);
                    }
                }
            });
            return isChild;
        }
        getKernelPosition(newParent) {
            let posInGlobal = this.parent.localToWorld(this.position);
            return convertToKernel(newParent.worldToLocal(posInGlobal));
        }
    }
    class HStaticComponent extends HRoomleComponent {
        constructor(id, glbUrl) {
            super(id, null, null, null);
            this.glbUrl = glbUrl;
        }
    }
    class HPreviewComponent extends HRoomleComponent {
        constructor(creator, id, position, eulerAngles, parentObjectId) {
            super(id, position, eulerAngles, parentObjectId);
            this._stringId = null;
            this.receivedPointAssociation = false;
            this.castShadow = false;
            this.receiveShadow = false;
            this._creator_ = creator;
        }
        get stringId() {
            if (this._stringId) {
                return this._stringId;
            }
            return this.runtimeId.toString();
        }
        addMesh(mesh, transform) {
            super.addMesh(mesh, transform);
            if (mesh.material instanceof MeshStandardMaterial) {
                mesh.material.opacity = DOCK_PREVIEW_MATERIAL_OPACITY;
                mesh.material.roughness = DOCK_PREVIEW_MATERIAL_ROUGHNESS;
                mesh.material.metalness = DOCK_PREVIEW_MATERIAL_METALNESS;
                mesh.material.color = new Color$1(this._initData.colors.PREVIEW_DOCKING_COLOR);
            }
            mesh.renderOrder = 1;
            mesh.castShadow = false;
            mesh.receiveShadow = false;
        }
        startPulsating() {
            var _a, _b;
            if ((_b = (_a = this._initData) === null || _a === void 0 ? void 0 : _a.featureFlags) === null || _b === void 0 ? void 0 : _b.pulsePreview) {
                for (const mesh of this.meshes) {
                    const start = { opacity: DOCK_PREVIEW_MATERIAL_OPACITY };
                    const end = { opacity: 0.3 };
                    new TWEEN.Tween(start)
                        .to(end, PULSE_DURATION)
                        .easing(TWEEN.Easing.Sinusoidal.In)
                        .onUpdate(() => {
                        mesh.material.opacity = start.opacity;
                    })
                        .yoyo(true)
                        .repeat(PULSE_LOOPS)
                        .start();
                }
            }
        }
        hoverOn() {
            this.remove(this._dockline);
            this.meshes.forEach(({ material }) => {
                material.opacity =
                    DOCK_PREVIEW_MATERIAL_OPACITY_HOVERED;
                material.roughness =
                    DOCK_PREVIEW_MATERIAL_ROUGHNESS;
                material.metalness =
                    DOCK_PREVIEW_MATERIAL_METALNESS;
                material.color = new Color$1(this._initData.colors.PREVIEW_DOCKING_COLOR);
            });
            setCursor("pointer" /* CURSOR_STYLE.HOVER */);
        }
        hoverOff() {
            this.add(this._dockline);
            this.meshes.forEach(({ material }) => {
                material.opacity =
                    DOCK_PREVIEW_MATERIAL_OPACITY;
                material.roughness =
                    DOCK_PREVIEW_MATERIAL_ROUGHNESS;
                material.metalness =
                    DOCK_PREVIEW_MATERIAL_METALNESS;
                material.color = new Color$1(this._initData.colors.PREVIEW_DOCKING_COLOR);
            });
            setCursor("default" /* CURSOR_STYLE.DEFAULT */);
        }
        clonePreview(numberOfDuplication) {
            const clone = new HPreviewComponent(this._creator_, this.runtimeId, this.roomlePosition, this.roomleRotation, this.parentObjectId);
            clone._stringId = this.runtimeId + '_' + numberOfDuplication;
            this.children.forEach((child) => {
                if (child instanceof Mesh &&
                    child.userData.meshType === 0 /* MeshType.ROOMLE_MESH */) {
                    clone.meshes.push(child.clone(true));
                }
            });
            clone.meshes.forEach((mesh) => {
                mesh.material = mesh.material.clone();
                mesh.geometry = mesh.geometry.clone();
                clone.add(mesh);
            });
            if (this._dockline) {
                // cannot use clone due to an issue: https://github.com/mrdoob/three.js/issues/15239
                // clone._dockline = this._dockline.clone(true);
                clone._dockline = HRoomleComponent.cloneDockLine(this._dockline, this._boundingBox);
            }
            if (this._boundingBoxMesh) {
                clone._boundingBoxMesh = this._boundingBoxMesh.clone(true);
            }
            if (this._boundingBox) {
                clone._boundingBox = this._boundingBox.clone();
            }
            return clone;
        }
        preparePreview() {
            this.add(this._dockline);
            this.add(this._boundingBoxMesh);
        }
    }
    __decorate([
        inject
    ], HPreviewComponent.prototype, "_initData", void 0);
    class HPreviewLineComponent extends HPreviewComponent {
        constructor(creator, id, position, eulerAngles, parentObjectId, receivedPointAssociation) {
            super(creator, id, position, eulerAngles, parentObjectId);
            if (receivedPointAssociation) {
                this._stringId = this.runtimeId + '_has_additional_dock_point_copy';
            }
        }
        set roomleLineFrom(lineFrom) {
            this._roomleLineFrom = lineFrom;
            this.lineFrom = convertToTHREE(lineFrom);
        }
        get roomleLineFrom() {
            return this._roomleLineFrom;
        }
        set roomleLineTo(lineTo) {
            this._roomleLineTo = lineTo;
            let vector = convertToTHREE(lineTo);
            if (vector.equals(this.lineFrom)) {
                console.warn('lineFrom and lineTo are equal!');
                vector.add(new Vector3(0, 0.01, 0));
            }
            this.lineTo = vector;
        }
        get roomleLineTo() {
            return this._roomleLineTo;
        }
        set roomlePositionFrom(positionFrom) {
            this._roomlePositionFrom = positionFrom;
            this.positionFrom = convertToTHREE(positionFrom);
        }
        get roomlePositionFrom() {
            return this._roomlePositionFrom;
        }
        set roomlePositionTo(positionTo) {
            this._roomlePositionTo = positionTo;
            let vector = convertToTHREE(positionTo);
            if (vector.equals(this.positionFrom)) {
                console.warn('positionFrom and positionTo are equal!');
                vector.add(new Vector3(0, 0.01, 0));
            }
            this.positionTo = vector;
        }
        get roomlePositionTo() {
            return this._roomlePositionTo;
        }
        addMesh(mesh, transform) {
            super.addMesh(mesh, transform);
            mesh.visible = false;
            mesh.renderOrder = 3;
        }
        hoverOn() {
            this._dockline.visible = true;
            setCursor("pointer" /* CURSOR_STYLE.HOVER */);
        }
        hoverOff() {
            this._dockline.visible = false;
            setCursor("default" /* CURSOR_STYLE.DEFAULT */);
        }
        preparePreview() {
            super.preparePreview();
            this._dockline.visible = false;
            let to = this.lineTo.clone();
            let from = this.lineFrom.clone();
            const lengthVector = new Vector3().subVectors(to, from);
            let length = lengthVector.length();
            let direction = lengthVector.normalize();
            let arrow = new ArrowHelper(direction, from);
            let edgeGeometry = new CylinderGeometry(0.01, 0.01, length, 16, 1);
            this.lineMesh = new Mesh(edgeGeometry, MaterialCreator.createMeshStandardMaterial({
                color: PREVIEW_MATERIAL_COLOR,
                transparent: true,
                opacity: PREVIEW_LINE_MATERIAL_OPACITY,
            }));
            this.lineMesh.name = 'line mesh';
            const arrowRotation = new Quaternion().setFromEuler(arrow.rotation);
            this.lineMesh.quaternion.multiply(arrowRotation);
            this.lineMesh.renderOrder = 1;
            let wantedLineMiddle = new Vector3()
                .addVectors(to, from)
                .multiplyScalar(0.5);
            this.lineMesh.position.copy(new Vector3().subVectors(wantedLineMiddle, this.position.clone()));
            this.add(this.lineMesh);
            let boundingCenter = this._boundingBox
                .getCenter(new Vector3())
                .applyEuler(this.docklineRotation);
            let offset = null;
            let radius = 0;
            let x = Math.abs(direction.x);
            let y = Math.abs(direction.y);
            let z = Math.abs(direction.z);
            if (x >= y && x >= z) {
                offset = new Vector3(boundingCenter.x, 0, 0);
                radius = Math.sqrt(boundingCenter.y * boundingCenter.y +
                    boundingCenter.z * boundingCenter.z);
            }
            else if (y >= x && y >= z) {
                offset = new Vector3(0, boundingCenter.y, 0);
                radius = Math.sqrt(boundingCenter.x * boundingCenter.x +
                    boundingCenter.z * boundingCenter.z);
            }
            else if (z >= y && z >= x) {
                offset = new Vector3(0, 0, boundingCenter.z);
                radius = Math.sqrt(boundingCenter.y * boundingCenter.y +
                    boundingCenter.x * boundingCenter.x);
            }
            radius = radius > 0 ? radius : 0.01;
            let boundingLineLength = new Vector3()
                .subVectors(this.positionTo.clone(), this.positionFrom.clone())
                .length() + offset.length();
            let geometry = new CylinderGeometry(radius * 1.1, radius * 1.1, boundingLineLength, 32, 1);
            this.boundingLineMesh = new Mesh(geometry, MaterialCreator.createMeshStandardMaterial({
                color: '#ffffff',
                transparent: true,
                opacity: 0,
            }));
            this.boundingLineMesh.name = 'bounding line mesh';
            this.boundingLineMesh.userData.ignoreComponentRaycast = true;
            this.boundingLineMesh.layers.set(5 /* LAYER.PREVIEW */);
            let positionTo = this.positionTo.clone();
            let positionFrom = this.positionFrom.clone();
            let positionDirection = new Vector3()
                .subVectors(positionTo, positionFrom)
                .normalize();
            let positionArrow = new ArrowHelper(positionDirection, positionFrom);
            const positionArrowRotation = new Quaternion().setFromEuler(positionArrow.rotation);
            this.boundingLineMesh.quaternion.multiply(positionArrowRotation);
            this.boundingLineMesh.renderOrder = 3;
            let wantedBoundingLineMiddle = new Vector3()
                .addVectors(this.positionTo.clone(), this.positionFrom.clone())
                .multiplyScalar(0.5)
                .add(boundingCenter);
            this.boundingLineMesh.position.copy(new Vector3().subVectors(wantedBoundingLineMiddle, this.position.clone()));
            this.add(this.boundingLineMesh);
        }
        clonePreviewLine(numberOfDuplication) {
            let clone = new HPreviewLineComponent(this._creator_, this.runtimeId, this.roomlePosition, this.roomleRotation, this.parentObjectId, this.receivedPointAssociation);
            clone._stringId = this.runtimeId + '_' + numberOfDuplication;
            this.children.forEach((child) => {
                if (child instanceof Mesh &&
                    child.userData.meshType === 0 /* MeshType.ROOMLE_MESH */) {
                    clone.meshes.push(child.clone(true));
                }
            });
            clone.meshes.forEach((mesh) => {
                mesh.material = mesh.material.clone();
                mesh.geometry = mesh.geometry.clone();
                clone.add(mesh);
            });
            if (this._dockline) {
                // cannot use clone due to an issue: https://github.com/mrdoob/three.js/issues/15239
                // clone._dockline = this._dockline.clone(true);
                clone._dockline = HRoomleComponent.cloneDockLine(this._dockline, this._boundingBox);
            }
            if (this._boundingBoxMesh) {
                clone._boundingBoxMesh = this._boundingBoxMesh.clone(true);
            }
            if (this._boundingBox) {
                clone._boundingBox = this._boundingBox.clone();
            }
            return clone;
        }
        getPositionForIntersectionPoint(intersectionPoint) {
            let boundingCenter = this._boundingBox
                .getCenter(new Vector3())
                .applyEuler(this.docklineRotation);
            let to = this.positionTo.clone().add(boundingCenter);
            let from = this.positionFrom.clone().add(boundingCenter);
            let line = new Line3(from, to);
            let closestPointToPoint = line.closestPointToPoint(intersectionPoint, true, new Vector3());
            if (isNaN(closestPointToPoint.x) ||
                isNaN(closestPointToPoint.y) ||
                isNaN(closestPointToPoint.z)) {
                closestPointToPoint.copy(intersectionPoint);
            }
            return closestPointToPoint.sub(boundingCenter);
        }
        updatePreviewPosition(intersectionPoint) {
            let rootComponentPoint = this.getPositionForIntersectionPoint(intersectionPoint);
            let worldPoint = this.parent.localToWorld(rootComponentPoint);
            this._newPosition = this.worldToLocal(worldPoint);
            let boundingCenter = this._boundingBox
                .getCenter(new Vector3())
                .applyEuler(this.docklineRotation);
            this._dockline.position.copy(new Vector3().addVectors(this._newPosition, boundingCenter));
            this._dockline.rotation.copy(this.docklineRotation);
        }
        hideSelectionLine() {
            this._dockline.visible = false;
        }
        getKernelPosition(newParent) {
            if (this._newPosition) {
                let posInGlobal = this.localToWorld(this._newPosition);
                return convertToKernel(newParent.worldToLocal(posInGlobal));
            }
            return super.getKernelPosition(newParent);
        }
    }
    class HOrthographicOffsetCamera extends OrthographicCamera {
        constructor(left, right, top, bottom, near, far, offset) {
            super(left, right, top, bottom, near, far);
            if (!offset) {
                offset = { left: 0, top: 1, right: 1, bottom: 0 };
            }
            this.offset = offset;
        }
        set offset(offset) {
            this._offset = offset;
            this.updateProjectionMatrix();
        }
        get offset() {
            return this._offset;
        }
        resetOffset() {
            this._offset = { left: 0, top: 1, right: 1, bottom: 0 };
        }
        updateProjectionMatrix() {
            if (this._offset) {
                this.projectionMatrix = this._calculateProjectionMatrix();
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            else {
                super.updateProjectionMatrix();
            }
        }
        _calculateProjectionMatrix() {
            const planes2D = this._calculate2DPlanes();
            if (this._offset.left >= this._offset.right ||
                this._offset.bottom > this._offset.top) {
                return new Matrix4().makeOrthographic(planes2D.left, planes2D.right, planes2D.top, planes2D.bottom, this.near, this.far);
            }
            const widthRange = this._scaleRange(planes2D.left, planes2D.right, this._offset.left, this._offset.right);
            let left = widthRange.from;
            let right = widthRange.to;
            const heightRange = this._scaleRange(planes2D.bottom, planes2D.top, this._offset.bottom, this._offset.top);
            let bottom = heightRange.from;
            let top = heightRange.to;
            const originalAspect = (planes2D.right - planes2D.left) / (planes2D.top - planes2D.bottom);
            const newAspect = (right - left) / (top - bottom);
            if (newAspect > originalAspect) {
                const center = (bottom + top) / 2;
                const size = ((top - bottom) * newAspect) / originalAspect;
                bottom = center - size / 2;
                top = center + size / 2;
            }
            else {
                const center = (left + right) / 2;
                const size = ((right - left) * originalAspect) / newAspect;
                left = center - size / 2;
                right = center + size / 2;
            }
            return new Matrix4().makeOrthographic(left, right, top, bottom, this.near, this.far);
        }
        _scaleRange(from, to, offsetFrom, offsetTo) {
            const distance = to - from;
            const newDistance = distance / (offsetTo - offsetFrom);
            const scaledFrom = from - newDistance * offsetFrom;
            const scaledTo = to + newDistance * (1 - offsetTo);
            return { from: scaledFrom, to: scaledTo };
        }
        _calculate2DPlanes() {
            // this implementation is copied from OrthographicCamera.updateProjectionMatrix
            const dx = (this.right - this.left) / (2 * this.zoom);
            const dy = (this.top - this.bottom) / (2 * this.zoom);
            const cx = (this.right + this.left) / 2;
            const cy = (this.top + this.bottom) / 2;
            let left = cx - dx;
            let right = cx + dx;
            let top = cy + dy;
            let bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                left += scaleW * this.view.offsetX;
                right = left + scaleW * this.view.width;
                top -= scaleH * this.view.offsetY;
                bottom = top - scaleH * this.view.height;
            }
            return { left, right, top, bottom };
        }
    }
    class HPerspectiveOffsetCamera extends PerspectiveCamera {
        constructor(fov, aspect, near, far, offset) {
            super(fov, aspect, near, far);
            if (!offset) {
                offset = { left: 0, top: 1, right: 1, bottom: 0 };
            }
            this.offset = offset;
        }
        copy(camera, recursive) {
            super.copy(camera, recursive);
            this._offset = camera._offset;
            return this;
        }
        set offset(offset) {
            this._offset = offset;
            this.updateProjectionMatrix();
        }
        get offset() {
            return this._offset;
        }
        resetOffset() {
            this._offset = { left: 0, top: 1, right: 1, bottom: 0 };
        }
        _calculateProjectionMatrix() {
            let fovVerticalOriginal = (this.fov * ((Math.PI * 2) / 360)) / 2;
            let leftAbs;
            let rightAbs;
            let topAbs;
            let bottomAbs;
            topAbs = Math.tan(fovVerticalOriginal);
            bottomAbs = -topAbs;
            let fovHorzontalOriginal = Math.atan(this.aspect * Math.tan(fovVerticalOriginal));
            rightAbs = Math.tan(fovHorzontalOriginal);
            leftAbs = -rightAbs;
            let rLeft = this._offset.left;
            let rRight = this._offset.right;
            let rTop = this._offset.top;
            let rBottom = this._offset.bottom;
            let size = new Vector2(rRight - rLeft, rTop - rBottom);
            let center = new Vector2(rLeft + size.x / 2, rBottom + size.y / 2);
            if (size.x < size.y) {
                let factorR = (1 - center.x) / (size.x / 2);
                let factorL = center.x / (size.x / 2);
                rightAbs *= factorR;
                leftAbs *= factorL;
                let factorV = (factorR + factorL) / 2;
                topAbs *= factorV;
                bottomAbs *= factorV;
            }
            else {
                let factorT = (1 - center.y) / (size.y / 2);
                let factorB = center.y / (size.y / 2);
                topAbs *= factorT;
                bottomAbs *= factorB;
                let factorH = (factorB + factorT) / 2;
                leftAbs *= factorH;
                rightAbs *= factorH;
            }
            leftAbs *= this.near;
            rightAbs *= this.near;
            topAbs *= this.near;
            bottomAbs *= this.near;
            let top = (this.near * Math.tan((Math.PI / 180) * 0.5 * this.fov)) / this.zoom;
            let height = 2 * top;
            let width = this.aspect * height;
            if (this.view && this.view.enabled) {
                leftAbs += (this.view.offsetX * width) / this.view.fullWidth;
                topAbs -= (this.view.offsetY * height) / this.view.fullHeight;
                rightAbs += (this.view.offsetX * width) / this.view.fullWidth;
                bottomAbs -= (this.view.offsetY * height) / this.view.fullHeight;
            }
            return new Matrix4().makePerspective(leftAbs, rightAbs, topAbs, bottomAbs, this.near, this.far);
        }
        clearViewOffset() {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
            if (this._offset) {
                this.projectionMatrix = this._calculateProjectionMatrix();
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
            }
            else {
                super.updateProjectionMatrix();
            }
        }
    }
    function create(id, position, rotation, parentObjectId) {
        return new HRoomleComponent(id, position, rotation, parentObjectId);
    }
    function createStatic(id, url) {
        return new HStaticComponent(id, url);
    }
    function createPreview(id, parentObjectId, creator) {
        return new HPreviewComponent(creator, id, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, parentObjectId);
    }
    function createPreviewLine(previewComponent, creator) {
        let previewLineComponent = new HPreviewLineComponent(creator, previewComponent.id, previewComponent.roomlePosition, previewComponent.roomleRotation, previewComponent.parentObjectId, previewComponent.receivedPointAssociation);
        previewComponent.meshes.forEach((mesh) => {
            let meshClone = mesh.clone();
            meshClone.material = mesh.material.clone();
            meshClone.geometry = mesh.geometry.clone();
            previewLineComponent.addMesh(meshClone);
        });
        previewLineComponent.computeBoundingBox();
        return previewLineComponent;
    }
    function createOrthographicCamera(left, right, top, bottom, near, far, offset) {
        return new HOrthographicOffsetCamera(left, right, top, bottom, near, far, offset);
    }
    function createPerspectiveCamera(fov, aspect, near, far, offset) {
        return new HPerspectiveOffsetCamera(fov, aspect, near, far, offset);
    }
    function isPreview(obj) {
        return obj instanceof HPreviewComponent;
    }
    function isPreviewLine(obj) {
        return obj instanceof HPreviewLineComponent;
    }
    return {
        create,
        createPreview,
        createStatic,
        createPreviewLine,
        isPreview,
        isPreviewLine,
        createPerspectiveCamera,
        createOrthographicCamera,
    };
}

const DOCKING_CONVERSATION_ID = 10;
const DEFAULT_CONVERSATION_ID = 9;
class ConfiguratorViewModel {
    constructor(creator) {
        this._mergeThreshold = 3;
        this._componentsToMerge = new OccurrenceMap();
        this._mergeInProgress = false;
        this._components = new Map();
        this._previews = new Map();
        this._componentNumberOfPossibleChildren = new Map();
        this._creator_ = creator;
        this._getKernelAccess().addConfiguratorListener(this);
        this._componentFactory = RoomleComponentFactoryInitializer();
    }
    get materialQueue() {
        return this.getMeshGenerator().materialQueue;
    }
    _getKernelAccess() {
        return RoomleDependencyInjection.lookup('planner-kernel-access', this._creator_);
    }
    _applyMeshTransform(mesh, userData, transform, uvTransform, originalGeometry) {
        if (transform) {
            const transformMatrix = (mesh.userData.transform =
                convertToThreeMatrix(transform));
            if (userData) {
                mesh.userData.transform = transformMatrix;
            }
            mesh.applyMatrix4(transformMatrix);
        }
        this._applyMeshUVTransform(mesh, userData, uvTransform, originalGeometry);
    }
    _applyMeshUVTransform(mesh, userData, uvTransform, originalGeometry) {
        if ((uvTransform === null || uvTransform === void 0 ? void 0 : uvTransform.length) === 6 && !isUVIdentityMatrix(uvTransform)) {
            // the new UV transformation is not the identity matrix
            const uvTransformMatrix = convertToThreeUVMatrix(uvTransform);
            if (userData) {
                userData.uvTransform = uvTransformMatrix;
            }
            const bufferGeometry = originalGeometry !== null && originalGeometry !== void 0 ? originalGeometry : mesh.geometry;
            if (bufferGeometry && bufferGeometry.attributes.uv) {
                const newBufferGeometry = bufferGeometry.clone();
                const bufferAttribute = newBufferGeometry.attributes
                    .uv;
                bufferAttribute.applyMatrix4(uvTransformMatrix);
                mesh.geometry = newBufferGeometry;
            }
        }
        else {
            if (userData) {
                userData.uvTransform = undefined;
            }
            if (originalGeometry) {
                mesh.geometry = originalGeometry;
            }
        }
    }
    _addMeshToSubPart(runtimeComponentId, meshId, materialId, transform, uvTransform, vertices, indices, uvCoords, normals, materialAttributes) {
        const mesh = this._generateMesh(runtimeComponentId, meshId, materialId, vertices, indices, uvCoords, normals, undefined, undefined, materialAttributes);
        this._applyMeshTransform(mesh, null, transform, uvTransform);
        this._subPartObject.add(mesh);
    }
    _addMeshToComponent(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, vertices, indices, uvCoords, normals, _environmentGeometry, materialAttributes) {
        if (this._subPartGuard && this._subPartGuard.info === runtimeComponentId) {
            this._addMeshToSubPart(runtimeComponentId, null, materialId, null, null, vertices, indices, uvCoords, normals, materialAttributes);
            return;
        }
        const runtimeComponent = this.getComponent(runtimeComponentId);
        if (!runtimeComponent) {
            return;
        }
        const isPreview = this._componentFactory.isPreview(runtimeComponent);
        const mesh = this._generateMesh(runtimeComponentId, geometryId, isPreview ? null : materialId, vertices, indices, uvCoords, normals, undefined, undefined, materialAttributes);
        mesh.userData.meshId = meshId;
        mesh.userData.geometryId = geometryId;
        mesh.userData.materialId = materialId;
        this._applyMeshTransform(mesh, mesh.userData, transform, uvTransform);
        if (isPreview) {
            mesh.layers.set(5 /* LAYER.PREVIEW */);
        }
        // three-refactor
        // LAYER.OBJECT would help to create the baked ground shadow in planner
        // however, this will break the selection
        //mesh.layers.set(isPreview ? LAYER.PREVIEW : LAYER.OBJECT);
        if (runtimeComponent) {
            runtimeComponent.addMesh(mesh);
        }
        if (runtimeComponent.meshes.length > this._mergeThreshold) {
            this._componentsToMerge.set(runtimeComponentId, runtimeComponent.meshes.length);
        }
    }
    _changeMeshOfComponent(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, materialAttributes) {
        const runtimeComponent = this.getComponent(runtimeComponentId);
        if (!runtimeComponent) {
            return;
        }
        const mesh = runtimeComponent.getMeshById(meshId);
        if (mesh) {
            if (mesh.userData.geometryId !== geometryId) {
                console.warn('Geometry of mesh has changed!');
            }
            // set the material id before we set the material
            // so we know if we are setting the right material after it's loaded from the network
            mesh.userData.materialId = materialId;
            mesh.userData.materialAttributes = materialAttributes;
            const oldMaterial = mesh.material.clone();
            this._configuratorMeshGenerator
                .setMaterial(mesh, materialId, undefined, materialAttributes)
                .then(() => {
                if (this._requestRenderSceneUpdateCallback) {
                    this._requestRenderSceneUpdateCallback();
                }
            });
            if (oldMaterial.opacity !== mesh.material.opacity &&
                this._requestRenderCallback) {
                this._requestRenderCallback();
            }
            if (transform) {
                //reset mesh before applying new transform matrix
                mesh.position.set(0, 0, 0);
                mesh.scale.set(1, 1, 1);
                mesh.rotation.set(0, 0, 0);
            }
            const originalGeometry = this._configuratorMeshGenerator.getGeometry(geometryId);
            this._applyMeshTransform(mesh, mesh.userData, transform, uvTransform, originalGeometry);
        }
    }
    _removeMeshFromComponent(runtimeComponentId, meshId) {
        const runtimeComponent = this.getComponent(runtimeComponentId);
        if (runtimeComponent) {
            runtimeComponent.removeMeshById(meshId);
        }
    }
    getComponent(componentId) {
        let runtimeComponent = this._components.get(componentId);
        if (!runtimeComponent) {
            runtimeComponent = this._previews.get(componentId.toString());
            if (!runtimeComponent) {
                console.warn('component not found!', componentId);
                return null;
            }
        }
        return runtimeComponent;
    }
    getNumberOfPossibleChildrenForComponent(componentId) {
        if (this._componentNumberOfPossibleChildren.has(componentId)) {
            return this._componentNumberOfPossibleChildren.get(componentId);
        }
        const numberOfPossibleChildren = this._getKernelAccess().kernelInstance.getPlanComponentPossibleChildren(componentId).length;
        this._componentNumberOfPossibleChildren.set(componentId, numberOfPossibleChildren);
        return numberOfPossibleChildren;
    }
    tryToMergeComponents() {
        if (this._initData.moc) {
            return;
        }
        if (!this._mergeInProgress) {
            this._mergeInProgress = true;
            console.log('start merging geometries', this._componentsToMerge.size);
            this._requestMergeComponents();
        }
    }
    _requestMergeComponents() {
        window.requestIdleCallback(this._mergeNextComponent.bind(this));
    }
    _mergeNextComponent() {
        if (this._componentsToMerge.size > 0) {
            const componentId = this._componentsToMerge.largestValue();
            this._componentsToMerge.delete(componentId);
            this._mergeComponent(componentId);
            this._requestMergeComponents();
        }
        else {
            this._mergeInProgress = false;
            if (this._geometriesMerged) {
                this._geometriesMerged();
            }
            console.log('finished merging geometries');
            this._components.forEach((component) => {
                if (component.loadingMesh) {
                    console.warn('component still has loading mesh: ', component.hash);
                }
            });
        }
    }
    _mergeComponent(componentId) {
        const roomleComponent = this._components.get(componentId);
        //only merge meshes when more than <threshold> are present, this saves memory because geometries can be reused then
        if (!roomleComponent ||
            roomleComponent.meshes.length <= this._mergeThreshold) {
            return;
        }
        if (this._cacheHolder.componentCache.has(roomleComponent.hash)) {
            const meshes = this._cacheHolder.componentCache.get(roomleComponent.hash).meshes;
            roomleComponent.replaceMeshes(meshes);
        }
        else {
            const uniqueMaterialMeshes = new Map();
            const meshesToAdd = [];
            const meshesToRemove = [];
            roomleComponent.meshes.forEach((mesh) => {
                const materialId = mesh.userData.materialId;
                if (!materialId) {
                    console.warn('mesh has no material id set');
                    return;
                }
                if (!uniqueMaterialMeshes.has(materialId)) {
                    const newMesh = new Mesh(new BufferGeometry(), mesh.material);
                    newMesh.userData.materialId = materialId;
                    newMesh.receiveShadow = true;
                    newMesh.castShadow = true;
                    newMesh.layers.set(3 /* LAYER.OBJECT */);
                    this._setMaterial(newMesh, materialId);
                    meshesToAdd.push(newMesh);
                    uniqueMaterialMeshes.set(materialId, newMesh);
                }
                const uniqueMesh = uniqueMaterialMeshes.get(materialId);
                const existingGeometry = uniqueMesh.geometry;
                if (mesh.userData.transform) {
                    mesh.geometry.applyMatrix4(mesh.userData.transform);
                }
                uniqueMesh.geometry = mergeGeometries([
                    existingGeometry,
                    mesh.geometry,
                ]);
                meshesToRemove.push(mesh);
            });
            meshesToAdd.forEach((componentMesh) => roomleComponent.addMesh(componentMesh));
            meshesToRemove.forEach((componentMesh) => roomleComponent.removeMesh(componentMesh));
            this._cacheHolder.componentCache.set(roomleComponent.hash, roomleComponent);
        }
    }
    _addRootComponent(component) {
        if (this._listener) {
            this._listener.display(component);
        }
    }
    removeDockingComponent() {
        this._getKernelAccess().requestDeleteComponent(this._configuratorContext.dockingRootComponentId);
        this._configuratorContext.dockingRootComponentId = null;
    }
    dockComponent(componentId, parentId, componentPosition, componentRotation) {
        let parentComponent = this._components.get(parentId);
        let runtimeComponent = this._components.get(componentId);
        if (!runtimeComponent) {
            return;
        }
        runtimeComponent.roomlePosition = componentPosition;
        runtimeComponent.roomleRotation = componentRotation;
        if (parentComponent) {
            parentComponent.add(runtimeComponent);
        }
    }
    dockComponentWithPosition(previewComponent, component) {
        let newParent = this._components.get(previewComponent.parentId);
        let position;
        if (component) {
            position = component.getKernelPosition(newParent);
        }
        else {
            position = previewComponent.getKernelPosition(newParent);
        }
        Benchmark.start('dock_component_with_position_' + previewComponent.childId);
        this._getKernelAccess().dockComponentWithPosition(previewComponent.parentId, previewComponent.parentDockId, previewComponent.childId, previewComponent.childDockId, position);
        this._configuratorContext.dockingRootComponentId = null; // Fix #126
    }
    removePreviews() {
        if (this._previews.size > 0) {
            this._previews.forEach((preview) => {
                preview.removeFromParent();
                preview.removeAllMeshes();
            });
            this._previews.clear();
        }
    }
    _updatePlanObject(planObject, pendingDocking) {
        const roomleComponent = this._components.get(planObject.rootPlanComponentId);
        let geometryChanged = true;
        if (roomleComponent) {
            geometryChanged = roomleComponent.geometryChanged;
        }
        if (this._listener) {
            this._listener.planObjectUpdated(planObject, geometryChanged, pendingDocking);
        }
    }
    Editor3dAddBakedMesh(runtimeComponentId, materialId, vertices, indices, uvCoords, normals, environmentGeometry, materialAttributes) {
        this._addMeshToComponent(runtimeComponentId, null, null, materialId, null, null, vertices, indices, uvCoords, normals, environmentGeometry, materialAttributes);
    }
    Editor3dAddDockPreview(componentId, previewId) {
        const previewComponent = this._componentFactory.createPreview(previewId, componentId, this._creator_); // TODO: don't know if componentId is correct as parentObjectId
        this._previews.set(previewId.toString(), previewComponent);
    }
    Editor3dAddNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, vertices, indices, uvCoords, normals, environmentGeometry, uvTransform, materialAttributes) {
        this._addMeshToComponent(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, vertices, indices, uvCoords, normals, environmentGeometry, materialAttributes);
    }
    Editor3ChangedNamedMesh(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, materialAttributes) {
        this._changeMeshOfComponent(runtimeComponentId, meshId, geometryId, materialId, transform, uvTransform, materialAttributes);
    }
    Editor3dRemoveNamedMesh(runtimeComponentId, meshId) {
        this._removeMeshFromComponent(runtimeComponentId, meshId);
    }
    Editor3dBeginConstruction(componentId, isDeltaUpdate) {
        if (!isDeltaUpdate) {
            const component = this._components.get(componentId);
            if (component) {
                component.removeAllMeshes();
            }
        }
        if (this._subPartGuard && componentId === this._subPartGuard.info) {
            this._subPartObject = new Object3D();
        }
    }
    Editor3dComponentCreated(id, position, eulerAngles, parentObjectRuntimeId, isRootComponent) {
        if (isRootComponent) {
            this._configuratorContext.rootComponentId = id;
        }
        let roomleComponent = null;
        if (this._components.has(id)) {
            roomleComponent = this._components.get(id);
            roomleComponent.removeAllMeshes();
        }
        else {
            roomleComponent = this._componentFactory.create(id, position, eulerAngles, parentObjectRuntimeId);
            roomleComponent.layers.set(3 /* LAYER.OBJECT */);
        }
        this._components.set(id, roomleComponent);
        if (isRootComponent) {
            this._addRootComponent(roomleComponent);
        }
    }
    Editor3dComponentDocked(componentId, parentId, componentPosition, componentRotation) {
        this.dockComponent(componentId, parentId, componentPosition, componentRotation);
    }
    Editor3dEndConstruction(id) {
        if (this._subPartGuard && this._subPartGuard.info === id) {
            this._subPartGuard.resolve(this._subPartObject);
            return;
        }
        const kernelComponent = this._getKernelAccess().kernelInstance.getComponent(id);
        const component = this._components.get(id);
        if (component) {
            component.computeBoundingBox(kernelComponent.boxForMeasurement);
            if (component.boundingBoxMesh && this._listener) {
                this._listener.addComponentHandlers(component);
            }
        }
        let preview = this._previews.get(id.toString());
        if (preview) {
            preview.computeBoundingBox(kernelComponent.boxForMeasurement, true);
        }
    }
    Editor3dGeometryReady(id) {
        const component = this._components.get(id);
        if (component) {
            component.loadingFinished();
        }
    }
    Editor3dGeometryNotReady(id) {
        const component = this._components.get(id);
        if (component) {
            component.loading();
        }
    }
    Editor3dPlanObjectConstructionDone(planObjectId) {
        const planObject = this._getKernelAccess().kernelInstance.getPlanObject(planObjectId);
        const partList = this._getKernelAccess().kernelInstance.getFullPartList();
        const hash = this._getKernelAccess().kernelInstance.getHashOfConfiguration(planObjectId);
        const rootComponentRapiId = this._getKernelAccess().kernelInstance.getComponentId(planObject.rootPlanComponentId);
        const params = [planObject, partList, hash, rootComponentRapiId];
        AsyncHelper.finishOperation(2 /* ASYNC_OPERATIONS.KERNEL_PLAN_OBJECT_CONSTRUCTION_DONE */, params);
        this._updatePlanObject(planObject, false);
        if (this._listener) {
            this._listener.planObjectConstructionDone(planObject);
        }
    }
    Editor3dPreviewConstructionDone(componentId, _objectId) {
        let hasPreviews = false;
        this._previews.forEach((preview) => {
            if (preview.parent !== null) {
                if (this._listener) {
                    if (this._componentFactory.isPreviewLine(preview)) {
                        this._listener.addPreviewLineHandlers(preview);
                    }
                    else {
                        this._listener.addPreviewHandlers(preview);
                    }
                }
                hasPreviews = true;
            }
        });
        if (this._listener) {
            this._listener.previewConstructionDone(this._components.get(componentId), hasPreviews);
        }
    }
    Editor3dSetPreviewLineAssociations(dockLines, previewId) {
        let previewComponent = this._previews.get(previewId.toString());
        previewComponent.clear();
        if (!previewComponent) {
            return;
        }
        let previewLineComponent = this._componentFactory.createPreviewLine(previewComponent, this._creator_);
        let rootComponent = this._components.get(this._configuratorContext.rootComponentId);
        for (let i = 0; i < dockLines.length; i++) {
            let clonedComponent;
            if (i === 0) {
                clonedComponent = previewLineComponent;
            }
            else {
                clonedComponent = previewLineComponent.clonePreviewLine(i);
            }
            clonedComponent.name = 'Preview Line';
            clonedComponent.parentDockId = dockLines[i].parentDockId;
            clonedComponent.parentId = dockLines[i].parentId;
            clonedComponent.childDockId = dockLines[i].childDockId;
            clonedComponent.childId = dockLines[i].childId;
            clonedComponent.docklineRotation = convertToEuler(dockLines[i].rotation);
            clonedComponent.roomlePosition = dockLines[i].position;
            // TODO: hack to fix negative docklines
            if (dockLines[i].lineFrom.x > dockLines[i].lineTo.x ||
                dockLines[i].lineFrom.y > dockLines[i].lineTo.y ||
                dockLines[i].lineFrom.z > dockLines[i].lineTo.z) {
                clonedComponent.roomleLineFrom = dockLines[i].lineTo;
                clonedComponent.roomleLineTo = dockLines[i].lineFrom;
            }
            else {
                clonedComponent.roomleLineFrom = dockLines[i].lineFrom;
                clonedComponent.roomleLineTo = dockLines[i].lineTo;
            }
            if (dockLines[i].positionFrom.x > dockLines[i].positionTo.x ||
                dockLines[i].positionFrom.y > dockLines[i].positionTo.y ||
                dockLines[i].positionFrom.z > dockLines[i].positionTo.z) {
                clonedComponent.roomlePositionFrom = dockLines[i].positionTo;
                clonedComponent.roomlePositionTo = dockLines[i].positionFrom;
            }
            else {
                clonedComponent.roomlePositionFrom = dockLines[i].positionFrom;
                clonedComponent.roomlePositionTo = dockLines[i].positionTo;
            }
            rootComponent.add(clonedComponent);
            clonedComponent.preparePreview();
            this._previews.set(clonedComponent.stringId, clonedComponent);
        }
    }
    Editor3dSetPreviewPointAssociations(dockPairs, previewId) {
        let previewComponent = this._previews.get(previewId.toString());
        if (!previewComponent) {
            return;
        }
        let rootComponent = this._components.get(this._configuratorContext.rootComponentId);
        for (let i = 0; i < dockPairs.length; i++) {
            let clonedComponent;
            if (i === 0) {
                clonedComponent = previewComponent;
            }
            else {
                clonedComponent = previewComponent.clonePreview(i);
                this._previews.set(clonedComponent.stringId, clonedComponent);
            }
            clonedComponent.name = 'Preview Point';
            clonedComponent.parentDockId = dockPairs[i].parentDockId;
            clonedComponent.parentId = dockPairs[i].parentId;
            clonedComponent.childDockId = dockPairs[i].childDockId;
            clonedComponent.childId = dockPairs[i].childId;
            clonedComponent.preparePreview();
            clonedComponent.receivedPointAssociation = true;
            clonedComponent.userData.ignoreComponentRaycast = true;
            rootComponent.add(clonedComponent);
            clonedComponent.roomlePosition = dockPairs[i].position;
            clonedComponent.roomleRotation = dockPairs[i].rotation;
            clonedComponent.startPulsating();
        }
    }
    componentDeleted(componentId) {
        const component = this._components.get(componentId);
        if (!component) {
            return;
        }
        if (this._listener) {
            this._listener.componentDeleted(component);
        }
        component.removeFromParent();
        component.removeAllMeshes();
        this._components.delete(componentId);
    }
    componentMetaUpdated(kernelComponent) {
        const runtimeComponent = this._getRuntimeComponent(kernelComponent.id);
        if (!runtimeComponent) {
            return;
        }
        runtimeComponent.hash = kernelComponent.hash;
        runtimeComponent.roomlePosition = kernelComponent.position;
        runtimeComponent.roomleRotation = kernelComponent.rotation;
        if (kernelComponent.boxForMeasurement) {
            runtimeComponent.computeBoundingBox(kernelComponent.boxForMeasurement);
        }
        if (this._listener) {
            this._listener.componentUpdated(runtimeComponent, kernelComponent);
        }
    }
    componentConfigurationUpdated(runtimeComponentId, geometryChanged) {
        const runtimeComponent = this._getRuntimeComponent(runtimeComponentId);
        if (!runtimeComponent) {
            return;
        }
        runtimeComponent.geometryChanged = geometryChanged;
    }
    _getRuntimeComponent(runtimeComponentId) {
        let runtimeComponent = this._components.get(runtimeComponentId);
        if (!runtimeComponent) {
            runtimeComponent = this._previews.get(runtimeComponentId.toString());
            if (!runtimeComponent) {
                return null;
            }
        }
        return runtimeComponent;
    }
    configurationLoaded(conversationId, objectId, componentId, _hash, _errors) {
        if (conversationId === DOCKING_CONVERSATION_ID) {
            this._configuratorContext.dockingRootComponentId = componentId;
        }
        let isFreeFlying = objectId === 0;
        if (!isFreeFlying) {
            this._getKernelAccess().kernelInstance.requestPlanObjectConstruction(objectId);
        }
        else {
            this._getKernelAccess().kernelInstance.requestPlanComponentConstructionRecursive(componentId);
        }
        let kernelComponent = this._getKernelAccess().kernelInstance.getComponent(componentId);
        let component = this._components.get(componentId);
        if (component) {
            component.computeBoundingBox(kernelComponent.boxForMeasurement);
            component.hash = kernelComponent.hash;
        }
        if (this._listener) {
            this._listener.configurationLoaded(component, isFreeFlying && component.boundingBoxMesh !== undefined);
        }
    }
    finishParameterChange(resolve, _reject) {
        this.materialQueue.registerCallback(resolve);
    }
    planObjectConfigurationUpdated(planObjectId, _configuration, _hash, pendingDocking) {
        let planObject = this._getKernelAccess().kernelInstance.getPlanObject(planObjectId);
        this._updatePlanObject(planObject, pendingDocking);
    }
    //planObjectId = runtimeConfigurationId
    planObjectCreated(conversationId, planObjectId) {
        this._configuratorContext.planObjectId = planObjectId;
        if (this._listener) {
            this._listener.clearScene();
        }
    }
    planObjectUpdated(planObject, pendingDocking) {
        this._updatePlanObject(planObject, pendingDocking);
    }
    sceneCleared() {
        this._components.forEach(function (component) {
            component.removeFromParent();
            component.removeAllMeshes();
        });
        this._components.clear();
        this._componentNumberOfPossibleChildren.clear();
        this._previews.forEach((preview) => {
            preview.removeFromParent();
            preview.removeAllMeshes();
        });
        this._previews.clear();
    }
    setListener(listener) {
        this._listener = listener;
    }
    getBoundingBox() {
        if (this._configuratorContext.planObjectId) {
            const planObject = this._getKernelAccess().kernelInstance.getPlanObject(this._configuratorContext.planObjectId);
            if (planObject && planObject.boxForMeasurement) {
                return kernelBoxToThreeBox(planObject.boxForMeasurement);
            }
        }
        else if (this._configuratorContext.rootComponentId) {
            const component = this._components.get(this._configuratorContext.rootComponentId);
            return new Box3().setFromObject(component);
        }
        return null;
    }
    getBoundingBoxWithPreviews() {
        const component = this._components.get(this._configuratorContext.rootComponentId);
        if (!component) {
            return null;
        }
        return new Box3().setFromObject(component);
    }
    hasPreviews() {
        return this._previews.size > 0;
    }
    clearRootComponent() {
        var _a;
        (_a = this._components.get(this._configuratorContext.rootComponentId)) === null || _a === void 0 ? void 0 : _a.hoverOff();
    }
    debugSceneGraph(id) {
        if (id) {
            if (this._components.has(id)) {
                console.log(this._components.get(id));
            }
            else if (this._previews.has(id.toString())) {
                console.log(this._previews.get(id.toString()));
            }
            return;
        }
        console.log(this._configuratorContext);
    }
    getComponentsForIds(ids) {
        let components = [];
        ids.forEach((id) => {
            const component = this._components.get(id);
            if (component) {
                components.push(component);
            }
        });
        return components;
    }
    getComponents() {
        return Array.from(this._components.values());
    }
    getPreviews() {
        return Array.from(this._previews.values());
    }
    hasPreviewLines() {
        for (const preview of this._previews.values()) {
            if (this._componentFactory.isPreviewLine(preview)) {
                return true;
            }
        }
        return false;
    }
    isPreviewLine(obj) {
        return this._componentFactory.isPreviewLine(obj);
    }
    isPreview(obj) {
        return this._componentFactory.isPreview(obj);
    }
    setGeometriesMergedListener(fun) {
        this._geometriesMerged = fun;
    }
    removeGeometriesMergedListener() {
        this._geometriesMerged = undefined;
    }
    setMergeThreshold(threshold) {
        this._mergeThreshold = threshold;
    }
    _generateMesh(runtimeComponentId = 0, geometryId = null, materialId, vertices, indices, uvCoords, normals, _type, _newGeometryInstance, materialAttributes) {
        return this._configuratorMeshGenerator.generateMesh(runtimeComponentId, geometryId, materialId, vertices, indices, uvCoords, normals, false, materialAttributes);
    }
    _setMaterial(mesh, material, _type) {
        this._configuratorMeshGenerator.setMaterial(mesh, material);
    }
    constructComponents(planObjectId) {
        // const componentId = this._getKernelAccess().kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId);
        // this._constructComponentsRecursive(componentId);
        this._getKernelAccess().kernelInstance.requestPlanObjectConstruction(planObjectId);
    }
    requestSubPartConstruction(partId) {
        this._subPartGuard = new AsyncGuard(partId);
        this._getKernelAccess().requestPlanComponentConstruction(partId, false);
        return this._subPartGuard.wait();
    }
    getMeshGenerator() {
        return this._configuratorMeshGenerator;
    }
    setRequestRenderCallback(requestRenderCallback) {
        this._requestRenderCallback = requestRenderCallback;
    }
    setRequestRenderSceneUpdateCallback(requestRenderSceneUpdateCallback) {
        this._requestRenderSceneUpdateCallback = requestRenderSceneUpdateCallback;
    }
}
__decorate([
    inject
], ConfiguratorViewModel.prototype, "_configuratorMeshGenerator", void 0);
__decorate([
    inject
], ConfiguratorViewModel.prototype, "_configuratorContext", void 0);
__decorate([
    inject
], ConfiguratorViewModel.prototype, "_cacheHolder", void 0);
__decorate([
    inject
], ConfiguratorViewModel.prototype, "_initData", void 0);
class OccurrenceMap extends Map {
    largestValue() {
        let largestKey = this.entries().next().value[0];
        let largestValue = 0;
        this.forEach((v, k) => {
            if (v > largestValue) {
                largestKey = k;
                largestValue = v;
            }
        });
        return largestKey;
    }
}

const PARAMETER_TYPE_MATERIAL = 'material';
const ASYNC_PARAMTER_CHANGES = [PARAMETER_TYPE_MATERIAL];
const NONE_STRING_ERROR_MESSAGE = 'tried to set a parameter to a none string value!';
class ConfiguratorKernelAccess extends CommonKernelAccess {
    constructor(creator) {
        super(creator);
        this.externalMeshQueue = new PromiseQueue();
        this.muteKernelCallbacks = false;
        this.listOfVariants = (_componentId, _list) => undefined; // unused but needed for kernel
    }
    init(kernelType) {
        super.init(kernelType);
        Benchmark.addMeta("kernel_is_ready" /* MARKS.KERNEL_IS_READY */, { isWasm: this._useWASM });
        if (AppContext.kernelInstance) {
            this._kernelContainer = AppContext.kernelContainer;
            setTimeout(() => this._loadSuccess(), 0); // use setTimeout to keep it async, so behaviour is similar to HSC use case
        }
        else {
            this._scriptLoader
                .fetch(this._kernelPath, { id: 'kernel' })
                .then(this._loadSuccess.bind(this), this._loadError.bind(this));
        }
    }
    _loadSuccess() {
        Benchmark.start("kernel_is_ready" /* MARKS.KERNEL_IS_READY */);
        if (!window.ConfiguratorKernel) {
            return;
        }
        if (!AppContext.kernelInstance) {
            window.ConfiguratorKernel(this._kernelContainer);
            window.ConfiguratorKernel = null;
        }
        else {
            setTimeout(() => this.isReady(), 0); // use setTimeout to keep it async, so behaviour is similar to HSC use case
        }
    }
    _loadError() {
        this._configuratorKernelAccessCallback.loadError();
    }
    selectedComponent(componentId) {
        this._updateComponentDependencies(componentId);
    }
    uiRequestConfiguration(objectId) {
        const configurationString = this._kernelInstance.getSerializedConfiguration(objectId);
        AsyncHelper.finishOperation(1 /* ASYNC_OPERATIONS.KERNEL_SERIALIZED_CONFIGURATION */, configurationString);
    }
    _updateComponentParameters(componentId) {
        let componentParameters = this._kernelInstance.getComponentParameters(componentId);
        const componentDefinition = this._kernelInstance.getComponent(componentId);
        this._configuratorKernelAccessCallback.updateParameters(componentParameters, componentDefinition.parameterGroups, componentId, 1 /* PARAMETER_UPDATE_TYPE.PLAN_COMPONENT */);
    }
    selectionChange(componentId, isRoot) {
        let hasChildren = false;
        let components = [];
        if (componentId) {
            let component = this._kernelInstance.getComponent(componentId);
            component.componentId = this._kernelInstance.getComponentId(componentId);
            if (component && component.childIds && component.childIds.length > 0) {
                hasChildren = true;
            }
            components.push(component);
        }
        this._configuratorUiCallbacks.onSelectionChange("standard" /* SELECTION_MODE.STANDARD */, isRoot, hasChildren, components);
    }
    multiSelectionChange(runtimeComponentIds, rootComponentId) {
        this._updateCommonComponentDependencies(runtimeComponentIds);
        let hasChildren = false;
        let isRoot = false;
        let components = [];
        if (runtimeComponentIds) {
            runtimeComponentIds.forEach((componentId) => {
                let component = this._kernelInstance.getComponent(componentId);
                component.componentId =
                    this._kernelInstance.getComponentId(componentId);
                if (component && component.childIds && component.childIds.length > 0) {
                    hasChildren = true;
                }
                if (component.id === rootComponentId) {
                    isRoot = true;
                }
                components.push(component);
            });
        }
        this._configuratorUiCallbacks.onSelectionChange("multiselect" /* SELECTION_MODE.MULTISELECT */, isRoot, hasChildren, components);
    }
    _updateCommonComponentDependencies(runtimeComponentIds) {
        const { parameters, parameterGroups } = this._kernelInstance.getCommonPlanComponentParameters(this._utilityToLongArray(runtimeComponentIds));
        this._configuratorKernelAccessCallback.updateParameters(parameters, parameterGroups, runtimeComponentIds, 2 /* PARAMETER_UPDATE_TYPE.COMMON_COMPONENTS */);
    }
    _updateComponentChildren(componentId) {
        const children = this._kernelInstance.getPlanComponentPossibleChildren(componentId);
        this._configuratorKernelAccessCallback.updatePossibleChildren(componentId, children, 1 /* PARAMETER_UPDATE_TYPE.PLAN_COMPONENT */);
    }
    _updateComponentDependencies(componentId) {
        this._updateComponentParameters(componentId);
        this._updateComponentChildren(componentId);
    }
    _updatePlanObjectParameters(planObjectId) {
        let planObjectParameters = this._kernelInstance.getPlanObjectParameters(planObjectId);
        let planObjectDefinition;
        if (planObjectParameters.length === 0) {
            let rootComponentId = this._kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId);
            planObjectParameters =
                this._kernelInstance.getComponentParameters(rootComponentId);
            this._enableRootComponentParametersAsGlobal();
            planObjectDefinition = this._kernelInstance.getComponent(rootComponentId);
        }
        else {
            this._configuratorContext.rootComponentParametersAsGlobal = false;
            planObjectDefinition = this._kernelInstance.getPlanObject(planObjectId);
        }
        this._configuratorKernelAccessCallback.updateParameters(planObjectParameters, planObjectDefinition.parameterGroups, planObjectId, 0 /* PARAMETER_UPDATE_TYPE.PLAN_OBJECT */);
    }
    _enableRootComponentParametersAsGlobal() {
        if (this._configuratorContext.selectedRuntimeComponentId) {
            return;
        }
        this._configuratorContext.rootComponentParametersAsGlobal = true;
    }
    _updatePlanObjectChildren(planObjectId) {
        const children = this._kernelInstance.getPlanObjectPossibleChildren(planObjectId);
        this._configuratorKernelAccessCallback.updatePossibleChildren(planObjectId, children, 0 /* PARAMETER_UPDATE_TYPE.PLAN_OBJECT */);
    }
    updatePlanObjectDependencies(planObjectId) {
        this._updatePlanObjectParameters(planObjectId);
        this._updatePlanObjectChildren(planObjectId);
    }
    _updateConfigurationHasChildren(planObjectId, component = null) {
        if (!component) {
            component = this._kernelInstance.getComponent(this._kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId));
        }
        const size = component.childIds.size
            ? component.childIds.size()
            : component.childIds.length;
        this._configuratorUiCallbacks.onConfigurationHasChildren(size > 0);
    }
    dockComponent(parentId, parentDockId, childId, childDockId) {
        const childDbId = this._kernelInstance.getComponentId(childId);
        const parentDbId = this._kernelInstance.getComponentId(parentId);
        this._kernelInstance.dockComponent(childId, childDockId, parentId, parentDockId);
        this._configuratorUiCallbacks.onUserInitiatedDockDone(childDbId, childDockId, parentDbId, parentDockId, null);
    }
    changeUseOfHDGeometry(context, useHDGeometry) {
        this._rapiAccess.changeUseOfHDGeometry();
        const planObjectId = context.planObjectId;
        const preLoadHint = context.lastLoadedRapiId
            ? context.lastLoadedRapiId
            : this._kernelInstance.getComponentId(planObjectId);
        const configuration = this._kernelInstance.getSerializedConfiguration(planObjectId);
        this._kernelInstance.clearAll();
        this._kernelInstance.useHDGeometry(useHDGeometry);
        AsyncHelper.finishOperation(3 /* ASYNC_OPERATIONS.UI_RELOAD_CONFIGURATION */, [
            configuration,
            preLoadHint,
        ]);
    }
    webGlPreviewDockings(context, dragIn) {
        AsyncHelper.waitFor(4 /* ASYNC_OPERATIONS.CONFIGURATION_LOADED */).then(({ componentId: configurationLoadedId, }) => {
            if (dragIn) {
                this.requestPlanComponentConstruction(configurationLoadedId);
            }
            this._kernelInstance.requestPreviewGeometry(configurationLoadedId, context.planObjectId, false);
        });
        if (context.lastPossibleChild && context.lastPossibleChild.isComponent) {
            this._kernelIo.setMeta({ componentId: context.lastPossibleChild.id });
            this._kernelInstance.loadPlainComponent(DOCKING_CONVERSATION_ID, context.lastPossibleChild.id, context.lastPossibleChild.configuration);
        }
        if (context.lastPossibleChild && context.lastPossibleChild.isItem) {
            this._kernelInstance.loadFreeFlyingConfiguration(DOCKING_CONVERSATION_ID, context.lastPossibleChild.configuration);
        }
    }
    previewDockingsWithDrag(componentId, planObjectId) {
        this._kernelInstance.requestPreviewGeometry(componentId, planObjectId, false);
    }
    loadConfiguration(configuration) {
        if (this._initData.id) {
            this._memoryManager.loadingConfiguration(this._initData.id);
        }
        else {
            this._memoryManager.loadingConfigurationString();
        }
        if (this._memoryManager.shouldHardReset()) {
            this._kernelInstance.clearAll();
        }
        else {
            this._kernelInstance.clearScene();
        }
        //TODO NEED TO CHECK IF LOAD CONFIGURATION CAN TRIGGER MORE LOAD COMPONENTS LIKE LOAD COMPONENT TRIGGERS MORE LOAD SUBCOMPONENTS
        this._kernelInstance.loadConfiguration(DEFAULT_CONVERSATION_ID, configuration, {
            x: 0,
            y: 0,
            z: 0,
        });
    }
    changeCommonComponentParameter(componentIds, parameterKey, type, value, resolve, reject) {
        if (typeof value === 'string') {
            this._kernelInstance.setPlanComponentParameters(this._utilityToLongArray(componentIds), parameterKey, value);
        }
        else {
            console.warn(NONE_STRING_ERROR_MESSAGE, value, parameterKey, type);
        }
        this._finishParameterChange(type, resolve, reject);
        this._updateCommonComponentDependencies(componentIds);
    }
    changeComponentParameter(componentId, parameterKey, type, value, resolve, reject) {
        if (typeof value === 'string') {
            this._kernelInstance.setComponentParameter(componentId, parameterKey, value);
        }
        else {
            console.warn(NONE_STRING_ERROR_MESSAGE, value, parameterKey, type);
        }
        this._finishParameterChange(type, resolve, reject);
        this._updateComponentDependencies(componentId);
    }
    changePlanObjectParameter(planObjectId, parameterKey, type, value, resolve, reject) {
        if (typeof value === 'string') {
            this._kernelInstance.setPlanObjectParameter(planObjectId, parameterKey, value);
        }
        else {
            console.warn(NONE_STRING_ERROR_MESSAGE, value, parameterKey, type);
        }
        this._finishParameterChange(type, resolve, reject);
    }
    _finishParameterChange(parameterType, resolve, reject) {
        if (ASYNC_PARAMTER_CHANGES.indexOf(parameterType) === -1) {
            setTimeout(() => resolve(), 0); // use settimeout here so that behaviour is same with in else branch! which means async
        }
        else {
            this._configuratorKernelCallbackListener.forEach((listener) => listener.finishParameterChange(resolve, reject));
        }
    }
    requestDeleteComponents(componentIds) {
        if (!componentIds) {
            return;
        }
        this._kernelInstance.deletePlanComponents(this._utilityToLongArray(componentIds));
    }
    requestDeletePlanComponent(componentId) {
        var _a, _b;
        if (!componentId || !((_b = (_a = this._initData) === null || _a === void 0 ? void 0 : _a.featureFlags) === null || _b === void 0 ? void 0 : _b.reDock)) {
            return;
        }
        this._kernelInstance.deletePlanComponent(componentId);
    }
    loadComponentIntoKernel(component, componentId) {
        const dummyConversationId = 10;
        this._kernelIo.setMeta({ componentId });
        this._kernelInstance.loadComponentDefinition(dummyConversationId, component);
    }
    async requestPartListAndUpdatePricesOfParts(hash, _prices) {
        let partList = this._kernelInstance.getFullPartList();
        if (!hash) {
            hash = this._kernelInstance.getHashOfConfiguration(this._configuratorContext.planObjectId);
        }
        const enhancedPartList = await this.addUiDataAndPriceToPartList(partList, hash);
        this._configuratorUiCallbacks.onPartListUpdate(enhancedPartList, btoa(hash));
    }
    requestSync(conversationId, planObjectId) {
        this.planObjectCreated(conversationId, planObjectId);
        this._kernelInstance.syncPlanObjectToView(conversationId, planObjectId);
    }
    getGlobalParameters(planObjectId, rootComponentParametersAsGlobal) {
        return new Promise((resolve) => {
            let method = this._kernelInstance.getPlanObjectParameters;
            let id = planObjectId;
            if (rootComponentParametersAsGlobal) {
                method = this._kernelInstance.getComponentParameters;
                id =
                    this._kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId);
            }
            const parameters = method.apply(this._kernelInstance, [
                id,
            ]);
            resolve(parameters);
        });
    }
    getPartList() {
        return new Promise((resolve) => {
            let partList = this._kernelInstance.getFullPartList();
            resolve(partList);
        });
    }
    getConfigurationHash(context) {
        return new Promise((resolve) => resolve(this._kernelInstance.getHashOfConfiguration(context.planObjectId)));
    }
    requestPlanObjectConstruction(objectId) {
        this._kernelInstance.requestPlanObjectConstruction(objectId);
    }
    isReady() {
        super.isReady();
        this._setupKernel();
        if (!Env.isProduction) {
            window.__RML__DEBUG__.Kernel = this._kernelInstance;
            window.__RML__DEBUG__.KernelContainer = this._kernelContainer;
            window.__RML__DEBUG__.Helper = { convertCObject };
        }
        this._configuratorKernelAccessCallback.isReady();
        this._configuratorUiCallbacks.onConfiguratorKernelIsReady(this._kernelContainer, this._kernelInstance);
        if (AppContext.planObjectId) {
            // needs to be done because planObjectCreated is already fired when plan is loaded
            this.planObjectCreated(-1, AppContext.planObjectId); // @todo check what's a meaningfull conversation id?!?
        }
    }
    _setupKernel() {
        if (this._kernelType === 1 /* KERNEL_TYPE.CONFIGURATOR */) {
            Benchmark.start("kernel_create_instance" /* MARKS.KERNEL_CREATE */);
            if (AppContext.kernelInstance) {
                this._kernelInstance = AppContext.kernelInstance;
            }
            else {
                this._kernelInstance = new this._kernelContainer.Kernel();
            }
            // *********************************************************************
            // Use proxy if kernel reports handle[name] is not defined then you'll
            // get a warning telling you which function is missing! Use this for
            // debug only!
            //
            // this._kernelContainer.registerConfiguratorCallback(new Proxy(this, {
            //     get(target, prop) {
            //         if ((target as any)[prop] === undefined) {
            //             console.warn('prop ' + prop.toString() + ' is missing');
            //             return (): void => undefined;
            //         }
            //         return (target as any)[prop];
            //     }
            // }));
            //
            // *********************************************************************
        }
        this._initKernel();
    }
    // This function is not called by the Kernel!
    // This function is only called if a rapi request fails!
    onLoadComponentError(error, id) {
        this._configuratorUiCallbacks.onComponentLoadError(error, id);
    }
    configurationLoaded(conversationId, objectId, componentId, hash, errors, _valid) {
        AsyncHelper.finishOperation(4 /* ASYNC_OPERATIONS.CONFIGURATION_LOADED */, {
            conversationId,
            objectId,
            componentId,
            hash,
            errors: convertCObject(errors),
        });
        this._configuratorKernelCallbackListener.forEach((listener) => listener.configurationLoaded(conversationId, objectId, componentId, hash, errors));
    }
    componentDefinitionLoaded(conversationId, componentId) {
        AsyncHelper.finishOperation(0 /* ASYNC_OPERATIONS.COMPONENT_DEFINITION_LOADED */, componentId);
    }
    componentDefinitionLoadingError(conversationId, errorMessage) {
        this._kernelIo.error(errorMessage);
        AsyncHelper.failOperation(0 /* ASYNC_OPERATIONS.COMPONENT_DEFINITION_LOADED */, new Error(errorMessage));
    }
    configurationLoadingError(_runtimeId, errors) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
        let errorMsg = 'Configuration loading error';
        if (errors) {
            const errorMessages = convertCObject(errors);
            if (Array.isArray(errorMessages)) {
                errorMsg = errorMessages.join('\n');
                errorMessages.forEach((err) => this._kernelIo.error(err));
            }
        }
        AsyncHelper.failOperation(4 /* ASYNC_OPERATIONS.CONFIGURATION_LOADED */, new Error(errorMsg));
        AsyncHelper.failOperation(2 /* ASYNC_OPERATIONS.KERNEL_PLAN_OBJECT_CONSTRUCTION_DONE */, new Error(errorMsg));
    }
    componentConfigurationUpdated(componentId, geometryChanged) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.componentConfigurationUpdated(componentId, geometryChanged));
        {
            this._kernelInstance.requestDeltaPlanComponentConstruction(componentId);
        }
    }
    setActiveGroupInView(group) {
        this._kernelInstance.setActiveGroupInView(group);
    }
    setActiveGroupInViewForPlanObject(group, runtimeId) {
        this._kernelInstance.setActiveGroupInViewForPlanObject(group, runtimeId || this._configuratorContext.planObjectId);
    }
    componentParameters( /*componentId, parameters*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
        // UPDATE
    }
    requestComponentDimensions( /*id*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    planObjectCreated(conversationId, planObjectId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.planObjectCreated(conversationId, planObjectId));
    }
    planObjectUpdated(planObjectId, pendingDocking) {
        const planObject = this._kernelInstance.getPlanObject(planObjectId);
        this._onBoundsUpdate(planObject);
        this._configuratorKernelCallbackListener.forEach((listener) => listener.planObjectUpdated(planObject, pendingDocking));
    }
    planObjectConfigurationUpdated(planObjectId, configuration, hash, _rootPlanComponentId, _valid, pendingDocking) {
        this.updatePlanObjectDependencies(planObjectId); // IS NEEDED OTHERWISE WE DO NOT GET UPDATES WHEN GLOBAL PARAMETERS CHANGE
        // UPDATE ROOT COMPONENT POSITIONING!
        let component = this._kernelInstance.getComponent(this._kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId));
        this._configuratorKernelCallbackListener.forEach((listener) => listener.planObjectConfigurationUpdated(planObjectId, configuration, hash, pendingDocking));
        const planObject = this._kernelInstance.getPlanObject(planObjectId);
        this._onBoundsUpdate(planObject);
        if (!pendingDocking) {
            this._configuratorHistory.push(configuration);
        }
        this._updateConfigurationHasChildren(planObjectId, component);
        return this.requestPartListAndUpdatePricesOfParts(hash);
    }
    _onBoundsUpdate(planObject) {
        if (!planObject.boxForMeasurement) {
            return;
        }
        const bounds = {
            width: this._unitFormatter.formatMMValueToUnitString(planObject.boxForMeasurement.size.x),
            height: this._unitFormatter.formatMMValueToUnitString(planObject.boxForMeasurement.size.z),
            depth: this._unitFormatter.formatMMValueToUnitString(planObject.boxForMeasurement.size.y),
            kernelBounds: planObject.boxForMeasurement,
        };
        this._configuratorUiCallbacks.onBoundsUpdate(bounds);
    }
    planObjectDeleted( /*objectId*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    requestPlanObjectDimensions( /*id*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    async requestExternalMesh(meshId, quality) {
        let queueResolve = () => undefined;
        const queuePromise = new Promise((resolve, _reject) => {
            queueResolve = resolve;
        });
        this.externalMeshQueue.push(queuePromise);
        this._configuratorUiCallbacks.onRequestExternalMesh(meshId, quality);
        let mesh;
        try {
            mesh = await this._rapiAccess.getMesh(meshId, MESH_DEFAULT_FORMAT, quality);
        }
        catch (error) {
            this._handleInvalidMesh(meshId);
            this._configuratorUiCallbacks.onError(new Error(`Mesh with id "${meshId}" can not be loaded. "${error}"`));
            console.error(error);
            return;
        }
        try {
            const response = await fetch(new Request(this._dataSyncer.requestAsset(mesh.url, true /* use mesh.url as fallback */)));
            const buffer = await response.arrayBuffer();
            this._handleCortoMesh(buffer, meshId, quality);
            queueResolve();
        }
        catch (error) {
            this._handleInvalidMesh(meshId);
            this._configuratorUiCallbacks.onError(new Error(`Mesh with id "${meshId}" breaks. "${error}"`));
            console.error(error);
            return;
        }
    }
    Editor3dComponentCreated(id, position, eulerAngles, parent) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dComponentCreated(id, position, eulerAngles, parent, false));
        //FIXME: Create itself knows everything thats needed to dock!
        if (parent && parent > 0) {
            this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dComponentDocked(id, parent, position, eulerAngles));
        }
    }
    Editor3dRootComponentCreated(id, position, eulerAngles, parentObjectId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dComponentCreated(id, position, eulerAngles, parentObjectId, true));
    }
    Editor3dPlanObjectConstructionDone(planObjectId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dPlanObjectConstructionDone(planObjectId));
        // planObjectConfigurationUpdated is NOT called on initial planObject creation
        // planObjectUpdated is called on changes on the planObject after that always planObjectConfigurationUpdated is called!
        // there fore adding this._updatePlanObjectDependencies(planObjectId); to planObject triggers this method two times.
        // adding it only to planObjectConfigurationUpdated is too less, since we dont get initial parameters and addons
        this.updatePlanObjectDependencies(planObjectId);
        this._updateConfigurationHasChildren(planObjectId);
        if (this._initData.moc) {
            return;
        }
        this._calcPrice();
        return;
    }
    Editor3dBeginGroup( /*id, name*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dEndGroup( /*id*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dSetMaterial( /*id, materialKey*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dLoadMaterial( /*materialKey*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddDockPreview(componentId, previewId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dAddDockPreview(componentId, previewId));
    }
    Editor3dSetPreviewPointAssociations(dockPairs, previewId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dSetPreviewPointAssociations(dockPairs, previewId));
    }
    Editor3dSetPreviewLineAssociations(dockLines, previewId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dSetPreviewLineAssociations(dockLines, previewId));
    }
    Editor3dPreviewConstructionDone(componentId, objectId) {
        this._configuratorKernelCallbackListener.forEach((listener) => listener.Editor3dPreviewConstructionDone(componentId, objectId));
    }
    Editor3dTranslateBy( /*id, delta*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dRotateBy( /*id, axis, angle*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dRotateAround( /*id, axis, angle, center*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddCube( /*id, size*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddCubeUVMod( /*id, size, uvScale, uvRotation, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddSphere( /*id, size*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddSphereUVMod( /*id, size, uvScale, uvRotation, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddRectangle( /*id, size*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddRectangleUVMod( /*id, size, uvScale, uvRotation, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddMesh( /*id, vertices , indices, uvs */) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddMeshUVMod( /*id, vertices, indices, uvScale, uvRotation, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddMeshUVCoord( /*id, vertices, indices, uvs, normals*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddCylinder( /*id, radiusBottom, radiusTop, height, circleSegments, radiusSegments, heightSegments*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddCylinderUVMod( /*id, radiusBottom, radiusTop, height, segmentsCircumference, uvScale, uvRotation, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddPrism( /*id, height, vertices*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddPrismUVMod( /*id, height, vertices, uvScale, uvRotate, uvOffset*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddFittingPoint( /*id, pointId, position, rotation, dockType, maskId*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dAddFittingLine( /*id, lineId, position, positionTo, rotation, dockType, maskId*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dSelectObject( /*id*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dCopy( /*id*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanObjectPosition( /*id, position*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanObjectRotation( /*id, eulerAngles*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanObjectTransform( /*id, position, eulerAngles*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanComponentPosition( /*id, position*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanComponentRotation( /*id, eulerAngles*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    Editor3dUpdatePlanComponentTransform( /*id, position, eulerAngles*/) {
        // UNUSED RIGHT NOW BUT NEEDED FOR KERNEL
    }
    getRuntimeComponentIdOfRootComponent(planObjectId) {
        if (!this._kernelInstance) {
            console.warn('this._kernelInstance not ready now');
            return 0; // Kernel returns 0 if something is invalid, to be same as kernel also return 0 here
        }
        return this._kernelInstance.getRootPlanComponentIdFromObjectId(planObjectId);
    }
    getRuntimeComponentId(runtimeComponentId) {
        return this._kernelInstance.getComponentId(runtimeComponentId);
    }
    getParameterGroups() {
        if (!this._configuratorContext.planObjectId) {
            return [];
        }
        const rootComponentId = this._kernelInstance.getRootPlanComponentIdFromObjectId(this._configuratorContext.planObjectId);
        const component = this._kernelInstance.getComponent(rootComponentId);
        return component.parameterGroups;
    }
    resume() {
        if (this.muteKernelCallbacks) {
            return;
        }
        super.resume();
    }
    getSerializedConfiguration(objectId) {
        return this._kernelInstance.getSerializedConfiguration(objectId);
    }
    createNewSerializedConfiguration(configurationRuntimeId) {
        return this._kernelInstance.createNewSerializedConfiguration(configurationRuntimeId);
    }
    getCurrentConfigurationHash(planObjectId) {
        return this._kernelInstance.getHashOfConfiguration(planObjectId);
    }
    listOfVariantsError(dbId, error) {
        this._kernelIo.setMeta({ rapiId: dbId });
        this._kernelIo.error(error);
    }
}
__decorate([
    inject
], ConfiguratorKernelAccess.prototype, "_memoryManager", void 0);
__decorate([
    inject
], ConfiguratorKernelAccess.prototype, "_configuratorKernelAccessCallback", void 0);
__decorate([
    inject
], ConfiguratorKernelAccess.prototype, "_initData", void 0);
__decorate([
    inject
], ConfiguratorKernelAccess.prototype, "_configuratorHistory", void 0);

class DraggableNode extends Mesh {
    constructor(name, sphereSize = 0.05) {
        super();
        this.name = name;
        this._sphereSize = sphereSize;
        this._innerRingRadius = this._sphereSize;
        this._outerRingRadius = this._innerRingRadius + 0.02;
        this._initNodeMesh();
    }
    _initNodeMesh() {
        const sphereGeometry = new SphereGeometry(this._sphereSize, 32);
        const sphereMaterial = new MeshBasicMaterial({ color: 0xffffff });
        this._sphere = new Mesh(sphereGeometry, sphereMaterial);
        const innerRingGeometry = new RingGeometry(this._innerRingRadius, this._outerRingRadius, 32);
        const innerRingMaterial = new MeshBasicMaterial({
            color: 0x000000,
            side: DoubleSide,
        });
        this._innerRingMesh = new Mesh(innerRingGeometry, innerRingMaterial);
        this._innerRingMesh.rotation.set(Math.PI / 2, 0, 0);
        const outerRingGeometry = new RingGeometry(this._outerRingRadius, this._outerRingRadius + 0.01, 32);
        const outerRingMaterial = new MeshBasicMaterial({
            color: 0xffffff,
            side: DoubleSide,
        });
        this._outerRingMesh = new Mesh(outerRingGeometry, outerRingMaterial);
        this._outerRingMesh.rotation.set(Math.PI / 2, 0, 0);
        this.add(this._sphere);
        this.add(this._innerRingMesh);
        this.add(this._outerRingMesh);
    }
    getSize() {
        this._initNodeMesh();
        return new Box3().setFromObject(this).getSize(new Vector3());
    }
    hoverOn() {
        const increaseBy = 0.02;
        this._sphere.geometry = new SphereGeometry(this._sphereSize + increaseBy, 32);
        this._innerRingMesh.geometry = new RingGeometry(this._innerRingRadius + increaseBy, this._outerRingRadius + increaseBy, 32);
        this._outerRingMesh.geometry = new RingGeometry(this._outerRingRadius + increaseBy, this._outerRingRadius + 0.01 + increaseBy, 32);
    }
    hoverOff() {
        this._sphere.geometry = new SphereGeometry(this._sphereSize, 32);
        this._innerRingMesh.geometry = new RingGeometry(this._innerRingRadius, this._outerRingRadius, 32);
        this._outerRingMesh.geometry = new RingGeometry(this._outerRingRadius, this._outerRingRadius + 0.01, 32);
    }
    select(color) {
        this._innerRingMesh.material = new MeshBasicMaterial({
            color,
            side: DoubleSide,
        });
    }
    deselect(color) {
        this._innerRingMesh.material = new MeshBasicMaterial({
            color,
            side: DoubleSide,
        });
    }
}

class NodePlanElementViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        const maxWallHeight = this.getPlanElement().getMaxWallHeight();
        // TODO check why getMaxWallHeight (core) returns -1000 when creating predefined rooms
        // and does not update it afterwards
        this._container.position.y =
            (maxWallHeight < 0 ? 2800 : maxWallHeight) / 1000 + 0.01;
        this._container.name = 'Node Plan Element';
        this.addMesh(this._nodeUiMesh);
    }
    update() {
        super.update();
        this._container.position.y =
            this.getPlanElement().getMaxWallHeight() / 1000 +
                0.01;
    }
    setTopView(enabled) {
        super.setTopView(enabled);
        if (!enabled) {
            this._nodeUiMesh.visible = false;
        }
    }
    getSize() {
        if (!this._nodeUiMesh) {
            this._nodeUiMesh = new DraggableNode('Wall draggable node');
        }
        return new Box3().setFromObject(this._nodeUiMesh).getSize(new Vector3());
    }
    show() {
        // only make it visible in top view (2d)
        this._nodeUiMesh.visible = this._topView;
    }
    hide() {
        this._nodeUiMesh.visible = false;
    }
    select() {
        this._nodeUiMesh.select(WALL_SELECTION_COLOR);
        super.select();
    }
    deselect() {
        this._nodeUiMesh.select(0x000000);
        super.deselect();
    }
    hoverOn() {
        this._nodeUiMesh.hoverOn();
        super.hoverOn();
    }
    hoverOff() {
        this._nodeUiMesh.hoverOff();
        super.hoverOff();
    }
    _generateBoundingBox() {
        const mesh = super._generateBoundingBox();
        mesh.layers.set(9 /* LAYER.CONSTRUCTION */);
        return mesh;
    }
    addMesh(mesh) {
        super.addMesh(mesh);
        // implement when we want to show node meshes to the scene, for example if we want to drag them
    }
}

const toConstructionMeasurementTransferable = (constructionMeasurements) => {
    return transformMeasurement(constructionMeasurements);
};
const MAX_ROOM_HEIGHT = 5;
class ConstructionPlanObjectViewModel extends StaticPlanObjectViewModel {
    constructor(planObject) {
        super(planObject);
        this._container.name = 'Construction ' + this._container.name;
    }
    setTopView(enabled) {
        super.setTopView(enabled);
        if (enabled) {
            this._enableTopView();
        }
        else {
            this._disableTopView();
        }
        this._updateBoundingBox();
    }
    _enableTopView() {
        if (!this._topViewContainer) {
            this._topViewContainer = new Group();
            const constructionPlanObject = this.getPlanElement();
            const { x, z } = convertToThreeDimensions(constructionPlanObject.size);
            const greyMeshGeometry = new BoxGeometry(x, 0.01, z);
            this._topGreyMesh = new Mesh(greyMeshGeometry, MaterialCreator.createMeshStandardMaterial({
                transparent: true,
                opacity: PREVIEW_MATERIAL_OPACITY,
                color: 0xb1b1b1,
            }));
            this._topViewContainer.add(this._topGreyMesh);
            if (constructionPlanObject.getObjectType() === 'window') {
                const blackMeshGeometry = new BoxGeometry(x, 0.02, 0.05);
                this._topBlackMesh = new Mesh(blackMeshGeometry, MaterialCreator.createMeshStandardMaterial({
                    transparent: true,
                    opacity: PREVIEW_MATERIAL_OPACITY,
                    color: 0x000000,
                }));
                this._topViewContainer.add(this._topBlackMesh);
            }
            this._topViewContainer.position.y = MAX_ROOM_HEIGHT;
            this._container.add(this._topViewContainer);
        }
        this._topViewContainer.visible = true;
    }
    _disableTopView() {
        if (this._topViewContainer) {
            this._topViewContainer.visible = false;
        }
    }
    getPlanElement() {
        return super.getPlanElement();
    }
    _generateBoundingBox() {
        const boundingBox = super._generateBoundingBox();
        const size = this.getSize();
        boundingBox.geometry = new BoxGeometry(size.x, this._topView ? MAX_ROOM_HEIGHT : size.y, size.z);
        return boundingBox;
    }
    _updateBoundingBox() {
        super._updateBoundingBox();
        const size = this.getSize();
        this._boundingBox.geometry = new BoxGeometry(size.x, this._topView ? MAX_ROOM_HEIGHT : size.y, size.z);
    }
    getTopViewContainer() {
        return this._topViewContainer;
    }
    _getWallCenterPoints(wallFromPoint, leftCorner, wallToPoint, rightCorner) {
        const directionFromPoint = wallFromPoint.clone().sub(leftCorner);
        const directionToPoint = wallToPoint.clone().sub(rightCorner);
        const directionFromLength = directionFromPoint.length();
        const directionToLength = directionToPoint.length();
        const centerFromVector = directionFromPoint
            .clone()
            .normalize()
            .multiplyScalar(directionFromLength);
        const centerToVector = directionToPoint
            .clone()
            .normalize()
            .multiplyScalar(directionToLength);
        const { centerFrom, centerTo } = getConstructionElemMiddlePoints(this.getPlanElement());
        const wallFromCenterPoint = centerFrom.clone().add(centerFromVector);
        const wallToCenterPoint = centerTo.clone().add(centerToVector);
        return { wallFromCenterPoint, wallToCenterPoint };
    }
    getConstructionElementMeasurements(zoomFactor) {
        let wallPlanObject;
        if (this.getPlanElement() && 'getAttachedWall' in this.getPlanElement()) {
            wallPlanObject = this.getPlanElement().getAttachedWall();
        }
        else {
            return null;
        }
        const wallPreferredSide = wallPlanObject.getPreferredSide();
        const elementPreferredSide = this.getPlanElement().getPreferredSide();
        const center = convertToTHREE(wallPlanObject.getCenter());
        const { from: wallFromPoint, to: wallToPoint, middle, } = calculateWallPlanPoints(wallPlanObject, wallPreferredSide);
        let { from: leftCorner, to: rightCorner } = calculateWallPlanPoints(this.getPlanElement(), elementPreferredSide);
        // Reset Y to zero since we show it in 2D only
        wallFromPoint.y = 0;
        wallToPoint.y = 0;
        leftCorner.y = 0;
        rightCorner.y = 0;
        const { wallFromCenterPoint, wallToCenterPoint } = this._getWallCenterPoints(wallFromPoint, leftCorner, wallToPoint, rightCorner);
        const { centerFrom: centerCornerFrom, centerTo: centerCornerTo } = getConstructionElemMiddlePoints(this.getPlanElement());
        const constructionElemDirection = rightCorner.clone().sub(leftCorner);
        const normalVector = constructionElemDirection
            .clone()
            .cross(new Vector3(0, 1, 0))
            .normalize();
        if (normalVector.clone().dot(middle.clone().sub(center)) < 0) {
            normalVector.multiplyScalar(-1);
        }
        const { textDirection, textRotation } = getTextDirectionAndRotation(constructionElemDirection);
        const shiftingFactor = calculateShiftingFactor(zoomFactor);
        const paddingDirection = normalVector
            .clone()
            .multiplyScalar(shiftingFactor);
        const INIT_2D_VECTOR = new Vector3(0, 0, 0);
        const init2DMeasurements = {
            fromPosition2d: INIT_2D_VECTOR,
            toPosition2d: INIT_2D_VECTOR,
            textPosition2d: INIT_2D_VECTOR,
        };
        const leftMeasurement = {
            fromPosition3d: leftCorner,
            toPosition3d: wallFromPoint,
            textDirection: normalVector,
            textRotation,
            textPosition3d: centerCornerFrom
                .clone()
                .add(wallFromCenterPoint)
                .divideScalar(2),
            length: leftCorner.distanceTo(wallFromPoint) * 1000,
            ...init2DMeasurements,
        };
        const rightMeasurement = {
            fromPosition3d: rightCorner,
            toPosition3d: wallToPoint,
            textDirection: normalVector,
            textRotation,
            textPosition3d: centerCornerTo
                .clone()
                .add(wallToCenterPoint)
                .divideScalar(2),
            length: rightCorner.distanceTo(wallToPoint) * 1000,
            ...init2DMeasurements,
        };
        const elementRange = {
            fromPosition3d: leftCorner,
            toPosition3d: rightCorner,
            textDirection,
            textRotation,
            textPosition3d: leftCorner
                .clone()
                .add(rightCorner)
                .divideScalar(2)
                .add(paddingDirection),
            length: constructionElemDirection.length() * 1000,
            ...init2DMeasurements,
        };
        return {
            leftMeasurement,
            rightMeasurement,
            elementRange,
        };
    }
    update() {
        super.update();
        if (!this._topGreyMesh) {
            return;
        }
        const { x, z } = convertToThreeDimensions(this.getPlanElement().size);
        this._topGreyMesh.geometry = new BoxGeometry(x, 0.01, z);
        if (this._topBlackMesh) {
            this._topBlackMesh.geometry = new BoxGeometry(x, 0.02, 0.05);
        }
    }
}

const toMeasurementLineDimensionToTransferable = (measurementLineDimension) => {
    return {
        ...transformMeasurement(measurementLineDimension),
        id: measurementLineDimension.id,
        lengthFormatted: measurementLineDimension.lengthFormatted,
    };
};
const MEASUREMENT_LINE_CONFIG = {
    lineColor: 0x000000,
    boundingBoxPadding: 0.2,
    measurementLineBoxYPos: 3,
    defaultMaterial: {
        color: PREVIEW_MATERIAL_COLOR,
        opacity: PREVIEW_MATERIAL_OPACITY,
        transparent: true,
    },
};
const MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME = {
    POINT1: 'point1',
    POINT2: 'point2',
};
class MeasurementLinePlanElementViewModel extends PlanElementViewModel {
    constructor(planObject) {
        super(planObject);
        this._initializeContainer();
        this._initializeLines();
        this._initializeDraggables();
    }
    _initializeContainer() {
        this._container.name = 'Measurement Line Plan Element';
        this._container.position.copy(new Vector3(0, MAX_ROOM_HEIGHT, 0));
    }
    _initializeLines() {
        this._lineMesh = this._createLine(MEASUREMENT_LINE_CONFIG.lineColor);
        this._subLine1 = this._createLine(MEASUREMENT_LINE_CONFIG.lineColor);
        this._subLine2 = this._createLine(MEASUREMENT_LINE_CONFIG.lineColor);
    }
    _createDraggableNodeBoundBox(point) {
        const size = new Box3().setFromObject(point).getSize(new Vector3());
        const geometry = new BoxGeometry(size.x + MEASUREMENT_LINE_CONFIG.boundingBoxPadding, size.y, size.z + MEASUREMENT_LINE_CONFIG.boundingBoxPadding);
        let boxColor = new Color$1(MEASUREMENT_LINE_CONFIG.defaultMaterial.color);
        const color = this.getPlanElement().customColor;
        if (color > 0) {
            boxColor = getColorFromInt(color);
        }
        let material = MaterialCreator.createMeshStandardMaterial({
            color: boxColor,
            opacity: MEASUREMENT_LINE_CONFIG.defaultMaterial.opacity,
            transparent: MEASUREMENT_LINE_CONFIG.defaultMaterial.transparent,
        });
        material.visible = false;
        let mesh = new Mesh(geometry, material);
        mesh.name = 'bounding box for draggable node';
        mesh.position.copy(point.position);
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.layers.set(6 /* LAYER.UI */);
        return mesh;
    }
    _initializeDraggables() {
        this._point1Draggable = new DraggableNode('point1 draggable');
        this._point1Draggable.layers.set(6 /* LAYER.UI */);
        this._point2Draggable = new DraggableNode('point2 draggable');
        const [point1, point2] = this._getMainLinePoints();
        this._point1Draggable.position.copy(point1);
        this._point2Draggable.position.copy(point2);
        this._point1BoundingBox = this._createDraggableNodeBoundBox(this._point1Draggable);
        this._point2BoundingBox = this._createDraggableNodeBoundBox(this._point2Draggable);
        this._point2Draggable.layers.set(6 /* LAYER.UI */);
        this.addMesh(this._point1Draggable);
        this.addMesh(this._point2Draggable);
        this.addMesh(this._point1BoundingBox);
        this.addMesh(this._point2BoundingBox);
    }
    _createLine(color) {
        const material = new LineBasicMaterial({ color, linewidth: 1 });
        const geometry = new BufferGeometry();
        const line = new Line(geometry, material);
        line.layers.set(6 /* LAYER.UI */);
        line.frustumCulled = false;
        this.addMesh(line);
        return line;
    }
    getMeasurementLineDimension() {
        const [point1, point2] = this._getMainLinePoints();
        const lineDirection = point1.clone().sub(point2);
        const { textDirection, textRotation } = getTextDirectionAndRotation(lineDirection);
        const textPosition3d = point1.clone().add(point2).divideScalar(2);
        return {
            id: this.getPlanElement().getId(),
            length: point1
                .clone()
                .multiplyScalar(1000)
                .distanceTo(point2.clone().multiplyScalar(1000)),
            textPosition3d,
            textRotation,
            fromPosition3d: point1,
            toPosition3d: point2,
            textDirection,
        };
    }
    show() {
        this._container.visible = true;
    }
    hide() {
        this._container.visible = false;
    }
    hideAllSubLines() {
        this._subLine1.material.visible = false;
        this._subLine2.material.visible = false;
    }
    showAllSubLines() {
        this._subLine1.material.visible = true;
        this._subLine2.material.visible = true;
    }
    hideDraggableNodes() {
        this._point1Draggable.visible = false;
        this._point2Draggable.visible = false;
        this.showAllSubLines();
    }
    showDraggableNodes() {
        this._point1Draggable.visible = true;
        this._point2Draggable.visible = true;
        this.hideAllSubLines();
    }
    showPoint1DraggableNode() {
        this._point1Draggable.visible = true;
        this._subLine2.material.visible = true;
    }
    showPoint2DraggableNode() {
        this._point2Draggable.visible = true;
        this._subLine1.material.visible = true;
    }
    hidePoint1DraggableNode() {
        this._point1Draggable.visible = false;
        this._subLine2.material.visible = false;
    }
    hidePoint2DraggableNode() {
        this._point2Draggable.visible = false;
        this._subLine1.material.visible = false;
    }
    setTopView(enabled) {
        super.setTopView(enabled);
        if (enabled) {
            this.show();
        }
        else {
            this.hide();
        }
    }
    update() {
        const [point1, point2] = this._getMainLinePoints();
        const normalVector = this._calculateNormalVector(point1, point2);
        this._updateSubLineGeometry(this._subLine1, point1, normalVector);
        this._updateSubLineGeometry(this._subLine2, point2, normalVector);
        this.updatePointDraggableGeometry(this._point1Draggable, point1);
        this.updatePointDraggableGeometry(this._point2Draggable, point2);
        this._lineMesh.geometry.setFromPoints([point1, point2]);
        this._lineMesh.name = 'main measurement line';
        this._boundingBox.geometry = this._getGeometry();
        this._point1BoundingBox.position.copy(point1);
        this._point2BoundingBox.position.copy(point2);
        this._point1BoundingBox.material.visible = false;
        this._point2BoundingBox.material.visible = false;
        this._point1BoundingBox.position.y =
            MEASUREMENT_LINE_CONFIG.measurementLineBoxYPos + 0.1;
        this._point2BoundingBox.position.y =
            MEASUREMENT_LINE_CONFIG.measurementLineBoxYPos + 0.1;
    }
    _generateBoundingBox() {
        let boxColor = new Color$1(MEASUREMENT_LINE_CONFIG.defaultMaterial.color);
        const color = this.getPlanElement().customColor;
        if (color > 0) {
            boxColor = getColorFromInt(color);
        }
        let material = MaterialCreator.createMeshStandardMaterial({
            color: boxColor,
            opacity: MEASUREMENT_LINE_CONFIG.defaultMaterial.opacity,
            transparent: MEASUREMENT_LINE_CONFIG.defaultMaterial.transparent,
            side: DoubleSide,
        });
        let mesh = new Mesh(this._getGeometry(), material);
        mesh.name = 'bounding box';
        mesh.position.y = MEASUREMENT_LINE_CONFIG.measurementLineBoxYPos;
        mesh.castShadow = false;
        mesh.receiveShadow = false;
        mesh.layers.set(6 /* LAYER.UI */);
        return mesh;
    }
    _getGeometry() {
        const [point1, point2] = this._getMainLinePoints();
        const normalVector = this._calculateNormalVector(point1, point2);
        const paddingLength = 0.1;
        const point1Positive = point1
            .clone()
            .add(normalVector.clone().multiplyScalar(paddingLength));
        const point1Negative = point1
            .clone()
            .add(normalVector.clone().multiplyScalar(-paddingLength));
        const point2Positive = point2
            .clone()
            .add(normalVector.clone().multiplyScalar(paddingLength));
        const point2Negative = point2
            .clone()
            .add(normalVector.clone().multiplyScalar(-paddingLength));
        const geometry = new BufferGeometry();
        const vertices = [
            point1Positive,
            point2Positive,
            point2Negative,
            point1Negative,
        ].reduce((p, c) => [...p, c.x, c.y, c.z], []);
        const indices = [
            0,
            1,
            2,
            2,
            3,
            0, // second triangle
        ];
        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        return geometry;
    }
    _getMainLinePoints() {
        const planObject = this.getPlanElement();
        return [
            convertToTHREE(planObject.getPoint1()),
            convertToTHREE(planObject.getPoint2()),
        ];
    }
    _calculateNormalVector(point1, point2) {
        return point1.clone().sub(point2).cross(new Vector3(0, 1, 0)).normalize();
    }
    _updateSubLineGeometry(line, point, normalVector) {
        const paddingLength = 0.1;
        const pointPositive = point
            .clone()
            .add(normalVector.clone().multiplyScalar(paddingLength));
        const pointNegative = point
            .clone()
            .add(normalVector.clone().multiplyScalar(-paddingLength));
        line.geometry.setFromPoints([pointNegative, pointPositive]);
    }
    updatePointDraggableGeometry(mesh, point) {
        mesh.position.copy(point);
    }
    getPoint1Draggable() {
        return this._point1Draggable;
    }
    getPoint2Draggable() {
        return this._point2Draggable;
    }
    getPoint1DraggableBoundingBox() {
        return this._point1BoundingBox;
    }
    getPoint2DraggableBoundingBox() {
        return this._point2BoundingBox;
    }
    hidePreviewBox() {
        if (this._container && this._boundingBox) {
            this._boundingBox.material.visible = false;
        }
    }
    selectPoint1Draggable() {
        this._point1Draggable.select(WALL_SELECTION_COLOR);
        super.select();
    }
    selectPoint2Draggable() {
        this._point2Draggable.select(WALL_SELECTION_COLOR);
        super.select();
    }
    deselectPoint1Draggable() {
        this._point1Draggable.select(MEASUREMENT_LINE_CONFIG.lineColor);
        super.deselect();
    }
    deselectPoint2Draggable() {
        this._point2Draggable.select(MEASUREMENT_LINE_CONFIG.lineColor);
        super.deselect();
    }
    selectAllDraggablePoints() {
        this._point1Draggable.select(WALL_SELECTION_COLOR);
        this._point2Draggable.select(WALL_SELECTION_COLOR);
        super.select();
    }
    deselectAllDraggablePoints() {
        this._point1Draggable.select(MEASUREMENT_LINE_CONFIG.lineColor);
        this._point2Draggable.select(MEASUREMENT_LINE_CONFIG.lineColor);
        super.deselect();
    }
    hoverOnDragPoint1() {
        this._point1Draggable.hoverOn();
        super.hoverOn();
    }
    hoverOnDragPoint2() {
        this._point2Draggable.hoverOn();
        super.hoverOn();
    }
    hoverOffDragPoint1() {
        this._point1Draggable.hoverOff();
        super.hoverOff();
    }
    hoverOffDragPoint2() {
        this._point2Draggable.hoverOff();
        super.hoverOff();
    }
    selectPointOnDragStart(planElementViewModel) {
        this.showAllSubLines();
        planElementViewModel.deselectAllDraggablePoints();
        if (planElementViewModel.currentPoint ===
            MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.selectPoint1Draggable();
        }
        else if (planElementViewModel.currentPoint ===
            MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.selectPoint2Draggable();
        }
    }
    hideDraggablePointsOnDragStart(planElementViewModel, point) {
        planElementViewModel.deselectAllDraggablePoints();
        if (point === MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.hidePoint1DraggableNode();
            planElementViewModel.selectPoint1Draggable();
        }
        else if (point === MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.hidePoint2DraggableNode();
            planElementViewModel.selectPoint2Draggable();
        }
    }
    showDraggablePointsOnDragEnd(planElementViewModel, point) {
        if (point === MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.showPoint1DraggableNode();
        }
        else if (point === MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.showPoint2DraggableNode();
        }
        this.hideAllSubLines();
    }
    handleDraggablePointsSelection(planElementViewModel) {
        planElementViewModel.deselectAllDraggablePoints();
        if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.selectPoint1Draggable();
        }
        else if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.selectPoint2Draggable();
        }
    }
    showDraggablePointsOnHoverOn(planElementViewModel) {
        if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.hoverOnDragPoint1();
        }
        else if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.hoverOnDragPoint2();
        }
    }
    showDraggablePointsOnHoverOff(planElementViewModel) {
        if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            planElementViewModel.hoverOffDragPoint1();
        }
        else if (planElementViewModel.currentPoint &&
            planElementViewModel.currentPoint ===
                MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            planElementViewModel.hoverOffDragPoint2();
        }
    }
}

class PlannerKernelAccess extends ConfiguratorKernelAccess {
    get kernelContainer() {
        return this._kernelContainer;
    }
    constructor(creator) {
        super(creator);
        this._plannerKernelCallbackListener = new Set();
    }
    _loadSuccess() {
        super._loadSuccess();
        if (window.RoomleCore) {
            window.RoomleCore(this._kernelContainer);
        }
    }
    _loadError() {
        super._loadError();
        console.error('kernel load error');
    }
    _createPlanInteractionHandler() {
        this._planInteractionHandler =
            new this._kernelContainer.PlanInteractionHandler();
        this._planInteractionHandler.init(this._planInteractionHandler, 1, INITIAL_SNAP_DISTANCE, !!this._initData.snappingEnabled, true, this._kernelContainer.DrawingType.CLICK_PER_CLICK);
        this._roomlePlannerUiCallback.onPlanInteractionHandlerCreated(this._planInteractionHandler);
    }
    addPlannerListener(listener) {
        this._plannerKernelCallbackListener.add(listener);
    }
    removePlannerListener(listener) {
        this._plannerKernelCallbackListener.delete(listener);
    }
    isReady() {
        super.isReady();
        this.registerCallbacks();
        this._roomlePlannerUiCallback.onPlannerKernelIsReady(this._kernelContainer);
        this._roomlePlannerUiCallback.onConfiguratorKernelIsReady(this._kernelContainer, this._kernelInstance);
        if (!Env.isProduction) {
            window.__RML__DEBUG__.ConfiguratorKernel = this._kernelInstance;
            window.__RML__DEBUG__.PlannerKernelContainer = this._kernelContainer;
        }
        this._kernelAccessCallback.isReady();
    }
    _setupKernel() {
        if (this._kernelType === 0 /* KERNEL_TYPE.PLANNER */) {
            this._createPlanInteractionHandler();
            if (AppContext.kernelInstance) {
                this._kernelInstance = AppContext.kernelInstance;
            }
            else {
                this._kernelInstance =
                    this._planInteractionHandler.getConfiguratorKernel();
            }
        }
        super._setupKernel();
    }
    get callbacks() {
        return this._roomlePlannerUiCallback;
    }
    get planInteractionHandler() {
        return this._planInteractionHandler;
    }
    get planModelViewHelper() {
        return this._kernelContainer.PlanModelViewHelper;
    }
    catalogItemLoaded(catalogItem) {
        const kernelCatalogItem = this._rapiItemToKernelItem(catalogItem);
        this._kernelContainer.catalogItemLoaded(kernelCatalogItem);
    }
    async insertItems(itemList) {
        this.planInteractionHandler.startInteraction();
        let list = new this._kernelContainer.CatalogItemPtrList();
        itemList.forEach((item) => {
            let count = item.count || 1;
            for (let i = 0; i < count; i++) {
                if (!item.count) {
                    item.count = 0;
                }
                list.push_back(this._rapiItemToKernelItem(item));
            }
        });
        const planViewModel = this.planInteractionHandler.getPlan().extRef.jsObject;
        const idsBefore = planViewModel
            .getPlanObjectViewModelsFromRapiId()
            .reduce((acc, element) => {
            acc[element.getId()] = true;
            return acc;
        }, {});
        this.planInteractionHandler.addPlanObjects(list, true);
        // https://medium.com/@ian.mundy/async-map-in-javascript-b19439f0099
        await Promise.allSettled([
            Promise.allSettled(planViewModel
                .getStaticPlanObjectViewModels()
                .map(async (planObject) => {
                if (planObject.needsRapiItem()) {
                    const rapiItem = await this._rapiAccess.getItem(planObject.getPlanObject().getCatalogItemId());
                    planObject.setRapiItem(rapiItem);
                }
            })),
            Promise.allSettled(planViewModel
                .getConfigurablePlanObjectViewModels()
                .map((planObject) => planObject.isInitDone())),
        ]);
        const planObjectViewModels = planViewModel.getPlanObjectViewModelsFromRapiId();
        const idsAfter = planObjectViewModels.map((element) => element.getId());
        const addedIds = idsAfter.filter((id) => !idsBefore[id]);
        this.planInteractionHandler.endInteraction();
        return addedIds;
    }
    duplicateItems(planObjects) {
        const list = new this.kernelContainer.PlanObjectPtrList();
        planObjects.forEach((planObject) => {
            list.push_back(planObject);
        });
        return this.planInteractionHandler.duplicatePlanObjects(list, 1, true);
    }
    _rapiItemToKernelItem(rapiItem) {
        let catalogItem = new this._kernelContainer.CatalogItem(rapiItem.id);
        let size = catalogItem.size;
        size.x = rapiItem.width || 0;
        size.y = rapiItem.depth || 0;
        size.z = rapiItem.height || 0;
        catalogItem.size = size;
        catalogItem.flipable = rapiItem.flipable;
        if (rapiItem.layer) {
            catalogItem.layer = rapiItem.layer;
        }
        catalogItem.orderable = rapiItem.orderable;
        catalogItem.scaleable = rapiItem.scaleable;
        catalogItem.type = rapiItem.type || 'other';
        catalogItem.detailType = rapiItem.detailType || catalogItem.type || 'other';
        catalogItem.configuration = rapiItem.configuration || '';
        return catalogItem;
    }
    planObjectDeleted( /*objectId*/) {
        console.log('PlannerKernel: planObjectDeleted');
    }
    requestPlanObjectDimensions( /*id*/) {
        // debugger;
    }
    cleanUpCallbacks() {
        var _a;
        super.cleanUpCallbacks();
        if ((_a = this._kernelContainer) === null || _a === void 0 ? void 0 : _a.unregisterPlannerCallback) {
            this._kernelContainer.unregisterPlannerCallback(this);
        }
    }
    registerCallbacks() {
        var _a;
        super.registerCallbacks();
        // *********************************************************************
        // Use proxy if kernel reports handle[name] is not defined then you'll
        // get a warning telling you which function is missing! Use this for
        // debug only!
        //
        // this._kernelContainer.registerPlannerCallback(new Proxy(this, {
        //     get(target, prop) {
        //         if ((target as any)[prop] === undefined) {
        //             console.warn('prop ' + prop.toString() + ' is missing');
        //             return (): void => undefined;
        //         }
        //         return (target as any)[prop];
        //     }
        // }));
        //
        // *********************************************************************
        if ((_a = this._kernelContainer) === null || _a === void 0 ? void 0 : _a.registerPlannerCallback) {
            this._kernelContainer.registerPlannerCallback(this);
        }
    }
    planElementRemoved(element) {
        this._plannerKernelCallbackListener.forEach((listener) => listener.planElementRemoved(element));
        this._plannerKernelCallbackListener.forEach((listener) => listener.removePlanObjectFromScene(element.extRef.jsObject));
        this._decoupleReferences(element);
    }
    handlerSwitchedPlans(fromPlan, toPlan) {
        this._decoupleReferences(fromPlan);
        if (toPlan) {
            this._plannerKernelCallbackListener.forEach((listener) => listener.handlerSwitchedPlans(fromPlan, toPlan));
        }
    }
    planBoundsChanged() {
        this._plannerKernelCallbackListener.forEach((listener) => listener.planBoundsChanged());
    }
    planCleared() {
        console.log('PlannerKernel: planCleared');
        this._plannerKernelCallbackListener.forEach((listener) => listener.planCleared());
    }
    planCompletelyLoaded(plan) {
        console.log('PlannerKernel: planCompletelyLoaded');
        this._plannerKernelCallbackListener.forEach((listener) => listener.planCompletelyLoaded(plan));
    }
    planElement3dMeshChanged(plan, element) {
        console.log('PlannerKernel: planElement3dMeshChanged');
        if (element.extRef) {
            const planElementViewModel = element.extRef
                .jsObject;
            for (let i = planElementViewModel.getObject().children.length - 1; i >= 0; i--) {
                planElementViewModel
                    .getObject()
                    .remove(planElementViewModel.getObject().children[i]);
            }
        }
        this.planModelViewHelper.requestMesh3d(element);
    }
    async _onStaticItemAdded(plan, element) {
        let planObjectViewModel;
        if (this.isConstructionPlanElement(element)) {
            planObjectViewModel = new ConstructionPlanObjectViewModel(element);
        }
        else {
            planObjectViewModel = new StaticPlanObjectViewModel(element);
        }
        this.coupleReferences(planObjectViewModel, element);
        let planViewModel = plan.extRef.jsObject;
        planViewModel.addPlanElementViewModel(planObjectViewModel);
        const catalogItemId = element.getCatalogItemId();
        if (catalogItemId) {
            const rapiItem = await this._rapiAccess.getItem(catalogItemId);
            planObjectViewModel.setRapiItem(rapiItem);
            this._plannerKernelCallbackListener.forEach((listener) => listener.addPlanObjectToScene(planObjectViewModel));
        }
    }
    _onConfigurableItemAdded(plan, element) {
        const planObjectViewModel = new ConfiguratorPlanObjectViewModel(element);
        this.coupleReferences(planObjectViewModel, element);
        let planViewModel = plan.extRef.jsObject;
        planViewModel.addPlanElementViewModel(planObjectViewModel);
        this._plannerKernelCallbackListener.forEach((listener) => listener.addPlanObjectToScene(planObjectViewModel));
    }
    async planElementAdded(plan, element) {
        console.log('PlannerKernel: planElementAdded');
        if (plan && plan.extRef) {
            if (element.getType() === this._kernelContainer.PlanElementType.OBJECT) {
                if (element.hasConfiguration()) {
                    this._onConfigurableItemAdded(plan, element);
                }
                else {
                    await this._onStaticItemAdded(plan, element);
                }
            }
            else {
                const planObject = element;
                let planElementViewModel;
                if (element.getType() === this._kernelContainer.PlanElementType.WALL) {
                    planElementViewModel = new WallPlanElementViewModel(planObject);
                }
                else if (element.getType() === this._kernelContainer.PlanElementType.FLOOR) {
                    planElementViewModel = new FloorPlanElementViewModel(planObject);
                }
                else if (element.getType() === this._kernelContainer.PlanElementType.CEILING) {
                    planElementViewModel = new CeilingPlanElementViewModel(planObject);
                }
                else if (element.getType() === this._kernelContainer.PlanElementType.NODE) {
                    planElementViewModel = new NodePlanElementViewModel(planObject);
                }
                else if (element.getType() === this._kernelContainer.PlanElementType.MEASURE) {
                    planElementViewModel = new MeasurementLinePlanElementViewModel(planObject);
                }
                if (!planElementViewModel) {
                    return;
                }
                this.coupleReferences(planElementViewModel, planObject);
                const planViewModel = plan.extRef.jsObject;
                planViewModel.addPlanElementViewModel(planElementViewModel);
                {
                    this.planModelViewHelper.requestMesh3d(element);
                }
                // "hack" to update scene, construction elements are added to the group and not the scene directly
                this._plannerKernelCallbackListener.forEach((listener) => listener.addPlanObjectToScene(null));
            }
        }
    }
    planElementChanged(plan, element) {
        if (element.extRef) {
            let planElement = element.extRef.jsObject;
            planElement.update();
            this._plannerKernelCallbackListener.forEach((listener) => listener.planElementChanged(plan, planElement));
        }
        console.log('PlannerKernel: planElementChanged');
    }
    planHistoryStateChanged() {
        console.log('PlannerKernel: planHistoryStateChanged');
        if (!this.planInteractionHandler) {
            return;
        }
        this._plannerKernelCallbackListener.forEach((listener) => listener.planHistoryStateChanged());
        this._roomlePlannerUiCallback.onHistoryChange(this.planInteractionHandler.isUndoPossible(), this.planInteractionHandler.isRedoPossible());
    }
    planObjectConfigurationCreated(_plan, _element) {
        // if (plan && plan.extRef && element && element.extRef) {
        //     let planObjectViewModel = element.extRef.jsObject as PlanObjectViewModel;
        //     planObjectViewModel.setRuntimeId(element.getConfigurationRuntimeId());
        // }
        console.log('PlannerKernel: planObjectConfigurationCreated');
    }
    planObjectConfigurationLoaded(plan, element, success) {
        if (plan && plan.extRef && element && element.extRef) {
            let planObjectViewModel = element.extRef.jsObject;
            let runtimeId = planObjectViewModel
                .getPlanObject()
                .getConfigurationRuntimeId();
            if (runtimeId > 0) {
                this._plannerKernelCallbackListener.forEach((listener) => listener.planObjectConfigurationLoaded(plan, element, success));
            }
        }
        console.log('PlannerKernel: planObjectConfigurationLoaded');
    }
    requestCatalogItem(_catalogItemId) {
        console.log('PlannerKernel: requestCatalogItem');
    }
    startedDrawing() {
        this._plannerKernelCallbackListener.forEach((callback) => callback.startedDrawing());
    }
    stoppedDrawing() {
        this._plannerKernelCallbackListener.forEach((callback) => callback.stoppedDrawing());
    }
    updateMesh2d() {
        console.log('PlannerKernel: updateMesh2d');
    }
    beginConstruction() {
        console.log('PlannerKernel: beginConstruction');
    }
    addMesh(planElement, material, vertices, indices, uvCoords, normals) {
        console.log('PlannerKernel: addMesh');
        this._plannerKernelCallbackListener.forEach((listener) => listener.addMesh(planElement, material, vertices, indices, uvCoords, normals));
    }
    endConstruction() {
        console.log('PlannerKernel: endConstruction');
    }
    beginPlanConstruction(plan) {
        console.log('PlannerKernel: beginPlanConstruction');
        this._plannerKernelCallbackListener.forEach((listener) => listener.beginPlanConstruction(plan));
    }
    addPlanMesh(plan, material, vertices, indices, uvCoords, normals, type) {
        console.log('PlannerKernel: addPlanMesh');
        this._plannerKernelCallbackListener.forEach((listener) => listener.addPlanMesh(plan, material, vertices, indices, uvCoords, normals, type));
    }
    endPlanConstruction(plan) {
        console.log('PlannerKernel: endPlanConstruction');
        this._plannerKernelCallbackListener.forEach((listener) => listener.endPlanConstruction(plan));
    }
    async addPlanObjectFromItem(rapiElement, position, rotation) {
        if (!position && !rotation) {
            const elements = await this.insertItems([rapiElement]);
            if (elements.length !== 1) {
                throw new Error('It was expected that 1 element is added but' +
                    elements.length +
                    'were added');
            }
            return elements[0];
        }
        rotation = !rotation && rotation !== 0 ? 0 : rotation;
        position = !position ? { x: 0, y: 0, z: 0 } : position;
        const kernelItem = this._planInteractionHandler.addPlanObjectFromItem(this._rapiItemToKernelItem(rapiElement), position, rotation, false);
        const planViewModel = this._planInteractionHandler.getPlan().extRef.jsObject;
        let object;
        if (kernelItem.hasConfiguration()) {
            object = planViewModel.getConfigurablePlanObjectForId(kernelItem.getId());
            if (!object) {
                console.warn('Could not find configuration');
            }
        }
        else {
            object = planViewModel.getStaticPlanObjectViewModelForId(kernelItem.getId());
            if (!object) {
                console.warn('Could not find static item');
            }
            else {
                await object.setRapiItem(rapiElement);
            }
        }
        await object.isInitDone();
        return object.getId();
    }
    coupleReferences(jsObject, coreReference) {
        let reference = new this._kernelContainer.EMSReference();
        reference.jsObject = jsObject;
        coreReference.extRef = reference;
    }
    _decoupleReferences(coreReference) {
        if (coreReference && coreReference.extRef) {
            coreReference.extRef.jsObject.clearReference();
            coreReference.extRef.jsObject = null;
            coreReference.extRef.delete();
            coreReference.extRef = null;
        }
    }
    isConstructionPlanElement(planElement) {
        const ConstructionObject = this.kernelContainer
            .ConstructionObject;
        return planElement instanceof ConstructionObject;
    }
}
__decorate([
    inject
], PlannerKernelAccess.prototype, "_kernelAccessCallback", void 0);
__decorate([
    inject
], PlannerKernelAccess.prototype, "_roomlePlannerUiCallback", void 0);

class PlannerMeshGenerator extends MeshGenerator {
    constructor(creator) {
        super(creator);
        this._wallMeshes = [];
        this._defaultMaterial = MaterialCreator.createMeshPhysicalMaterial({
            color: '#ffffff',
            side: DoubleSide,
        });
    }
    generateGeometry(meshId = null, vertices, indices, uvCoords, normals, newGeometryInstance = false) {
        let geometry;
        if (newGeometryInstance) {
            geometry = this._generateGeometry(meshId, vertices, indices, uvCoords, normals).clone();
        }
        else {
            geometry = this._generateGeometry(meshId, vertices, indices, uvCoords, normals);
        }
        return geometry;
    }
    generateMesh(runtimeComponentId = 0, geometryId = null, materialId, vertices, indices, uvCoords, normals, type, newGeometryInstance = false, materialAttributes) {
        let geometry;
        if (newGeometryInstance) {
            geometry = this._generateGeometry(geometryId, vertices, indices, uvCoords, normals).clone();
        }
        else {
            geometry = this._generateGeometry(geometryId, vertices, indices, uvCoords, normals);
        }
        const mesh = this._createMesh(runtimeComponentId, geometryId, geometry);
        mesh.userData.materialId = materialId;
        mesh.layers.set(4 /* LAYER.COMPONENT */);
        if (materialId) {
            this.setMaterial(mesh, materialId, type, materialAttributes).then(() => {
                if (runtimeComponentId && geometryId && materialId) {
                    this._geometryComponentMaterialCache.set(this._getComponentMeshId(runtimeComponentId, geometryId), materialId);
                }
                const isFloor = type && type.value === 3 /* PlanElementType.FLOOR */;
                const isWall = type && type.value === 1 /* PlanElementType.WALL */;
                mesh.castShadow = !isFloor && !isWall;
            });
        }
        this._checkWallMaterial(mesh, type);
        return mesh;
    }
    async setMaterial(mesh, material, type, materialAttributes) {
        mesh.userData.materialId = getMaterialId(material, type);
        if (isString(material)) {
            // this if statement can be removed when this has been resolved: http://source.roomle.local/Shared/RoomleModel/issues/210
            if (!material) {
                console.warn('Used default material because material is empty');
                this.changeMaterialOfMesh(mesh, this._getDefaultMaterial(type));
            }
            else {
                await this._assignMaterial(mesh, material, materialAttributes);
            }
        }
        else {
            //@todo remove this statement when this issue has been resolved: http://source.roomle.local/Shared/RoomleModel/issues/221
            if (!material) {
                this.changeMaterialOfMesh(mesh, this._configuratorPreviewMaterial);
                return;
            }
            material = material;
            if (material.getSourceType().value === 2 /* MaterialSourceType.Material */) {
                await this._assignMaterial(mesh, material.materialId, materialAttributes);
            }
            else if (material.getSourceType().value === 1 /* MaterialSourceType.CatalogItem */) {
                await this._assignItem(mesh, material.catalogItemId);
            }
            else if (material.getSourceType().value === 3 /* MaterialSourceType.RgbValue */) {
                await this._assignRGB(mesh, material.rgbValue);
            }
            else if (material.getSourceType().value === 0 /* MaterialSourceType.None */) {
                this.changeMaterialOfMesh(mesh, this._getDefaultMaterial(type));
            }
            else {
                this.changeMaterialOfMesh(mesh, this._getDefaultMaterial(type));
                if (type.value !== 1 /* PlanElementType.WALL */ &&
                    type.value !== 7 /* PlanElementType.CEILING */ &&
                    type.value !== 3 /* PlanElementType.FLOOR */) {
                    console.warn('Used default material because material is not supported', material);
                }
            }
        }
    }
    _getDefaultMaterial(type) {
        if ((type === null || type === void 0 ? void 0 : type.value) === 3 /* PlanElementType.FLOOR */) {
            return this._defaultMaterialFloor;
        }
        return this._defaultMaterial;
    }
    set maxAnisotropy(maxAnisotropy) {
        this._maxAnisotropy = maxAnisotropy;
    }
    _checkWallMaterial(mesh, type) {
        if (type && type.value === 1 /* PlanElementType.WALL */) {
            mesh.renderOrder = 5 /* PLANNER_RENDER_ORDER.WALL */;
            this._wallMeshes.push(mesh);
        }
    }
    clear() {
        super.clear();
        this.clearWallMeshes();
    }
    clearWallMeshes() {
        this._wallMeshes.forEach((wallMesh) => {
            disposeMesh(wallMesh);
        });
        this._wallMeshes = [];
    }
    get wallMeshes() {
        return this._wallMeshes;
    }
}

// Placeholder for Kernel Enum
let KERNEL_UNIT = {
    InchFeet: null,
    Feet: null,
    MM: null,
    CM: null,
    Inch: null,
};
// Placeholder for Kernel Enum
let KERNEL_UNIT_STRING_TYPE = {
    NoUnitString: null,
    LongUnitString: null,
    ShortUnitString: null,
};
const UNIT_STRING = {
    MM: 'mm',
    CM: 'cm',
    // eslint-disable-next-line @typescript-eslint/quotes
    FEET_SHORT: "'",
    FEET: 'ft',
    INCH_SHORT: '"',
    INCH: 'inch',
    SQ_METER: 'm',
    SQ_FEET: 'sqft',
};
const MEASUREMENT_SYSTEM_STRING = {
    IMPERIAL: 'imperial',
    METRIC: 'metric',
};
const METRIC_UNIT_TYPES = ['mm', 'cm', 'feet'];
const IMPERIAL_UNIT_TYPES = ['inch', 'inchfeet'];
class UnitFormatter {
    constructor(creator) {
        this._formatter = null;
        this._precision = 0;
        this._creator_ = creator;
    }
    init(kernelContainer) {
        const formatter = new kernelContainer.UnitMeasureFormatter();
        // Assign Kernel Enums so that we don't have to access KernelContainer all the time
        KERNEL_UNIT = kernelContainer.Unit; // use constants from C/C++ and attach them to a JS variable
        KERNEL_UNIT_STRING_TYPE = kernelContainer.UnitStringType;
        this._initActualUnit();
        this._initMeasurementSystemType();
        this._initActualUnitStringType();
        // use max precision 2 until we find a better solution! problem is feet inch vs mm
        const { precisionCm, precisionInch } = this._initData;
        if (this._actualUnit === KERNEL_UNIT.InchFeet) {
            this._precision =
                precisionInch !== undefined ? parseInt(precisionInch, 10) : 2;
        }
        else if (this._actualUnit === KERNEL_UNIT.CM) {
            this._precision =
                precisionCm !== undefined ? parseInt(precisionCm, 10) : 1;
        }
        formatter.init(UNIT_STRING.MM, UNIT_STRING.CM, UNIT_STRING.FEET_SHORT, UNIT_STRING.FEET, UNIT_STRING.INCH_SHORT, UNIT_STRING.INCH, UNIT_STRING.SQ_METER, UNIT_STRING.SQ_FEET, true, this._precision, true);
        this._formatter = formatter;
    }
    _initMeasurementSystemType() {
        let { measurementSystem, unit } = this._initData;
        this._actualMeasurementString = measurementSystem;
        if (!measurementSystem && unit) {
            this._actualUnitString = unit;
            const isMetric = METRIC_UNIT_TYPES.find((unitStr) => unitStr === unit);
            this._actualMeasurementString = isMetric
                ? MEASUREMENT_SYSTEM_STRING.METRIC
                : MEASUREMENT_SYSTEM_STRING.IMPERIAL;
            return;
        }
        if (measurementSystem === MEASUREMENT_SYSTEM_STRING.METRIC) {
            if (!unit) {
                unit = UNIT_STRING.CM;
            }
            const matchingMetricUnitString = METRIC_UNIT_TYPES.find((unitStr) => unitStr === unit);
            if (matchingMetricUnitString) {
                this._actualUnit = this._getKernelUnitEnum(unit);
                this._actualUnitString = matchingMetricUnitString;
            }
            else {
                console.warn('Unit is not a metric unit, using CM');
                this._actualUnit = KERNEL_UNIT.CM;
                this._actualUnitString = 'cm';
            }
        }
        if (measurementSystem === MEASUREMENT_SYSTEM_STRING.IMPERIAL) {
            if (!unit) {
                unit = UNIT_STRING.INCH;
            }
            const matchingImperialUnitString = IMPERIAL_UNIT_TYPES.find((unitStr) => unitStr === unit);
            if (matchingImperialUnitString) {
                this._actualUnit = this._getKernelUnitEnum(unit);
                this._actualUnitString = matchingImperialUnitString;
            }
            else {
                console.warn('Unit is not an imperial unit, using Inches');
                this._actualUnit = KERNEL_UNIT.Inch;
                this._actualUnitString = 'inch';
            }
        }
    }
    _initActualUnit() {
        const { unit } = this._initData;
        this._actualUnit = this._getKernelUnitEnum(unit);
    }
    _getKernelUnitEnum(unit) {
        switch (unit) {
            case 'cm':
                return KERNEL_UNIT.CM;
            case 'mm':
                return KERNEL_UNIT.MM;
            case 'inchfeet':
                return KERNEL_UNIT.InchFeet;
            case 'feet':
                return KERNEL_UNIT.Feet;
            case 'inch':
                return KERNEL_UNIT.Inch;
            default:
                return KERNEL_UNIT.CM;
        }
    }
    _initActualUnitStringType() {
        const { unitStringType } = this._initData;
        if (unitStringType && unitStringType !== 'short') {
            console.warn('Only short unit strings is supported at the moment');
        }
        this._actualUnitStringType = KERNEL_UNIT_STRING_TYPE.ShortUnitString;
    }
    _isFormatterReady() {
        if (!this._formatter) {
            console.warn('Formatter is not ready...');
            return false;
        }
        return true;
    }
    formatAngleValueToUnitString(value, parameter) {
        const decimals = parameter.type === "Integer" /* PARAMETER_KERNEL_TYPE.INTEGER */ ? 0 : 2;
        return value.toFixed(decimals) + '';
    }
    parseAngleValueFromUnitString(rotation) {
        return rotation.replace('', '').replace(/\s/g, '');
    }
    parseValue(value, parameter) {
        if (parameter.unitType === null ||
            parameter.unitType === "unknown" /* PARAMETER_UNIT_TYPES.UNKNOWN_UNIT */ ||
            parameter.unitType === "count" /* PARAMETER_UNIT_TYPES.COUNT */) {
            return value;
        }
        if (parameter.unitType === "length" /* PARAMETER_UNIT_TYPES.LENGTH */) {
            return this.parseMMValueFromUnitString(value, parameter.unitType);
        }
        if (parameter.unitType === "angle" /* PARAMETER_UNIT_TYPES.ANGLE */) {
            return this.parseAngleValueFromUnitString(value);
        }
        if (parameter.unitType === "area" /* PARAMETER_UNIT_TYPES.AREA */) {
            return this.parseAngleValueFromUnitString(value);
        }
        return value;
    }
    formatValueToUnitString(value, parameter) {
        if (parameter.unitType === null ||
            parameter.unitType === "unknown" /* PARAMETER_UNIT_TYPES.UNKNOWN_UNIT */ ||
            parameter.unitType === "count" /* PARAMETER_UNIT_TYPES.COUNT */) {
            if (parameter.type === "Integer" /* PARAMETER_KERNEL_TYPE.INTEGER */) {
                return value.toString();
            }
            else {
                return parseFloat(value.toString()).toFixed(2);
            }
        }
        if (parameter.unitType === "length" /* PARAMETER_UNIT_TYPES.LENGTH */) {
            return this.formatMMValueToUnitString(value, parameter.unitType);
        }
        if (parameter.unitType === "angle" /* PARAMETER_UNIT_TYPES.ANGLE */) {
            return this.formatAngleValueToUnitString(value, parameter);
        }
        if (parameter.unitType === "area" /* PARAMETER_UNIT_TYPES.AREA */) {
            return this.formatSquareMMValueToUnitString(value);
        }
        return value;
    }
    isParseableNumber(aString) {
        return this._isFormatterReady()
            ? this._formatter.isParseableNumber(aString)
            : null;
    }
    isParseableUnitString(aString, parameter) {
        if (this._isFormatterReady()) {
            if (parameter.unitType === "angle" /* PARAMETER_UNIT_TYPES.ANGLE */) {
                // KERNEL DOES NOT PROVIDE A PARSE ANGLE FROM UNIT STRING BECAUSE IT'S ONLY REMOVING 
                return this._formatter.isParseableUnitString(this.parseAngleValueFromUnitString(aString), this._actualUnit);
            }
            else {
                return this._formatter.isParseableUnitString(aString, this._actualUnit);
            }
        }
        else {
            return null;
        }
    }
    parseMMValueFromUnitString(aString, unitType) {
        if (this._isFormatterReady()) {
            if (unitType === "count" /* PARAMETER_UNIT_TYPES.COUNT */) {
                return parseFloat(aString);
            }
            return this._formatter.parseMMValueFromUnitString(aString, this._actualUnit);
        }
        return null;
    }
    parseNumber(aString) {
        return this._isFormatterReady()
            ? this._formatter.parseNumber(aString)
            : null;
    }
    formatNumber(aValue, digit = 0) {
        return this._isFormatterReady()
            ? this._formatter.formatNumber(aValue, digit)
            : null;
    }
    formatSquareMMValueToUnitString(aValue) {
        return this._isFormatterReady()
            ? this._formatter.formatSquareMMValueToUnitString(aValue, this._actualUnit)
            : null;
    }
    formatMMValueToUnitString(aValue, unitType) {
        if (this._isFormatterReady()) {
            if (unitType === "count" /* PARAMETER_UNIT_TYPES.COUNT */) {
                return aValue.toString();
            }
            return this._formatter.formatMMValueToUnitString(aValue, this._actualUnit, this._actualUnitStringType);
        }
        return null;
    }
    formatMMValueWithReqMaxLength(aValue, reqMaxSize) {
        return this._isFormatterReady()
            ? this._formatter.formatMMValueWithReqMaxLength(aValue, this._actualUnit, reqMaxSize)
            : null;
    }
    _formatParameterValue(value, unitType) {
        if (unitType === "length" /* PARAMETER_UNIT_TYPES.LENGTH */) {
            return this.formatMMValueToUnitString(parseFloat(value));
        }
        if (unitType === "area" /* PARAMETER_UNIT_TYPES.AREA */) {
            return this.formatSquareMMValueToUnitString(parseFloat(value));
        }
        return value;
    }
    formatPartListParameter(parameter) {
        if (hasUnits(parameter)) {
            parameter.valueLabel = this._formatParameterValue(parameter.value, parameter.unitType);
        }
    }
    formatParameter(parameter) {
        parameter.valueLabel = this._formatParameterValue(parameter.value, parameter.unitType);
        if (isMaterial(parameter)) {
            parameter.uiType = "Material" /* PARAMETER_UI_TYPES.MATERIAL */;
        }
        else if (isBoolean(parameter)) {
            parameter.uiType = "Boolean" /* PARAMETER_UI_TYPES.BOOLEAN */;
        }
        else if (isRange(parameter)) {
            parameter.uiType = "Range" /* PARAMETER_UI_TYPES.RANGE */;
            const valueFrom = parameter.validRange.valueFrom !== null
                ? parameter.validRange.valueFrom
                : Number.MIN_SAFE_INTEGER;
            const valueTo = parameter.validRange.valueTo !== null
                ? parameter.validRange.valueTo
                : Number.MAX_SAFE_INTEGER;
            parameter.validRangeLabels = {
                valueFrom: this._formatParameterValue(valueFrom.toString(), parameter.unitType),
                valueTo: this._formatParameterValue(valueTo.toString(), parameter.unitType),
                type: parameter.validRange.type,
            };
        }
        else if (isOptions(parameter)) {
            parameter.uiType = "Options" /* PARAMETER_UI_TYPES.OPTIONS */;
            if (isThumbnail(parameter)) {
                parameter.uiType = "Thumbnails" /* PARAMETER_UI_TYPES.THUMBNAILS */;
            }
        }
        else {
            console.error('Could not detect uiType of param');
            parameter.uiType = null;
        }
    }
    isInch() {
        return this._actualUnit === KERNEL_UNIT.InchFeet;
    }
    getActualUnitString() {
        return this._actualUnitString;
    }
    getActualMeasurementString() {
        return this._actualMeasurementString;
    }
    getUnitStringType() {
        return this._initData.unitStringType;
    }
    getPrecision() {
        return this._precision;
    }
    getAllowedDelta() {
        const precision = 1 / Math.pow(10, this._precision);
        if (this.isInch()) {
            return precision * 25.4;
        }
        return precision;
    }
    setUnitInitData(unit, measurementSystem = '') {
        this._initData.unit = unit;
        this._initData.measurementSystem = measurementSystem;
        this._initActualUnit();
        this._initMeasurementSystemType();
        this._initActualUnitStringType();
        this._plannerKernelAccess.kernelInstance.setEnvironmentVariable('unit', this._actualUnitString);
    }
}
__decorate([
    inject
], UnitFormatter.prototype, "_initData", void 0);
__decorate([
    inject
], UnitFormatter.prototype, "_plannerKernelAccess", void 0);

class ConfiguratorHistory {
    constructor(creator) {
        this._history = [];
        this._index = 0;
        this._creator_ = creator;
    }
    /**
     * loads the configurationString of the configuration which was set before
     * only possible if there are some changes on the current item
     * @returns configurationString of lastAction or null if canUndo returns false
     */
    undo() {
        if (!this.canUndo()) {
            return null;
        }
        this._index++;
        const [lastConfiguration] = this._history.slice(this._index);
        if (this._index === this._history.length - 1) {
            this._configuratorUiCallbacks.onHistoryChange(false, true);
        }
        else {
            this._configuratorUiCallbacks.onHistoryChange(true, true);
        }
        return lastConfiguration;
    }
    /**
     * loads the configurationString of the configuration which was set before undo function was called
     * only possible if undo function was called before
     * @returns configurationString of configuration before undo was called or null if canRedo returns false
     */
    redo() {
        if (!this.canRedo()) {
            return null;
        }
        this._index--;
        const [lastConfiguration] = this._history.slice(this._index);
        if (this._index === 0) {
            this._configuratorUiCallbacks.onHistoryChange(true, false);
        }
        else {
            this._configuratorUiCallbacks.onHistoryChange(true, true);
        }
        return lastConfiguration;
    }
    /**
     * pushes new configurationString to history Array
     * is called when changes on the item happened
     * @param configurationString
     * @returns
     */
    push(configurationString) {
        const [lastConfiguration] = this._history.slice(this._index);
        if (lastConfiguration === configurationString) {
            return;
        }
        this._history = this._history.slice(this._index);
        this._history.unshift(configurationString);
        this._index = 0;
        if (this._history.length === 1) {
            this._configuratorUiCallbacks.onHistoryChange(false, false);
        }
        else {
            this._configuratorUiCallbacks.onHistoryChange(true, false);
        }
    }
    /**
     * checks if there are any changes on the item already happened
     * @returns true if the current configuration is not the default configuration
     */
    canUndo() {
        return this._index !== this._history.length - 1;
    }
    /**
     * checks if there are newer configurations
     * @returns true if current configuration is not the latest configuration
     */
    canRedo() {
        return this._index !== 0;
    }
    /**
     * @returns array of all configuration strings
     */
    getHistory() {
        return this._history;
    }
    /**
     * clears history and make new empty history array
     * sets index on 0 that no undo and redo is possible
     */
    clearHistory() {
        this._history = [];
        this._index = 0;
    }
}
__decorate([
    inject
], ConfiguratorHistory.prototype, "_configuratorUiCallbacks", void 0);

/* eslint-disable @typescript-eslint/no-unused-vars */
const PLAN_ELEMENT_CHANGE_TYPES = {
    ADDED: 'added',
    CHANGED: 'changed',
    REMOVED: 'removed',
};
class RoomlePlannerUiCallback extends UiCallback {
    constructor(creator) {
        super(creator);
        this.onItemsLoaded = () => {
            //override
        };
        this.onCameraChanged = (type) => {
            //override
        };
        this.onCameraIdle = () => {
            //override
        };
        this.onTotalFloorAreaChanged = (totalFloorArea) => {
            //override
        };
        this.onPlanInteractionHandlerCreated = (planInteractionHandler) => {
            //override
        };
        /**
         * is called when the planner kernel is ready. It returns the container and the instance
         * @param kernelContainer
         * @param kernelInstance
         */
        this.onPlannerKernelIsReady = (kernelContainer) => undefined; //TESTED
        /**
         * is called when the configurator kernel is ready. It returns the container and the instance
         * @param kernelContainer
         * @param kernelInstance
         */
        this.onConfiguratorKernelIsReady = (kernelContainer, kernelInstance) => undefined; //TESTED
        /**
         * When an item has been selected
         * @param selectionMode
         * @param objectType currently only static items and configurations are supported
         * @param payload returns the data which is available immediately (sync), currently this is catalogItemId and/or configurationRuntimeId
         * @param payloadPromise this promise resolves when the data of an object is fetched
         * @param planElementViewModel the plan element view model used internally, WARNING: this is a reference, use with caution
         */
        this.onSelectionChange = (selectionMode, objectType, payload, payloadPromise, planElementViewModel) => undefined;
        /**
         * When an item selection has been canceled
         */
        this.onSelectionCancel = (reason) => undefined;
        /**
         * When something in the plan has changed
         */
        this.onPlanChanged = () => undefined;
        /**
         * When an element in the plan has been added, removed or changed
         * null if changed, added or removed object is not a item or configuration, such as a wall or construction element
         */
        this.onPlanElementChanged = (changeType, changedObject) => undefined;
        /**
         * When the plan has been completely loaded
         */
        this.onCompletelyLoaded = () => undefined;
        /**
         * When rotation mode has been canceled
         */
        this.onRotationCancel = () => undefined;
        /**
         * gets called if history changes
         * @param undo true if undo is possible
         * @param redo true if redo is possible
         */
        this.onHistoryChange = (undo, redo) => undefined;
        /**
         * This function gets called when the camera is no longer moving
         * and the position of the wall dimensions can be calculated
         * @param wallDimensions
         */
        this.onUpdateWallDimensions = (wallDimensions) => undefined;
        /**
         * This function gets called when the camera is no longer moving
         * and the position of the measurement line dimensions can be calculated
         * @param measurementLineDimensions
         */
        this.onUpdateMeasurementLineDimensions = (measurementLineDimensions) => undefined;
        /**
         * This function gets called when the camera has stopped moving,
         * allowing for the calculation of the dimensions of construction elements' positions.
         * It is also called when an element is selected or dragged on the plan.
         * @param constructionMeasurementsMeasurements The measurements of construction elements.
         */
        this.onUpdateConstructionElementsMeasurements = (constructionMeasurementsMeasurements) => undefined;
        /**
         * This function gets called when the camera has stopped moving,
         * allowing for the calculation of the dimensions of plan element position.
         * It is also called when the element is selected or dragged on the plan.
         * @param objectMeasurements The measurements of plan element related to the walls plus object dimensions.
         */
        this.onUpdateObjectMeasurements = (objectMeasurements) => undefined;
        /**
         * This function gets called when the camera is moving and thus the wall dimensions should not be shown
         */
        this.disableWallDimensions = () => undefined;
        /**
         * This function gets called when the camera is no longer moving
         * it delivers all the positions of items in the plan normalized to the screen coordinates
         * @param planObjectPositions
         */
        this.onUpdatePlanObjectPositions = (planObjectPositions) => undefined;
        this.onDrawCancel = () => undefined;
        this.onHandlerSwitchedPlans = () => undefined;
        /**
         * This function gets called when a movable element begins to be dragged
         */
        this.onDragElementStart = () => undefined;
        /**
         * This function gets called when a movable element was being dragged before and is now released
         */
        this.onDragElementEnd = () => undefined;
        /**
         * This function gets called when a selectable element has been clicked on.
         * An equivalent function for component clicks is onClickComponent in the configurator-ui-callback.ts
         * @param planElement PlanElementViewModel instance of the clicked element
         */
        this.onClickElement = (planElement) => undefined;
        /*
         * This function gets called when a selectable element has been clicked on while multi-select is enabled.
         * @param selectedElements Array of PlanElementViewModel instances of the selected elements
         */
        this.onMultiSelectionChange = (selectedElements) => undefined;
        /*
         * This function gets called when the selection mode is changes
         * @param mode SELECTION_MODE can be standard or multiselect
         */
        this.onSelectionModeChange = (mode) => undefined;
        /*
         * This function is called upon activation of the measurement drawing mode and upon completion of the drawing process.
         * @param isActive send the active state while draw a measurement line
         */
        this.onMeasurementLineStateChange = (isActive) => undefined;
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
class ConfiguratorUiCallbacks extends UiCallback {
    constructor(creator) {
        super(creator);
        /**
         * When kernel initialization is complete
         */
        this.onKernelIsReady = null; //TESTED --> deprecated
        /**
         * gets called when the screen position of components/previews changes
         * @param positions
         */
        this.onComponentPositionsUpdated = null;
        /**
         * When component parameters are changed/updated, this event is triggered
         * on start up and when a configuration changes
         * @param parameters
         */
        this.onUpdateParameters = (parameters) => undefined; //TESTED
        /**
         * When children of a component change, this event is triggered
         * on start up and when a configuration changes
         * @param tags
         * @param defaultChild
         */
        this.onUpdatePossibleChildren = (tags, defaultChild) => undefined; //TESTED
        /**
         * When the price of a configuration/item changes, this event is triggered
         * on start up and when a configuration changes
         * @param currencySymbol
         * @param price
         */
        this.onUpdatePrice = (currencySymbol, price) => undefined; //TESTED
        /**
         * When a/another (different) component has been selected
         * @param selectionMode
         * @param isRoot
         * @param hasChildren
         * @param components
         */
        this.onSelectionChange = (selectionMode, isRoot, hasChildren, components) => undefined; //TESTED
        /**
         * When a component or item selection has been canceled
         */
        this.onSelectionCancel = () => undefined; //TESTED
        /**
         * When part list has been changed/updated, this event is triggered
         * on start up and when a configuration changes
         * @param partList
         * @param hash
         */
        this.onPartListUpdate = (partList, hash) => undefined; //TESTED
        /**
         * When the bounds of the object are changed/updated, this event is triggered
         * on start up and when a configuration changes
         * @param bounds
         */
        this.onBoundsUpdate = (bounds) => undefined; //TESTED
        /**
         * When a new item or configuration is loading, this can be useful to display loading screens etc
         */
        this.onLoadConfiguration = () => undefined; //TESTED
        /**
         * When configuration has been loaded completely, this can be useful to hide loading indicators
         * @param partList
         * @param hash
         * @param rootComponentLabel
         */
        this.onConfigurationReady = (partList, hash, rootComponentLabel) => undefined; //TESTED
        /**
         * When UI should show the overlay based on the selected tag. Gets triggered when {@link @roomle/web-sdk/common-core/src/utils/shims#CommonInitData.startTag} is set
         * @param tag
         */
        this.onOpenTag = (tag) => undefined; //TESTED
        /**
         * When UI should show add ons
         */
        this.onOpenAddOns = () => undefined; //TESTED
        /**
         * When the user clicks on no UI element, can be used to deselect
         */
        this.onClickOutside = () => undefined; //TESTED
        /**
         * Is triggered when {@link @roomle/web-sdk/configurator-core/src/roomle-configurator#RoomleConfigurator.previewDockings} has no available dockings
         */
        this.onNoDockingsAvailable = () => undefined; //TESTED
        /**
         * When the configuration overlaps the UI (defined by {@link @roomle/web-sdk/common-core/src/common-interfaces#CanvasOffset})
         * @param intersections
         */
        this.onUiIntersectionChange = (intersections) => undefined; //TESTED
        /**
         * When the zoom level has been changed by the user
         * @param minZoom true when zoomed out as far as possible
         * @param maxZoom true when zoomed in as much as possible
         */
        this.onZoomChange = (minZoom, maxZoom) => undefined; //TESTED
        /**
         * When the use clicks on a configurable element twice to zoom the camera onto said element.
         * Doesn't matter if triggered by the user or via SDK
         */
        this.onZoomToComponent = () => undefined;
        /**
         * When the visibility of the dimensions changes from visible to gone or vice versa.
         * Doesn't matter if triggered by the user or via SDK
         * @param visible
         */
        this.onDimensionsVisibilityChange = (visible) => undefined; //TESTED
        /**
         * When not connected to the internet
         * @param error
         */
        this.onErrorDueToOffline = (error) => undefined; //TESTED
        /**
         * When any generic error is thrown while requesting data
         * @param error
         */
        this.onError = (error) => undefined; //TESTED
        /**
         * When dockings/ghosts are no longer visible
         */
        this.onDockingsPreviewRemoved = () => undefined; //TESTED
        /**
         * Updates when the current configuration changes
         * @param hasChildren
         */
        this.onConfigurationHasChildren = (hasChildren) => undefined; //TESTED
        /**
         * This method is used to track timings, this can be helpful to identify performance bottel necks
         * @hidden
         * @param category
         * @param label
         * @param time
         * @param meta
         */
        this.onTrackTiming = (category, label, time, meta) => undefined;
        /**
         * When a dock component call has been completed
         * @param childDbId the database id of the component which is docked
         * @param childDockId the number of the dock position
         * @param parentDbId the database id of the component to which is docked
         * @param parentDockId the number of the dock position to which is docked
         * @param position vector where the dock is done can be null
         */
        this.onUserInitiatedDockDone = (childDbId, childDockId, parentDbId, parentDockId, position) => undefined;
        /**
         * When user hovers over an addon plus symbol
         */
        this.onAddonPlusHover = () => undefined; // hard to test
        /**
         * When user hovers over an addon plus symbol
         */
        this.onAddonPlusHoverOff = () => undefined; // hard to test
        /**
         * When all addon plus symbols are shown in the user interface
         */
        this.onAddonPlusShown = () => undefined; // hard to test
        /**
         * When all addon plus symbols are hidden in the user interface
         */
        this.onAddonPlusHidden = () => undefined; // hard to test
        /**
         * When an asset could not be loaded (for example an image or texture). See paths or ids to identify the problem.
         * @param data
         */
        this.onContentProblem = (data) => undefined; //TESTED
        /**
         * When a sync has been started
         */
        this.onSyncStarted = () => undefined;
        /**
         * When a previously requested sync has been completed
         */
        this.onSyncDone = () => undefined;
        /**
         * When UI should show floor material selection
         */
        this.onOpenFloorMaterials = () => undefined; // UNUSED
        /**
         * When UI should show part list
         */
        this.onOpenPartList = () => undefined;
        /**
         * When a requested component could not be loaded from RAPI
         * @param error
         * @param id
         */
        this.onComponentLoadError = (error, id) => undefined;
        /**
         * Gets called when configuration/configurable-item could not be loaded
         */
        this.onConfigurationLoadError = () => undefined;
        /**
         * When {@link @roomle/web-sdk/configurator-core/src/roomle-configurator#RoomleConfigurator.changeTypeChangeTag} as been called and the sync has been started
         * @param rapiId
         */
        this.onChangeTypeChangeTag = (rapiId) => undefined;
        /**
         * When {@link @roomle/web-sdk/configurator-core/src/roomle-configurator#RoomleConfigurator.removeTypeChangeTag} as been called
         * @param rapiId
         */
        this.onRemoveTypeChangeTag = (rapiId) => undefined;
        /**
         * Gets called when a new item/configuration has been loaded
         * @param catalogName
         * @param rapiItemLabel
         * @param rootComponentLabel
         */
        this.onConfigurationLabelChange = (catalogName, rapiItemLabel, rootComponentLabel) => undefined; //TESTED
        /**
         * When kernel failed to load a mesh
         */
        this.onMemoryCorruption = () => undefined; //TESTED
        /**
         * is called when the configurator kernel is ready. It returns the container and the instance
         * @param kernelContainer
         * @param kernelInstance
         */
        this.onConfiguratorKernelIsReady = (kernelContainer, kernelInstance) => undefined; //TESTED
        /**
         * is called when the configuration is saved to our backend
         */
        this.onConfigurationSaved = (configurationHash) => undefined;
        /**
         * called when camera position starts to change or is changing at the moment
         */
        this.onCameraPositionChanges = () => undefined;
        /**
         * gets called if history changes
         * @param undo true if undo is possible
         * @param redo true if redo is possible
         */
        this.onHistoryChange = (undo, redo) => undefined;
        /**
         * This function gets called when a selectable component on a configurable element has been clicked on.
         * An equivalent function for component clicks is onClickElement in the roomle-planner-ui-callback.ts
         * @param component RoomleComponent instance of the clicked component
         */
        this.onClickComponent = (component) => undefined;
        /**
         * This function gets called when an external mesh is requested
         * @param meshId meshId
         * @param quality number between 0 and 100
         * @returns void
         */
        this.onRequestExternalMesh = (meshId, quality) => undefined;
        /**
         * This function gets called when a geometry is ready
         * @param runtimeId number
         * @returns void
         */
        this.onGeometryReady = (runtimeId) => undefined;
        /**
         * This function gets called when a geometry is not ready
         * @param runtimeId
         * @returns
         */
        this.onGeometryNotReady = (runtimeId) => undefined;
    }
}

class RoomleToolsCore {
    constructor(creator) {
        this._kernelCallbacks = {
            isReady: () => undefined,
            throw: (error) => console.error('Kernel exception', error),
            log: (_log) => undefined,
            error: (_line, _column, _message, _source) => undefined,
            message: (messageObject) => {
                if (this._analyzeComponentCallback) {
                    this._analyzeComponentCallback(messageObject);
                }
            },
        };
        this._creator_ = creator;
    }
    async init() {
        if (this._toolsCoreInstance) {
            return Promise.resolve();
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const toolsContainer = {
            locateFile(filename) {
                // Because of fingerprinting we need to redirect Emscripten
                if (filename === 'RoomleToolsCore.wasm') {
                    return getAssetPath() + TOOLS_CORE_WASM_FILE_NAME;
                }
                return filename;
            },
            wasmBinaryFile: getAssetPath() + TOOLS_CORE_WASM_FILE_NAME,
            preRun: [],
            postRun: [],
            setStatus: null,
            print(msg) {
                self._kernelIo.log(msg);
            },
            printErr(err) {
                self._kernelIo.error(err);
            },
            quit(errorCode) {
                if (errorCode === 0) {
                    return;
                }
                self._kernelIo.throw(errorCode && errorCode.toString
                    ? errorCode.toString()
                    : 'Unknown error while C/C++ main executes');
            },
        };
        await this._scriptLoader.fetch(TOOLS_CORE_LOADER_FILE_NAME, {
            id: 'core-tool',
        });
        const toolsCoreModule = await window.RoomleToolsCore(toolsContainer);
        toolsCoreModule.setContext(this._kernelCallbacks);
        this._toolsCoreInstance = new toolsCoreModule.ToolsCore();
    }
    analyzeComponent(componentDefinition, source) {
        const messages = [];
        this._analyzeComponentCallback = (messageObject) => {
            messages.push(messageObject);
        };
        this._toolsCoreInstance.analyzeComponent(componentDefinition, source);
        this._analyzeComponentCallback = null;
        return Promise.resolve(messages);
    }
}
__decorate([
    inject
], RoomleToolsCore.prototype, "_scriptLoader", void 0);
__decorate([
    inject
], RoomleToolsCore.prototype, "_kernelIo", void 0);

/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var durl = function (c) { return URL.createObjectURL(new Blob([c], { type: 'text/javascript' })); };
try {
    URL.revokeObjectURL(durl(''));
}
catch (e) {
    // We're in Deno or a very old browser
    durl = function (c) { return 'data:application/javascript;charset=UTF-8,' + encodeURI(c); };
}

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
// see fleb note
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new u32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return [b, r];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b[0];
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);
    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);
    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);
    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i)
        ++l[cd[i] - 1];
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 0; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >>> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
// fixed length map
var flrm = /*#__PURE__*/ hMap(flt, 9, 1);
// fixed distance map
var fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);
// find max of array
var max = function (a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
        if (a[i] > m)
            m = a[i];
    }
    return m;
};
// read d, starting at bit p and mask with m
var bits = function (d, p, m) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;
};
// read d, starting at bit p continuing for at least 16 bits
var bits16 = function (d, p) {
    var o = (p / 8) | 0;
    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));
};
// get end of byte
var shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (s == null || s < 0)
        s = 0;
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
};
// expands raw DEFLATE data
var inflt = function (dat, buf, st) {
    // source length
    var sl = dat.length;
    if (!sl || (st && !st.l && sl < 5))
        return buf || new u8(0);
    // have to estimate size
    var noBuf = !buf || st;
    // no state
    var noSt = !st || st.i;
    if (!st)
        st = {};
    // Assumes roughly 33% compression ratio average
    if (!buf)
        buf = new u8(sl * 3);
    // ensure buffer can fit at least l elements
    var cbuf = function (l) {
        var bl = buf.length;
        // need to increase size to fit
        if (l > bl) {
            // Double or set to necessary, whichever is greater
            var nbuf = new u8(Math.max(bl * 2, l));
            nbuf.set(buf);
            buf = nbuf;
        }
    };
    //  last chunk         bitpos           bytes
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    // total bits
    var tbts = sl * 8;
    do {
        if (!lm) {
            // BFINAL - this is only 1 when last chunk is next
            st.f = final = bits(dat, pos, 1);
            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
                // go to end of byte boundary
                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;
                if (t > sl) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                // ensure size
                if (noBuf)
                    cbuf(bt + l);
                // Copy over uncompressed data
                buf.set(dat.subarray(s, t), bt);
                // Get new bitpos, update byte count
                st.b = bt += l, st.p = pos = t * 8;
                continue;
            }
            else if (type == 1)
                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
                //  literal                            lengths
                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
                var tl = hLit + bits(dat, pos + 5, 31) + 1;
                pos += 14;
                // length+distance tree
                var ldt = new u8(tl);
                // code length tree
                var clt = new u8(19);
                for (var i = 0; i < hcLen; ++i) {
                    // use index map to get real code
                    clt[clim[i]] = bits(dat, pos + i * 3, 7);
                }
                pos += hcLen * 3;
                // code lengths bits
                var clb = max(clt), clbmsk = (1 << clb) - 1;
                // code lengths map
                var clm = hMap(clt, clb, 1);
                for (var i = 0; i < tl;) {
                    var r = clm[bits(dat, pos, clbmsk)];
                    // bits read
                    pos += r & 15;
                    // symbol
                    var s = r >>> 4;
                    // code length to copy
                    if (s < 16) {
                        ldt[i++] = s;
                    }
                    else {
                        //  copy   count
                        var c = 0, n = 0;
                        if (s == 16)
                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                        else if (s == 17)
                            n = 3 + bits(dat, pos, 7), pos += 3;
                        else if (s == 18)
                            n = 11 + bits(dat, pos, 127), pos += 7;
                        while (n--)
                            ldt[i++] = c;
                    }
                }
                //    length tree                 distance tree
                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
                // max length bits
                lbt = max(lt);
                // max dist bits
                dbt = max(dt);
                lm = hMap(lt, lbt, 1);
                dm = hMap(dt, dbt, 1);
            }
            else
                throw 'invalid block type';
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
        }
        // Make sure the buffer can hold this + the largest possible addition
        // Maximum chunk size (practically, theoretically infinite) is 2^17;
        if (noBuf)
            cbuf(bt + 131072);
        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
        var lpos = pos;
        for (;; lpos = pos) {
            // bits read, code
            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;
            pos += c & 15;
            if (pos > tbts) {
                if (noSt)
                    throw 'unexpected EOF';
                break;
            }
            if (!c)
                throw 'invalid length/literal';
            if (sym < 256)
                buf[bt++] = sym;
            else if (sym == 256) {
                lpos = pos, lm = null;
                break;
            }
            else {
                var add = sym - 254;
                // no extra bits needed if less
                if (sym > 264) {
                    // index
                    var i = sym - 257, b = fleb[i];
                    add = bits(dat, pos, (1 << b) - 1) + fl[i];
                    pos += b;
                }
                // dist
                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;
                if (!d)
                    throw 'invalid distance';
                pos += d & 15;
                var dt = fd[dsym];
                if (dsym > 3) {
                    var b = fdeb[dsym];
                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;
                }
                if (pos > tbts) {
                    if (noSt)
                        throw 'unexpected EOF';
                    break;
                }
                if (noBuf)
                    cbuf(bt + 131072);
                var end = bt + add;
                for (; bt < end; bt += 4) {
                    buf[bt] = buf[bt - dt];
                    buf[bt + 1] = buf[bt + 1 - dt];
                    buf[bt + 2] = buf[bt + 2 - dt];
                    buf[bt + 3] = buf[bt + 3 - dt];
                }
                bt = end;
            }
        }
        st.l = lm, st.p = lpos, st.b = bt;
        if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
};
// empty
var et = /*#__PURE__*/ new u8(0);
// zlib valid
var zlv = function (d) {
    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))
        throw 'invalid zlib data';
    if (d[1] & 32)
        throw 'invalid zlib data: preset dictionaries not supported';
};
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */
function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }

/**
 * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.
 * Supports reading as UnsignedByte, HalfFloat and Float type data texture.
 *
 * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita
 * implementation, so I have preserved their copyright notices.
 */

// /*
// Copyright (c) 2014 - 2017, Syoyo Fujita
// All rights reserved.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Syoyo Fujita nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// */

// // TinyEXR contains some OpenEXR code, which is licensed under ------------

// ///////////////////////////////////////////////////////////////////////////
// //
// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas
// // Digital Ltd. LLC
// //
// // All rights reserved.
// //
// // Redistribution and use in source and binary forms, with or without
// // modification, are permitted provided that the following conditions are
// // met:
// // *       Redistributions of source code must retain the above copyright
// // notice, this list of conditions and the following disclaimer.
// // *       Redistributions in binary form must reproduce the above
// // copyright notice, this list of conditions and the following disclaimer
// // in the documentation and/or other materials provided with the
// // distribution.
// // *       Neither the name of Industrial Light & Magic nor the names of
// // its contributors may be used to endorse or promote products derived
// // from this software without specific prior written permission.
// //
// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// //
// ///////////////////////////////////////////////////////////////////////////

// // End of OpenEXR license -------------------------------------------------

class EXRLoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	parse( buffer ) {

		const USHORT_RANGE = ( 1 << 16 );
		const BITMAP_SIZE = ( USHORT_RANGE >> 3 );

		const HUF_ENCBITS = 16; // literal (value) bit length
		const HUF_DECBITS = 14; // decoding bit size (>= 8)

		const HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size
		const HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size
		const HUF_DECMASK = HUF_DECSIZE - 1;

		const NBITS = 16;
		const A_OFFSET = 1 << ( NBITS - 1 );
		const MOD_MASK = ( 1 << NBITS ) - 1;

		const SHORT_ZEROCODE_RUN = 59;
		const LONG_ZEROCODE_RUN = 63;
		const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;

		const ULONG_SIZE = 8;
		const FLOAT32_SIZE = 4;
		const INT32_SIZE = 4;
		const INT16_SIZE = 2;
		const INT8_SIZE = 1;

		const STATIC_HUFFMAN = 0;
		const DEFLATE = 1;

		const UNKNOWN = 0;
		const LOSSY_DCT = 1;
		const RLE = 2;

		const logBase = Math.pow( 2.7182818, 2.2 );

		function reverseLutFromBitmap( bitmap, lut ) {

			let k = 0;

			for ( let i = 0; i < USHORT_RANGE; ++ i ) {

				if ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {

					lut[ k ++ ] = i;

				}

			}

			const n = k - 1;

			while ( k < USHORT_RANGE ) lut[ k ++ ] = 0;

			return n;

		}

		function hufClearDecTable( hdec ) {

			for ( let i = 0; i < HUF_DECSIZE; i ++ ) {

				hdec[ i ] = {};
				hdec[ i ].len = 0;
				hdec[ i ].lit = 0;
				hdec[ i ].p = null;

			}

		}

		const getBitsReturn = { l: 0, c: 0, lc: 0 };

		function getBits( nBits, c, lc, uInt8Array, inOffset ) {

			while ( lc < nBits ) {

				c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
				lc += 8;

			}

			lc -= nBits;

			getBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );
			getBitsReturn.c = c;
			getBitsReturn.lc = lc;

		}

		const hufTableBuffer = new Array( 59 );

		function hufCanonicalCodeTable( hcode ) {

			for ( let i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;
			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;

			let c = 0;

			for ( let i = 58; i > 0; -- i ) {

				const nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );
				hufTableBuffer[ i ] = c;
				c = nc;

			}

			for ( let i = 0; i < HUF_ENCSIZE; ++ i ) {

				const l = hcode[ i ];
				if ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );

			}

		}

		function hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, hcode ) {

			const p = inOffset;
			let c = 0;
			let lc = 0;

			for ( ; im <= iM; im ++ ) {

				if ( p.value - inOffset.value > ni ) return false;

				getBits( 6, c, lc, uInt8Array, p );

				const l = getBitsReturn.l;
				c = getBitsReturn.c;
				lc = getBitsReturn.lc;

				hcode[ im ] = l;

				if ( l == LONG_ZEROCODE_RUN ) {

					if ( p.value - inOffset.value > ni ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					getBits( 8, c, lc, uInt8Array, p );

					let zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
					c = getBitsReturn.c;
					lc = getBitsReturn.lc;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				} else if ( l >= SHORT_ZEROCODE_RUN ) {

					let zerun = l - SHORT_ZEROCODE_RUN + 2;

					if ( im + zerun > iM + 1 ) {

						throw new Error( 'Something wrong with hufUnpackEncTable' );

					}

					while ( zerun -- ) hcode[ im ++ ] = 0;

					im --;

				}

			}

			hufCanonicalCodeTable( hcode );

		}

		function hufLength( code ) {

			return code & 63;

		}

		function hufCode( code ) {

			return code >> 6;

		}

		function hufBuildDecTable( hcode, im, iM, hdecod ) {

			for ( ; im <= iM; im ++ ) {

				const c = hufCode( hcode[ im ] );
				const l = hufLength( hcode[ im ] );

				if ( c >> l ) {

					throw new Error( 'Invalid table entry' );

				}

				if ( l > HUF_DECBITS ) {

					const pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];

					if ( pl.len ) {

						throw new Error( 'Invalid table entry' );

					}

					pl.lit ++;

					if ( pl.p ) {

						const p = pl.p;
						pl.p = new Array( pl.lit );

						for ( let i = 0; i < pl.lit - 1; ++ i ) {

							pl.p[ i ] = p[ i ];

						}

					} else {

						pl.p = new Array( 1 );

					}

					pl.p[ pl.lit - 1 ] = im;

				} else if ( l ) {

					let plOffset = 0;

					for ( let i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {

						const pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];

						if ( pl.len || pl.p ) {

							throw new Error( 'Invalid table entry' );

						}

						pl.len = l;
						pl.lit = im;

						plOffset ++;

					}

				}

			}

			return true;

		}

		const getCharReturn = { c: 0, lc: 0 };

		function getChar( c, lc, uInt8Array, inOffset ) {

			c = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );
			lc += 8;

			getCharReturn.c = c;
			getCharReturn.lc = lc;

		}

		const getCodeReturn = { c: 0, lc: 0 };

		function getCode( po, rlc, c, lc, uInt8Array, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {

			if ( po == rlc ) {

				if ( lc < 8 ) {

					getChar( c, lc, uInt8Array, inOffset );
					c = getCharReturn.c;
					lc = getCharReturn.lc;

				}

				lc -= 8;

				let cs = ( c >> lc );
				cs = new Uint8Array( [ cs ] )[ 0 ];

				if ( outBufferOffset.value + cs > outBufferEndOffset ) {

					return false;

				}

				const s = outBuffer[ outBufferOffset.value - 1 ];

				while ( cs -- > 0 ) {

					outBuffer[ outBufferOffset.value ++ ] = s;

				}

			} else if ( outBufferOffset.value < outBufferEndOffset ) {

				outBuffer[ outBufferOffset.value ++ ] = po;

			} else {

				return false;

			}

			getCodeReturn.c = c;
			getCodeReturn.lc = lc;

		}

		function UInt16( value ) {

			return ( value & 0xFFFF );

		}

		function Int16( value ) {

			const ref = UInt16( value );
			return ( ref > 0x7FFF ) ? ref - 0x10000 : ref;

		}

		const wdec14Return = { a: 0, b: 0 };

		function wdec14( l, h ) {

			const ls = Int16( l );
			const hs = Int16( h );

			const hi = hs;
			const ai = ls + ( hi & 1 ) + ( hi >> 1 );

			const as = ai;
			const bs = ai - hi;

			wdec14Return.a = as;
			wdec14Return.b = bs;

		}

		function wdec16( l, h ) {

			const m = UInt16( l );
			const d = UInt16( h );

			const bb = ( m - ( d >> 1 ) ) & MOD_MASK;
			const aa = ( d + bb - A_OFFSET ) & MOD_MASK;

			wdec14Return.a = aa;
			wdec14Return.b = bb;

		}

		function wav2Decode( buffer, j, nx, ox, ny, oy, mx ) {

			const w14 = mx < ( 1 << 14 );
			const n = ( nx > ny ) ? ny : nx;
			let p = 1;
			let p2;
			let py;

			while ( p <= n ) p <<= 1;

			p >>= 1;
			p2 = p;
			p >>= 1;

			while ( p >= 1 ) {

				py = 0;
				const ey = py + oy * ( ny - p2 );
				const oy1 = oy * p;
				const oy2 = oy * p2;
				const ox1 = ox * p;
				const ox2 = ox * p2;
				let i00, i01, i10, i11;

				for ( ; py <= ey; py += oy2 ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;
						const p10 = px + oy1;
						const p11 = p10 + ox1;

						if ( w14 ) {

							wdec14( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec14( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec14( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec14( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;

						} else {

							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

							i00 = wdec14Return.a;
							i10 = wdec14Return.b;

							wdec16( buffer[ p01 + j ], buffer[ p11 + j ] );

							i01 = wdec14Return.a;
							i11 = wdec14Return.b;

							wdec16( i00, i01 );

							buffer[ px + j ] = wdec14Return.a;
							buffer[ p01 + j ] = wdec14Return.b;

							wdec16( i10, i11 );

							buffer[ p10 + j ] = wdec14Return.a;
							buffer[ p11 + j ] = wdec14Return.b;


						}

					}

					if ( nx & p ) {

						const p10 = px + oy1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p10 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p10 + j ] );

						i00 = wdec14Return.a;
						buffer[ p10 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				if ( ny & p ) {

					let px = py;
					const ex = py + ox * ( nx - p2 );

					for ( ; px <= ex; px += ox2 ) {

						const p01 = px + ox1;

						if ( w14 )
							wdec14( buffer[ px + j ], buffer[ p01 + j ] );
						else
							wdec16( buffer[ px + j ], buffer[ p01 + j ] );

						i00 = wdec14Return.a;
						buffer[ p01 + j ] = wdec14Return.b;

						buffer[ px + j ] = i00;

					}

				}

				p2 = p;
				p >>= 1;

			}

			return py;

		}

		function hufDecode( encodingTable, decodingTable, uInt8Array, inOffset, ni, rlc, no, outBuffer, outOffset ) {

			let c = 0;
			let lc = 0;
			const outBufferEndOffset = no;
			const inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );

			while ( inOffset.value < inOffsetEnd ) {

				getChar( c, lc, uInt8Array, inOffset );

				c = getCharReturn.c;
				lc = getCharReturn.lc;

				while ( lc >= HUF_DECBITS ) {

					const index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;
					const pl = decodingTable[ index ];

					if ( pl.len ) {

						lc -= pl.len;

						getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

						c = getCodeReturn.c;
						lc = getCodeReturn.lc;

					} else {

						if ( ! pl.p ) {

							throw new Error( 'hufDecode issues' );

						}

						let j;

						for ( j = 0; j < pl.lit; j ++ ) {

							const l = hufLength( encodingTable[ pl.p[ j ] ] );

							while ( lc < l && inOffset.value < inOffsetEnd ) {

								getChar( c, lc, uInt8Array, inOffset );

								c = getCharReturn.c;
								lc = getCharReturn.lc;

							}

							if ( lc >= l ) {

								if ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {

									lc -= l;

									getCode( pl.p[ j ], rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

									c = getCodeReturn.c;
									lc = getCodeReturn.lc;

									break;

								}

							}

						}

						if ( j == pl.lit ) {

							throw new Error( 'hufDecode issues' );

						}

					}

				}

			}

			const i = ( 8 - ni ) & 7;

			c >>= i;
			lc -= i;

			while ( lc > 0 ) {

				const pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];

				if ( pl.len ) {

					lc -= pl.len;

					getCode( pl.lit, rlc, c, lc, uInt8Array, inOffset, outBuffer, outOffset, outBufferEndOffset );

					c = getCodeReturn.c;
					lc = getCodeReturn.lc;

				} else {

					throw new Error( 'hufDecode issues' );

				}

			}

			return true;

		}

		function hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {

			const outOffset = { value: 0 };
			const initialInOffset = inOffset.value;

			const im = parseUint32( inDataView, inOffset );
			const iM = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			const nBits = parseUint32( inDataView, inOffset );

			inOffset.value += 4;

			if ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {

				throw new Error( 'Something wrong with HUF_ENCSIZE' );

			}

			const freq = new Array( HUF_ENCSIZE );
			const hdec = new Array( HUF_DECSIZE );

			hufClearDecTable( hdec );

			const ni = nCompressed - ( inOffset.value - initialInOffset );

			hufUnpackEncTable( uInt8Array, inOffset, ni, im, iM, freq );

			if ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {

				throw new Error( 'Something wrong with hufUncompress' );

			}

			hufBuildDecTable( freq, im, iM, hdec );

			hufDecode( freq, hdec, uInt8Array, inOffset, nBits, iM, nRaw, outBuffer, outOffset );

		}

		function applyLut( lut, data, nData ) {

			for ( let i = 0; i < nData; ++ i ) {

				data[ i ] = lut[ data[ i ] ];

			}

		}

		function predictor( source ) {

			for ( let t = 1; t < source.length; t ++ ) {

				const d = source[ t - 1 ] + source[ t ] - 128;
				source[ t ] = d;

			}

		}

		function interleaveScalar( source, out ) {

			let t1 = 0;
			let t2 = Math.floor( ( source.length + 1 ) / 2 );
			let s = 0;
			const stop = source.length - 1;

			while ( true ) {

				if ( s > stop ) break;
				out[ s ++ ] = source[ t1 ++ ];

				if ( s > stop ) break;
				out[ s ++ ] = source[ t2 ++ ];

			}

		}

		function decodeRunLength( source ) {

			let size = source.byteLength;
			const out = new Array();
			let p = 0;

			const reader = new DataView( source );

			while ( size > 0 ) {

				const l = reader.getInt8( p ++ );

				if ( l < 0 ) {

					const count = - l;
					size -= count + 1;

					for ( let i = 0; i < count; i ++ ) {

						out.push( reader.getUint8( p ++ ) );

					}


				} else {

					const count = l;
					size -= 2;

					const value = reader.getUint8( p ++ );

					for ( let i = 0; i < count + 1; i ++ ) {

						out.push( value );

					}

				}

			}

			return out;

		}

		function lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {

			let dataView = new DataView( outBuffer.buffer );

			const width = channelData[ cscSet.idx[ 0 ] ].width;
			const height = channelData[ cscSet.idx[ 0 ] ].height;

			const numComp = 3;

			const numFullBlocksX = Math.floor( width / 8.0 );
			const numBlocksX = Math.ceil( width / 8.0 );
			const numBlocksY = Math.ceil( height / 8.0 );
			const leftoverX = width - ( numBlocksX - 1 ) * 8;
			const leftoverY = height - ( numBlocksY - 1 ) * 8;

			const currAcComp = { value: 0 };
			const currDcComp = new Array( numComp );
			const dctData = new Array( numComp );
			const halfZigBlock = new Array( numComp );
			const rowBlock = new Array( numComp );
			const rowOffsets = new Array( numComp );

			for ( let comp = 0; comp < numComp; ++ comp ) {

				rowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];
				currDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;
				dctData[ comp ] = new Float32Array( 64 );
				halfZigBlock[ comp ] = new Uint16Array( 64 );
				rowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );

			}

			for ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {

				let maxY = 8;

				if ( blocky == numBlocksY - 1 )
					maxY = leftoverY;

				let maxX = 8;

				for ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {

					if ( blockx == numBlocksX - 1 )
						maxX = leftoverX;

					for ( let comp = 0; comp < numComp; ++ comp ) {

						halfZigBlock[ comp ].fill( 0 );

						// set block DC component
						halfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];
						// set block AC components
						unRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );

						// UnZigZag block to float
						unZigZag( halfZigBlock[ comp ], dctData[ comp ] );
						// decode float dct
						dctInverse( dctData[ comp ] );

					}

					{

						csc709Inverse( dctData );

					}

					for ( let comp = 0; comp < numComp; ++ comp ) {

						convertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );

					}

				} // blockx

				let offset = 0;

				for ( let comp = 0; comp < numComp; ++ comp ) {

					const type = channelData[ cscSet.idx[ comp ] ].type;

					for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

						offset = rowOffsets[ comp ][ y ];

						for ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {

							const src = blockx * 64 + ( ( y & 0x7 ) * 8 );

							dataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );
							dataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );
							dataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );
							dataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );

							dataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );
							dataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );
							dataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );
							dataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );

							offset += 8 * INT16_SIZE * type;

						}

					}

					// handle partial X blocks
					if ( numFullBlocksX != numBlocksX ) {

						for ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {

							const offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;
							const src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );

							for ( let x = 0; x < maxX; ++ x ) {

								dataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );

							}

						}

					}

				} // comp

			} // blocky

			const halfRow = new Uint16Array( width );
			dataView = new DataView( outBuffer.buffer );

			// convert channels back to float, if needed
			for ( let comp = 0; comp < numComp; ++ comp ) {

				channelData[ cscSet.idx[ comp ] ].decoded = true;
				const type = channelData[ cscSet.idx[ comp ] ].type;

				if ( channelData[ comp ].type != 2 ) continue;

				for ( let y = 0; y < height; ++ y ) {

					const offset = rowOffsets[ comp ][ y ];

					for ( let x = 0; x < width; ++ x ) {

						halfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );

					}

					for ( let x = 0; x < width; ++ x ) {

						dataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );

					}

				}

			}

		}

		function unRleAC( currAcComp, acBuffer, halfZigBlock ) {

			let acValue;
			let dctComp = 1;

			while ( dctComp < 64 ) {

				acValue = acBuffer[ currAcComp.value ];

				if ( acValue == 0xff00 ) {

					dctComp = 64;

				} else if ( acValue >> 8 == 0xff ) {

					dctComp += acValue & 0xff;

				} else {

					halfZigBlock[ dctComp ] = acValue;
					dctComp ++;

				}

				currAcComp.value ++;

			}

		}

		function unZigZag( src, dst ) {

			dst[ 0 ] = decodeFloat16( src[ 0 ] );
			dst[ 1 ] = decodeFloat16( src[ 1 ] );
			dst[ 2 ] = decodeFloat16( src[ 5 ] );
			dst[ 3 ] = decodeFloat16( src[ 6 ] );
			dst[ 4 ] = decodeFloat16( src[ 14 ] );
			dst[ 5 ] = decodeFloat16( src[ 15 ] );
			dst[ 6 ] = decodeFloat16( src[ 27 ] );
			dst[ 7 ] = decodeFloat16( src[ 28 ] );
			dst[ 8 ] = decodeFloat16( src[ 2 ] );
			dst[ 9 ] = decodeFloat16( src[ 4 ] );

			dst[ 10 ] = decodeFloat16( src[ 7 ] );
			dst[ 11 ] = decodeFloat16( src[ 13 ] );
			dst[ 12 ] = decodeFloat16( src[ 16 ] );
			dst[ 13 ] = decodeFloat16( src[ 26 ] );
			dst[ 14 ] = decodeFloat16( src[ 29 ] );
			dst[ 15 ] = decodeFloat16( src[ 42 ] );
			dst[ 16 ] = decodeFloat16( src[ 3 ] );
			dst[ 17 ] = decodeFloat16( src[ 8 ] );
			dst[ 18 ] = decodeFloat16( src[ 12 ] );
			dst[ 19 ] = decodeFloat16( src[ 17 ] );

			dst[ 20 ] = decodeFloat16( src[ 25 ] );
			dst[ 21 ] = decodeFloat16( src[ 30 ] );
			dst[ 22 ] = decodeFloat16( src[ 41 ] );
			dst[ 23 ] = decodeFloat16( src[ 43 ] );
			dst[ 24 ] = decodeFloat16( src[ 9 ] );
			dst[ 25 ] = decodeFloat16( src[ 11 ] );
			dst[ 26 ] = decodeFloat16( src[ 18 ] );
			dst[ 27 ] = decodeFloat16( src[ 24 ] );
			dst[ 28 ] = decodeFloat16( src[ 31 ] );
			dst[ 29 ] = decodeFloat16( src[ 40 ] );

			dst[ 30 ] = decodeFloat16( src[ 44 ] );
			dst[ 31 ] = decodeFloat16( src[ 53 ] );
			dst[ 32 ] = decodeFloat16( src[ 10 ] );
			dst[ 33 ] = decodeFloat16( src[ 19 ] );
			dst[ 34 ] = decodeFloat16( src[ 23 ] );
			dst[ 35 ] = decodeFloat16( src[ 32 ] );
			dst[ 36 ] = decodeFloat16( src[ 39 ] );
			dst[ 37 ] = decodeFloat16( src[ 45 ] );
			dst[ 38 ] = decodeFloat16( src[ 52 ] );
			dst[ 39 ] = decodeFloat16( src[ 54 ] );

			dst[ 40 ] = decodeFloat16( src[ 20 ] );
			dst[ 41 ] = decodeFloat16( src[ 22 ] );
			dst[ 42 ] = decodeFloat16( src[ 33 ] );
			dst[ 43 ] = decodeFloat16( src[ 38 ] );
			dst[ 44 ] = decodeFloat16( src[ 46 ] );
			dst[ 45 ] = decodeFloat16( src[ 51 ] );
			dst[ 46 ] = decodeFloat16( src[ 55 ] );
			dst[ 47 ] = decodeFloat16( src[ 60 ] );
			dst[ 48 ] = decodeFloat16( src[ 21 ] );
			dst[ 49 ] = decodeFloat16( src[ 34 ] );

			dst[ 50 ] = decodeFloat16( src[ 37 ] );
			dst[ 51 ] = decodeFloat16( src[ 47 ] );
			dst[ 52 ] = decodeFloat16( src[ 50 ] );
			dst[ 53 ] = decodeFloat16( src[ 56 ] );
			dst[ 54 ] = decodeFloat16( src[ 59 ] );
			dst[ 55 ] = decodeFloat16( src[ 61 ] );
			dst[ 56 ] = decodeFloat16( src[ 35 ] );
			dst[ 57 ] = decodeFloat16( src[ 36 ] );
			dst[ 58 ] = decodeFloat16( src[ 48 ] );
			dst[ 59 ] = decodeFloat16( src[ 49 ] );

			dst[ 60 ] = decodeFloat16( src[ 57 ] );
			dst[ 61 ] = decodeFloat16( src[ 58 ] );
			dst[ 62 ] = decodeFloat16( src[ 62 ] );
			dst[ 63 ] = decodeFloat16( src[ 63 ] );

		}

		function dctInverse( data ) {

			const a = 0.5 * Math.cos( 3.14159 / 4.0 );
			const b = 0.5 * Math.cos( 3.14159 / 16.0 );
			const c = 0.5 * Math.cos( 3.14159 / 8.0 );
			const d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );
			const e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );
			const f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );
			const g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );

			const alpha = new Array( 4 );
			const beta = new Array( 4 );
			const theta = new Array( 4 );
			const gamma = new Array( 4 );

			for ( let row = 0; row < 8; ++ row ) {

				const rowPtr = row * 8;

				alpha[ 0 ] = c * data[ rowPtr + 2 ];
				alpha[ 1 ] = f * data[ rowPtr + 2 ];
				alpha[ 2 ] = c * data[ rowPtr + 6 ];
				alpha[ 3 ] = f * data[ rowPtr + 6 ];

				beta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];
				beta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];
				beta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];
				beta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];

				theta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );
				theta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );
				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];
				data[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];
				data[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];
				data[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];

				data[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];
				data[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];
				data[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];
				data[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];

			}

			for ( let column = 0; column < 8; ++ column ) {

				alpha[ 0 ] = c * data[ 16 + column ];
				alpha[ 1 ] = f * data[ 16 + column ];
				alpha[ 2 ] = c * data[ 48 + column ];
				alpha[ 3 ] = f * data[ 48 + column ];

				beta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];
				beta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];
				beta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];
				beta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];

				theta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );
				theta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );

				theta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];
				theta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];

				gamma[ 0 ] = theta[ 0 ] + theta[ 1 ];
				gamma[ 1 ] = theta[ 3 ] + theta[ 2 ];
				gamma[ 2 ] = theta[ 3 ] - theta[ 2 ];
				gamma[ 3 ] = theta[ 0 ] - theta[ 1 ];

				data[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];
				data[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];
				data[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];
				data[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];

				data[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];
				data[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];
				data[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];
				data[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];

			}

		}

		function csc709Inverse( data ) {

			for ( let i = 0; i < 64; ++ i ) {

				const y = data[ 0 ][ i ];
				const cb = data[ 1 ][ i ];
				const cr = data[ 2 ][ i ];

				data[ 0 ][ i ] = y + 1.5747 * cr;
				data[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;
				data[ 2 ][ i ] = y + 1.8556 * cb;

			}

		}

		function convertToHalf( src, dst, idx ) {

			for ( let i = 0; i < 64; ++ i ) {

				dst[ idx + i ] = DataUtils.toHalfFloat( toLinear( src[ i ] ) );

			}

		}

		function toLinear( float ) {

			if ( float <= 1 ) {

				return Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );

			} else {

				return Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );

			}

		}

		function uncompressRAW( info ) {

			return new DataView( info.array.buffer, info.offset.value, info.size );

		}

		function uncompressRLE( info ) {

			const compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = new Uint8Array( decodeRunLength( compressed ) );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressZIP( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );
			const tmpBuffer = new Uint8Array( rawBuffer.length );

			predictor( rawBuffer ); // revert predictor

			interleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPIZ( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };

			const outBuffer = new Uint16Array( info.width * info.scanlineBlockSize * ( info.channels * info.type ) );
			const bitmap = new Uint8Array( BITMAP_SIZE );

			// Setup channel info
			let outBufferEnd = 0;
			const pizChannelData = new Array( info.channels );
			for ( let i = 0; i < info.channels; i ++ ) {

				pizChannelData[ i ] = {};
				pizChannelData[ i ][ 'start' ] = outBufferEnd;
				pizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];
				pizChannelData[ i ][ 'nx' ] = info.width;
				pizChannelData[ i ][ 'ny' ] = info.lines;
				pizChannelData[ i ][ 'size' ] = info.type;

				outBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;

			}

			// Read range compression data

			const minNonZero = parseUint16( inDataView, inOffset );
			const maxNonZero = parseUint16( inDataView, inOffset );

			if ( maxNonZero >= BITMAP_SIZE ) {

				throw new Error( 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE' );

			}

			if ( minNonZero <= maxNonZero ) {

				for ( let i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {

					bitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );

				}

			}

			// Reverse LUT
			const lut = new Uint16Array( USHORT_RANGE );
			const maxValue = reverseLutFromBitmap( bitmap, lut );

			const length = parseUint32( inDataView, inOffset );

			// Huffman decoding
			hufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );

			// Wavelet decoding
			for ( let i = 0; i < info.channels; ++ i ) {

				const cd = pizChannelData[ i ];

				for ( let j = 0; j < pizChannelData[ i ].size; ++ j ) {

					wav2Decode(
						outBuffer,
						cd.start + j,
						cd.nx,
						cd.size,
						cd.ny,
						cd.nx * cd.size,
						maxValue
					);

				}

			}

			// Expand the pixel data to their original range
			applyLut( lut, outBuffer, outBufferEnd );

			// Rearrange the pixel data into the format expected by the caller.
			let tmpOffset = 0;
			const tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );
			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.channels; c ++ ) {

					const cd = pizChannelData[ c ];

					const n = cd.nx * cd.size;
					const cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );

					tmpBuffer.set( cp, tmpOffset );
					tmpOffset += n * INT16_SIZE;
					cd.end += n;

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressPXR( info ) {

			const compressed = info.array.slice( info.offset.value, info.offset.value + info.size );

			const rawBuffer = unzlibSync( compressed );

			const sz = info.lines * info.channels * info.width;
			const tmpBuffer = ( info.type == 1 ) ? new Uint16Array( sz ) : new Uint32Array( sz );

			let tmpBufferEnd = 0;
			let writePtr = 0;
			const ptr = new Array( 4 );

			for ( let y = 0; y < info.lines; y ++ ) {

				for ( let c = 0; c < info.channels; c ++ ) {

					let pixel = 0;

					switch ( info.type ) {

						case 1:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							tmpBufferEnd = ptr[ 1 ] + info.width;

							for ( let j = 0; j < info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 8 ) | rawBuffer[ ptr[ 1 ] ++ ];

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

						case 2:

							ptr[ 0 ] = tmpBufferEnd;
							ptr[ 1 ] = ptr[ 0 ] + info.width;
							ptr[ 2 ] = ptr[ 1 ] + info.width;
							tmpBufferEnd = ptr[ 2 ] + info.width;

							for ( let j = 0; j < info.width; ++ j ) {

								const diff = ( rawBuffer[ ptr[ 0 ] ++ ] << 24 ) | ( rawBuffer[ ptr[ 1 ] ++ ] << 16 ) | ( rawBuffer[ ptr[ 2 ] ++ ] << 8 );

								pixel += diff;

								tmpBuffer[ writePtr ] = pixel;
								writePtr ++;

							}

							break;

					}

				}

			}

			return new DataView( tmpBuffer.buffer );

		}

		function uncompressDWA( info ) {

			const inDataView = info.viewer;
			const inOffset = { value: info.offset.value };
			const outBuffer = new Uint8Array( info.width * info.lines * ( info.channels * info.type * INT16_SIZE ) );

			// Read compression header information
			const dwaHeader = {

				version: parseInt64( inDataView, inOffset ),
				unknownUncompressedSize: parseInt64( inDataView, inOffset ),
				unknownCompressedSize: parseInt64( inDataView, inOffset ),
				acCompressedSize: parseInt64( inDataView, inOffset ),
				dcCompressedSize: parseInt64( inDataView, inOffset ),
				rleCompressedSize: parseInt64( inDataView, inOffset ),
				rleUncompressedSize: parseInt64( inDataView, inOffset ),
				rleRawSize: parseInt64( inDataView, inOffset ),
				totalAcUncompressedCount: parseInt64( inDataView, inOffset ),
				totalDcUncompressedCount: parseInt64( inDataView, inOffset ),
				acCompression: parseInt64( inDataView, inOffset )

			};

			if ( dwaHeader.version < 2 )
				throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported' );

			// Read channel ruleset information
			const channelRules = new Array();
			let ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;

			while ( ruleSize > 0 ) {

				const name = parseNullTerminatedString( inDataView.buffer, inOffset );
				const value = parseUint8( inDataView, inOffset );
				const compression = ( value >> 2 ) & 3;
				const csc = ( value >> 4 ) - 1;
				const index = new Int8Array( [ csc ] )[ 0 ];
				const type = parseUint8( inDataView, inOffset );

				channelRules.push( {
					name: name,
					index: index,
					type: type,
					compression: compression,
				} );

				ruleSize -= name.length + 3;

			}

			// Classify channels
			const channels = EXRHeader.channels;
			const channelData = new Array( info.channels );

			for ( let i = 0; i < info.channels; ++ i ) {

				const cd = channelData[ i ] = {};
				const channel = channels[ i ];

				cd.name = channel.name;
				cd.compression = UNKNOWN;
				cd.decoded = false;
				cd.type = channel.pixelType;
				cd.pLinear = channel.pLinear;
				cd.width = info.width;
				cd.height = info.lines;

			}

			const cscSet = {
				idx: new Array( 3 )
			};

			for ( let offset = 0; offset < info.channels; ++ offset ) {

				const cd = channelData[ offset ];

				for ( let i = 0; i < channelRules.length; ++ i ) {

					const rule = channelRules[ i ];

					if ( cd.name == rule.name ) {

						cd.compression = rule.compression;

						if ( rule.index >= 0 ) {

							cscSet.idx[ rule.index ] = offset;

						}

						cd.offset = offset;

					}

				}

			}

			let acBuffer, dcBuffer, rleBuffer;

			// Read DCT - AC component data
			if ( dwaHeader.acCompressedSize > 0 ) {

				switch ( dwaHeader.acCompression ) {

					case STATIC_HUFFMAN:

						acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );
						hufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );
						break;

					case DEFLATE:

						const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );
						const data = unzlibSync( compressed );
						acBuffer = new Uint16Array( data.buffer );
						inOffset.value += dwaHeader.totalAcUncompressedCount;
						break;

				}


			}

			// Read DCT - DC component data
			if ( dwaHeader.dcCompressedSize > 0 ) {

				const zlibInfo = {
					array: info.array,
					offset: inOffset,
					size: dwaHeader.dcCompressedSize
				};
				dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );
				inOffset.value += dwaHeader.dcCompressedSize;

			}

			// Read RLE compressed data
			if ( dwaHeader.rleRawSize > 0 ) {

				const compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );
				const data = unzlibSync( compressed );
				rleBuffer = decodeRunLength( data.buffer );

				inOffset.value += dwaHeader.rleCompressedSize;

			}

			// Prepare outbuffer data offset
			let outBufferEnd = 0;
			const rowOffsets = new Array( channelData.length );
			for ( let i = 0; i < rowOffsets.length; ++ i ) {

				rowOffsets[ i ] = new Array();

			}

			for ( let y = 0; y < info.lines; ++ y ) {

				for ( let chan = 0; chan < channelData.length; ++ chan ) {

					rowOffsets[ chan ].push( outBufferEnd );
					outBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;

				}

			}

			// Lossy DCT decode RGB channels
			lossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );

			// Decode other channels
			for ( let i = 0; i < channelData.length; ++ i ) {

				const cd = channelData[ i ];

				if ( cd.decoded ) continue;

				switch ( cd.compression ) {

					case RLE:

						let row = 0;
						let rleOffset = 0;

						for ( let y = 0; y < info.lines; ++ y ) {

							let rowOffsetBytes = rowOffsets[ i ][ row ];

							for ( let x = 0; x < cd.width; ++ x ) {

								for ( let byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {

									outBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];

								}

								rleOffset ++;

							}

							row ++;

						}

						break;

					case LOSSY_DCT: // skip

					default:
						throw new Error( 'EXRLoader.parse: unsupported channel compression' );

				}

			}

			return new DataView( outBuffer.buffer );

		}

		function parseNullTerminatedString( buffer, offset ) {

			const uintBuffer = new Uint8Array( buffer );
			let endOffset = 0;

			while ( uintBuffer[ offset.value + endOffset ] != 0 ) {

				endOffset += 1;

			}

			const stringValue = new TextDecoder().decode(
				uintBuffer.slice( offset.value, offset.value + endOffset )
			);

			offset.value = offset.value + endOffset + 1;

			return stringValue;

		}

		function parseFixedLengthString( buffer, offset, size ) {

			const stringValue = new TextDecoder().decode(
				new Uint8Array( buffer ).slice( offset.value, offset.value + size )
			);

			offset.value = offset.value + size;

			return stringValue;

		}

		function parseRational( dataView, offset ) {

			const x = parseInt32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseTimecode( dataView, offset ) {

			const x = parseUint32( dataView, offset );
			const y = parseUint32( dataView, offset );

			return [ x, y ];

		}

		function parseInt32( dataView, offset ) {

			const Int32 = dataView.getInt32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Int32;

		}

		function parseUint32( dataView, offset ) {

			const Uint32 = dataView.getUint32( offset.value, true );

			offset.value = offset.value + INT32_SIZE;

			return Uint32;

		}

		function parseUint8Array( uInt8Array, offset ) {

			const Uint8 = uInt8Array[ offset.value ];

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		function parseUint8( dataView, offset ) {

			const Uint8 = dataView.getUint8( offset.value );

			offset.value = offset.value + INT8_SIZE;

			return Uint8;

		}

		const parseInt64 = function ( dataView, offset ) {

			let int;

			if ( 'getBigInt64' in DataView.prototype ) {

				int = Number( dataView.getBigInt64( offset.value, true ) );

			} else {

				int = dataView.getUint32( offset.value + 4, true ) + Number( dataView.getUint32( offset.value, true ) << 32 );

			}

			offset.value += ULONG_SIZE;

			return int;

		};

		function parseFloat32( dataView, offset ) {

			const float = dataView.getFloat32( offset.value, true );

			offset.value += FLOAT32_SIZE;

			return float;

		}

		function decodeFloat32( dataView, offset ) {

			return DataUtils.toHalfFloat( parseFloat32( dataView, offset ) );

		}

		// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript
		function decodeFloat16( binary ) {

			const exponent = ( binary & 0x7C00 ) >> 10,
				fraction = binary & 0x03FF;

			return ( binary >> 15 ? - 1 : 1 ) * (
				exponent ?
					(
						exponent === 0x1F ?
							fraction ? NaN : Infinity :
							Math.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )
					) :
					6.103515625e-5 * ( fraction / 0x400 )
			);

		}

		function parseUint16( dataView, offset ) {

			const Uint16 = dataView.getUint16( offset.value, true );

			offset.value += INT16_SIZE;

			return Uint16;

		}

		function parseFloat16( buffer, offset ) {

			return decodeFloat16( parseUint16( buffer, offset ) );

		}

		function parseChlist( dataView, buffer, offset, size ) {

			const startOffset = offset.value;
			const channels = [];

			while ( offset.value < ( startOffset + size - 1 ) ) {

				const name = parseNullTerminatedString( buffer, offset );
				const pixelType = parseInt32( dataView, offset );
				const pLinear = parseUint8( dataView, offset );
				offset.value += 3; // reserved, three chars
				const xSampling = parseInt32( dataView, offset );
				const ySampling = parseInt32( dataView, offset );

				channels.push( {
					name: name,
					pixelType: pixelType,
					pLinear: pLinear,
					xSampling: xSampling,
					ySampling: ySampling
				} );

			}

			offset.value += 1;

			return channels;

		}

		function parseChromaticities( dataView, offset ) {

			const redX = parseFloat32( dataView, offset );
			const redY = parseFloat32( dataView, offset );
			const greenX = parseFloat32( dataView, offset );
			const greenY = parseFloat32( dataView, offset );
			const blueX = parseFloat32( dataView, offset );
			const blueY = parseFloat32( dataView, offset );
			const whiteX = parseFloat32( dataView, offset );
			const whiteY = parseFloat32( dataView, offset );

			return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };

		}

		function parseCompression( dataView, offset ) {

			const compressionCodes = [
				'NO_COMPRESSION',
				'RLE_COMPRESSION',
				'ZIPS_COMPRESSION',
				'ZIP_COMPRESSION',
				'PIZ_COMPRESSION',
				'PXR24_COMPRESSION',
				'B44_COMPRESSION',
				'B44A_COMPRESSION',
				'DWAA_COMPRESSION',
				'DWAB_COMPRESSION'
			];

			const compression = parseUint8( dataView, offset );

			return compressionCodes[ compression ];

		}

		function parseBox2i( dataView, offset ) {

			const xMin = parseUint32( dataView, offset );
			const yMin = parseUint32( dataView, offset );
			const xMax = parseUint32( dataView, offset );
			const yMax = parseUint32( dataView, offset );

			return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };

		}

		function parseLineOrder( dataView, offset ) {

			const lineOrders = [
				'INCREASING_Y'
			];

			const lineOrder = parseUint8( dataView, offset );

			return lineOrders[ lineOrder ];

		}

		function parseV2f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );

			return [ x, y ];

		}

		function parseV3f( dataView, offset ) {

			const x = parseFloat32( dataView, offset );
			const y = parseFloat32( dataView, offset );
			const z = parseFloat32( dataView, offset );

			return [ x, y, z ];

		}

		function parseValue( dataView, buffer, offset, type, size ) {

			if ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {

				return parseFixedLengthString( buffer, offset, size );

			} else if ( type === 'chlist' ) {

				return parseChlist( dataView, buffer, offset, size );

			} else if ( type === 'chromaticities' ) {

				return parseChromaticities( dataView, offset );

			} else if ( type === 'compression' ) {

				return parseCompression( dataView, offset );

			} else if ( type === 'box2i' ) {

				return parseBox2i( dataView, offset );

			} else if ( type === 'lineOrder' ) {

				return parseLineOrder( dataView, offset );

			} else if ( type === 'float' ) {

				return parseFloat32( dataView, offset );

			} else if ( type === 'v2f' ) {

				return parseV2f( dataView, offset );

			} else if ( type === 'v3f' ) {

				return parseV3f( dataView, offset );

			} else if ( type === 'int' ) {

				return parseInt32( dataView, offset );

			} else if ( type === 'rational' ) {

				return parseRational( dataView, offset );

			} else if ( type === 'timecode' ) {

				return parseTimecode( dataView, offset );

			} else if ( type === 'preview' ) {

				offset.value += size;
				return 'skipped';

			} else {

				offset.value += size;
				return undefined;

			}

		}

		function parseHeader( dataView, buffer, offset ) {

			const EXRHeader = {};

			if ( dataView.getUint32( 0, true ) != 20000630 ) { // magic

				throw new Error( 'THREE.EXRLoader: Provided file doesn\'t appear to be in OpenEXR format.' );

			}

			EXRHeader.version = dataView.getUint8( 4 );

			const spec = dataView.getUint8( 5 ); // fullMask

			EXRHeader.spec = {
				singleTile: !! ( spec & 2 ),
				longName: !! ( spec & 4 ),
				deepFormat: !! ( spec & 8 ),
				multiPart: !! ( spec & 16 ),
			};

			// start of header

			offset.value = 8; // start at 8 - after pre-amble

			let keepReading = true;

			while ( keepReading ) {

				const attributeName = parseNullTerminatedString( buffer, offset );

				if ( attributeName == 0 ) {

					keepReading = false;

				} else {

					const attributeType = parseNullTerminatedString( buffer, offset );
					const attributeSize = parseUint32( dataView, offset );
					const attributeValue = parseValue( dataView, buffer, offset, attributeType, attributeSize );

					if ( attributeValue === undefined ) {

						console.warn( `THREE.EXRLoader: Skipped unknown header attribute type \'${attributeType}\'.` );

					} else {

						EXRHeader[ attributeName ] = attributeValue;

					}

				}

			}

			if ( ( spec & ~ 0x04 ) != 0 ) { // unsupported tiled, deep-image, multi-part

				console.error( 'THREE.EXRHeader:', EXRHeader );
				throw new Error( 'THREE.EXRLoader: Provided file is currently unsupported.' );

			}

			return EXRHeader;

		}

		function setupDecoder( EXRHeader, dataView, uInt8Array, offset, outputType ) {

			const EXRDecoder = {
				size: 0,
				viewer: dataView,
				array: uInt8Array,
				offset: offset,
				width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,
				height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,
				channels: EXRHeader.channels.length,
				bytesPerLine: null,
				lines: null,
				inputSize: null,
				type: EXRHeader.channels[ 0 ].pixelType,
				uncompress: null,
				getter: null,
				format: null,
				colorSpace: LinearSRGBColorSpace,
			};

			switch ( EXRHeader.compression ) {

				case 'NO_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRAW;
					break;

				case 'RLE_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressRLE;
					break;

				case 'ZIPS_COMPRESSION':
					EXRDecoder.lines = 1;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'ZIP_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressZIP;
					break;

				case 'PIZ_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressPIZ;
					break;

				case 'PXR24_COMPRESSION':
					EXRDecoder.lines = 16;
					EXRDecoder.uncompress = uncompressPXR;
					break;

				case 'DWAA_COMPRESSION':
					EXRDecoder.lines = 32;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				case 'DWAB_COMPRESSION':
					EXRDecoder.lines = 256;
					EXRDecoder.uncompress = uncompressDWA;
					break;

				default:
					throw new Error( 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported' );

			}

			EXRDecoder.scanlineBlockSize = EXRDecoder.lines;

			if ( EXRDecoder.type == 1 ) {

				// half
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = parseUint16;
						EXRDecoder.inputSize = INT16_SIZE;
						break;

				}

			} else if ( EXRDecoder.type == 2 ) {

				// float
				switch ( outputType ) {

					case FloatType:
						EXRDecoder.getter = parseFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;
						break;

					case HalfFloatType:
						EXRDecoder.getter = decodeFloat32;
						EXRDecoder.inputSize = FLOAT32_SIZE;

				}

			} else {

				throw new Error( 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.' );

			}

			EXRDecoder.blockCount = ( EXRHeader.dataWindow.yMax + 1 ) / EXRDecoder.scanlineBlockSize;

			for ( let i = 0; i < EXRDecoder.blockCount; i ++ )
				parseInt64( dataView, offset ); // scanlineOffset

			// we should be passed the scanline offset table, ready to start reading pixel data.

			// RGB images will be converted to RGBA format, preventing software emulation in select devices.
			EXRDecoder.outputChannels = ( ( EXRDecoder.channels == 3 ) ? 4 : EXRDecoder.channels );
			const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels;

			switch ( outputType ) {

				case FloatType:
					EXRDecoder.byteArray = new Float32Array( size );

					// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten
					if ( EXRDecoder.channels < EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 1, 0, size );

					break;

				case HalfFloatType:
					EXRDecoder.byteArray = new Uint16Array( size );

					if ( EXRDecoder.channels < EXRDecoder.outputChannels )
						EXRDecoder.byteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1

					break;

				default:
					console.error( 'THREE.EXRLoader: unsupported type: ', outputType );
					break;

			}

			EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels;

			if ( EXRDecoder.outputChannels == 4 ) {

				EXRDecoder.format = RGBAFormat$1;
				EXRDecoder.colorSpace = LinearSRGBColorSpace;

			} else {

				EXRDecoder.format = RedFormat;
				EXRDecoder.colorSpace = NoColorSpace;

			}

			return EXRDecoder;

		}

		// start parsing file [START]

		const bufferDataView = new DataView( buffer );
		const uInt8Array = new Uint8Array( buffer );
		const offset = { value: 0 };

		// get header information and validate format.
		const EXRHeader = parseHeader( bufferDataView, buffer, offset );

		// get input compression information and prepare decoding.
		const EXRDecoder = setupDecoder( EXRHeader, bufferDataView, uInt8Array, offset, this.type );

		const tmpOffset = { value: 0 };
		const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };

		for ( let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx ++ ) {

			const line = parseUint32( bufferDataView, offset ); // line_no
			EXRDecoder.size = parseUint32( bufferDataView, offset ); // data_len
			EXRDecoder.lines = ( ( line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ) ? ( EXRDecoder.height - line ) : EXRDecoder.scanlineBlockSize );

			const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
			const viewer = isCompressed ? EXRDecoder.uncompress( EXRDecoder ) : uncompressRAW( EXRDecoder );

			offset.value += EXRDecoder.size;

			for ( let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y ++ ) {

				const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
				if ( true_y >= EXRDecoder.height ) break;

				for ( let channelID = 0; channelID < EXRDecoder.channels; channelID ++ ) {

					const cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];

					for ( let x = 0; x < EXRDecoder.width; x ++ ) {

						tmpOffset.value = ( line_y * ( EXRDecoder.channels * EXRDecoder.width ) + channelID * EXRDecoder.width + x ) * EXRDecoder.inputSize;
						const outIndex = ( EXRDecoder.height - 1 - true_y ) * ( EXRDecoder.width * EXRDecoder.outputChannels ) + x * EXRDecoder.outputChannels + cOff;
						EXRDecoder.byteArray[ outIndex ] = EXRDecoder.getter( viewer, tmpOffset );

					}

				}

			}

		}

		return {
			header: EXRHeader,
			width: EXRDecoder.width,
			height: EXRDecoder.height,
			data: EXRDecoder.byteArray,
			format: EXRDecoder.format,
			colorSpace: EXRDecoder.colorSpace,
			type: this.type,
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			texture.colorSpace = texData.colorSpace;
			texture.minFilter = LinearFilter;
			texture.magFilter = LinearFilter;
			texture.generateMipmaps = false;
			texture.flipY = false;

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: throw new Error( 'THREE.RGBELoader: Read Error: ' + ( msg || '' ) );
					case rgbe_write_error: throw new Error( 'THREE.RGBELoader: Write Error: ' + ( msg || '' ) );
					case rgbe_format_error: throw new Error( 'THREE.RGBELoader: Bad File Format: ' + ( msg || '' ) );
					default:
					case rgbe_memory_error: throw new Error( 'THREE.RGBELoader: Memory Error: ' + ( msg || '' ) );

				}

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		const w = rgbe_header_info.width,
			h = rgbe_header_info.height,
			image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );


		let data, type;
		let numElements;

		switch ( this.type ) {

			case FloatType:

				numElements = image_rgba_data.length / 4;
				const floatArray = new Float32Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

				}

				data = floatArray;
				type = FloatType;
				break;

			case HalfFloatType:

				numElements = image_rgba_data.length / 4;
				const halfArray = new Uint16Array( numElements * 4 );

				for ( let j = 0; j < numElements; j ++ ) {

					RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

				}

				data = halfArray;
				type = HalfFloatType;
				break;

			default:

				throw new Error( 'THREE.RGBELoader: Unsupported type: ' + this.type );

		}

		return {
			width: w, height: h,
			data: data,
			header: rgbe_header_info.string,
			gamma: rgbe_header_info.gamma,
			exposure: rgbe_header_info.exposure,
			type: type
		};

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case FloatType:
				case HalfFloatType:

					texture.colorSpace = LinearSRGBColorSpace;
					texture.minFilter = LinearFilter;
					texture.magFilter = LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;

					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}

class HdrEnvironmentLoader {
    constructor(creator) {
        this._creator_ = creator;
        const initialColor = new Color$1(PREVIEW_MATERIAL_COLOR);
        this._environmentMap = createColorCubeTexture(initialColor.r, initialColor.g, initialColor.b, PREVIEW_MATERIAL_OPACITY);
    }
    async loadUrl(renderer, url) {
        const lowerName = url.toLowerCase();
        this._environmentMap = lowerName.endsWith('.exr')
            ? await this._loadExr(url)
            : await this._loadRgbe(url);
        this._environmentMap.mapping = EquirectangularReflectionMapping;
        const maps = {
            url,
            environmentMap: this._environmentMap,
        };
        this._envChangedCallback(maps);
        return maps;
    }
    _loadExr(url) {
        var _a;
        this._exrLoader = (_a = this._exrLoader) !== null && _a !== void 0 ? _a : new EXRLoader();
        this._exrLoader.setPath(url.startsWith('http') ? '' : getAssetPath());
        return this._exrLoader.loadAsync(url);
    }
    _loadRgbe(url) {
        var _a;
        this._rgbeLoader = (_a = this._rgbeLoader) !== null && _a !== void 0 ? _a : new RGBELoader();
        this._rgbeLoader.setPath(url.startsWith('http') ? '' : getAssetPath());
        return this._rgbeLoader.loadAsync(url);
    }
    registerEnvironmentChangedCallback(callBack) {
        this._envChangedCallback = callBack;
    }
}

class ShadowGroundPlane extends Mesh {
    constructor(shadowMap, parameters) {
        const planeMaterial = new MeshBasicMaterial({
            transparent: true,
            depthWrite: false,
            //side: DoubleSide
        });
        if (ShadowGroundPlane.alphaMap) {
            planeMaterial.color.set(0x000000);
        }
        planeMaterial.polygonOffset = true;
        super(new PlaneGeometry(1, 1, 10, 10), planeMaterial);
        this.name = 'ShadowGroundPlane';
        this.userData.isFloor = true;
        this.renderOrder = 1;
        this.receiveShadow = false;
        this.layers.disableAll();
        if (parameters) {
            this.updateMaterial(parameters);
        }
        this.setShadowMap(shadowMap);
    }
    setVisibility(visible) {
        this.visible = visible;
        this.setVisibilityLayers(visible);
    }
    setVisibilityLayers(visible) {
        if (visible) {
            this.layers.enableAll();
        }
        else {
            this.layers.disableAll();
        }
    }
    setDepthWrite(write) {
        const shadowGroundMaterial = this.material;
        shadowGroundMaterial.depthWrite = write;
        shadowGroundMaterial.transparent = !write;
        shadowGroundMaterial.needsUpdate = true;
        this.setVisibility(write);
    }
    setReceiveShadow(receive) {
        this.receiveShadow = receive;
        this.setVisibility(receive);
    }
    setShadowMap(shadowMap) {
        const shadowGroundMaterial = this.material;
        shadowGroundMaterial.map = shadowMap;
        if (ShadowGroundPlane.alphaMap) {
            shadowGroundMaterial.alphaMap = shadowMap;
        }
        shadowGroundMaterial.needsUpdate = true;
    }
    updateMaterial(parameters) {
        const shadowGroundMaterial = this.material;
        if (parameters.opacity &&
            shadowGroundMaterial.opacity !== parameters.opacity) {
            shadowGroundMaterial.opacity = parameters.opacity;
        }
        if (parameters.polygonOffset &&
            shadowGroundMaterial.polygonOffsetFactor !== parameters.polygonOffset) {
            shadowGroundMaterial.polygonOffset = true;
            shadowGroundMaterial.polygonOffsetFactor = parameters.polygonOffset;
            shadowGroundMaterial.polygonOffsetUnits = parameters.polygonOffset;
        }
        shadowGroundMaterial.needsUpdate = true;
    }
}
ShadowGroundPlane.alphaMap = false;

class RenderPass extends Pass {
    get renderPassManager() {
        return this._renderPassManager;
    }
    get renderCacheManager() {
        return this._renderPassManager.renderCacheManager;
    }
    get scene() {
        return this._renderPassManager.scene;
    }
    get camera() {
        return this._renderPassManager.camera;
    }
    get gBufferTextures() {
        return this._renderPassManager.gBufferRenderPass;
    }
    get passRenderer() {
        return this._renderPassManager.passRenderer;
    }
    constructor(renderPassManager) {
        super();
        this._renderPassManager = renderPassManager;
    }
    render(renderer, _writeBuffer, _readBuffer, _deltaTime, _maskActive) {
        this.renderPass(renderer);
    }
}

const generatePdSamplePointInitializer = (samples, rings, radiusExponent) => {
    const poissonDisk = generateDenoiseSamples(samples, rings, radiusExponent);
    let glslCode = 'vec3[SAMPLES](';
    for (let i = 0; i < samples; i++) {
        const sample = poissonDisk[i];
        glslCode += `vec3(${sample.x}, ${sample.y}, ${sample.z})${i < samples - 1 ? ',' : ')'}`;
    }
    return glslCode;
};
const generateDenoiseSamples = (numSamples, numRings, radiusExponent) => {
    const samples = [];
    for (let i = 0; i < numSamples; i++) {
        const angle = (2 * Math.PI * numRings * i) / numSamples;
        const radius = Math.pow(i / (numSamples - 1), radiusExponent);
        samples.push(new Vector3(Math.cos(angle), Math.sin(angle), radius));
    }
    return samples;
};
const poissonDenoiseVertexShader = /* glsl */ `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
const poissonDenoiseFragmentShader = /* glsl */ `
varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tNormal;
uniform sampler2D tDepth;
uniform sampler2D tNoise;
uniform vec2 resolution;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraProjectionMatrixInverse;
uniform mat4 cameraWorldMatrix;
uniform float lumaPhi;
uniform float depthPhi;
uniform float normalPhi;
uniform float radius;
uniform float radiusExponent;
uniform int index;
#if SCENE_CLIP_BOX == 1
    uniform vec3 sceneBoxMin;
    uniform vec3 sceneBoxMax;
#endif

#include <common>
#include <packing>

#ifndef LUMINANCE_TYPE
#define LUMINANCE_TYPE float
#endif

#ifndef SAMPLE_LUMINANCE
#define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)
#endif

#ifndef FRAGMENT_OUTPUT
#define FRAGMENT_OUTPUT vec4(vec3(denoised), 1.)
#endif

LUMINANCE_TYPE getLuminance(const in vec3 a) {
    return SAMPLE_LUMINANCE;
}

const vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;

vec3 getViewPosition(const in vec2 screenPosition, const in float depth) {
    vec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);
    vec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;
    return viewSpacePosition.xyz / viewSpacePosition.w;
}

float getDepth(const vec2 uv) {
#if DEPTH_VALUE_SOURCE == 1    
    return textureLod(tDepth, uv.xy, 0.0).a;
#else
    return textureLod(tDepth, uv.xy, 0.0).r;
#endif
}

float fetchDepth(const ivec2 uv) {
#if DEPTH_VALUE_SOURCE == 1    
    return texelFetch(tDepth, uv.xy, 0).a;
#else
    return texelFetch(tDepth, uv.xy, 0).r;
#endif
}

vec3 computeNormalFromDepth(const vec2 uv) {
    vec2 size = vec2(textureSize(tDepth, 0));
    ivec2 p = ivec2(uv * size);
    float c0 = fetchDepth(p);
    float l2 = fetchDepth(p - ivec2(2, 0));
    float l1 = fetchDepth(p - ivec2(1, 0));
    float r1 = fetchDepth(p + ivec2(1, 0));
    float r2 = fetchDepth(p + ivec2(2, 0));
    float b2 = fetchDepth(p - ivec2(0, 2));
    float b1 = fetchDepth(p - ivec2(0, 1));
    float t1 = fetchDepth(p + ivec2(0, 1));
    float t2 = fetchDepth(p + ivec2(0, 2));
    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);
    vec3 ce = getViewPosition(uv, c0).xyz;
    vec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz
                : -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;
    vec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz
                : -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;
    return normalize(cross(dpdx, dpdy));
}

vec3 getViewNormal(const vec2 uv) {
#if NORMAL_VECTOR_TYPE == 2
    return normalize(textureLod(tNormal, uv, 0.).rgb);
#elif NORMAL_VECTOR_TYPE == 1
    return unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);
#else
    return computeNormalFromDepth(uv);
#endif
}

void denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout LUMINANCE_TYPE totalWeight) {
    vec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);
    float sampleDepth = getDepth(sampleUv);
    vec3 sampleNormal = getViewNormal(sampleUv);
    vec3 neighborColor = sampleTexel.rgb;
    vec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);
    
    float normalDiff = dot(viewNormal, sampleNormal);
    float normalSimilarity = pow(max(normalDiff, 0.), normalPhi);
    LUMINANCE_TYPE lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));
    LUMINANCE_TYPE lumaSimilarity = max(1. - lumaDiff / lumaPhi, 0.);
    float depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));
    float depthSimilarity = max(1. - depthDiff / depthPhi, 0.);
    LUMINANCE_TYPE w = lumaSimilarity * depthSimilarity * normalSimilarity;

    denoised += w * neighborColor;
    totalWeight += w;
}

void main() {
    float depth = getDepth(vUv.xy);	
    vec3 viewNormal = getViewNormal(vUv);	
    if (depth == 1. || dot(viewNormal, viewNormal) == 0.) {
        discard;
        return;
    }
    vec4 texel = textureLod(tDiffuse, vUv, 0.0);
    vec3 center = texel.rgb;
    vec3 viewPos = getViewPosition(vUv, depth);

    #if SCENE_CLIP_BOX == 1
      vec3 worldPos = (cameraWorldMatrix * vec4(viewPos, 1.0)).xyz;
          float boxDistance = length(max(vec3(0.0), max(sceneBoxMin - worldPos, worldPos - sceneBoxMax)));
      if (boxDistance > radius * 2.) {
        discard;
        return;
      }
		#endif

    vec2 noiseResolution = vec2(textureSize(tNoise, 0));
    vec2 noiseUv = vUv * resolution / noiseResolution;
    vec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);
    vec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));
    #if SAMPLE_DISTRIBUTION == 1
      vec3 randomVec = normalize(vec3(noiseVec.xy, 0.));
      vec3 tangent = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
      vec3 bitangent = cross(viewNormal, tangent);
      mat3 kernelMatrix = mat3(tangent, bitangent, viewNormal);
    #else
      mat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);
    #endif

    LUMINANCE_TYPE totalWeight = LUMINANCE_TYPE(1.);
    vec3 denoised = texel.rgb;
    for (int i = 0; i < SAMPLES; i++) {
        vec3 sampleDir = poissonDisk[i];
    #if SAMPLE_DISTRIBUTION == 1
        vec3 offsetViewPos = viewPos + normalize(kernelMatrix * vec3(sampleDir.xy, 0.)) * sampleDir.z * radius;
        vec4 samplePointNDC = cameraProjectionMatrix * vec4(offsetViewPos, 1.0); 
        vec2 sampleUv = (samplePointNDC.xy / samplePointNDC.w * 0.5 + 0.5);
    #else
        vec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);
        vec2 sampleUv = vUv + offset;
    #endif
        denoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);
    }

    denoised /= totalWeight + 1.0 - step(0.0, totalWeight);
    gl_FragColor = FRAGMENT_OUTPUT;
}`;
const poissonDenoiseShader = {
    name: 'PoissonDenoiseShader',
    defines: {
        SAMPLES: 16,
        SAMPLE_VECTORS: generatePdSamplePointInitializer(16, 2, 1),
        NV_ALIGNED_SAMPLES: 0,
        SAMPLE_DISTRIBUTION: 0,
        DEPTH_VALUE_SOURCE: 0,
        LUMINANCE_TYPE: 'float',
        SAMPLE_LUMINANCE: 'dot(vec3(0.2125, 0.7154, 0.0721), a)',
        SCENE_CLIP_BOX: 0,
        FRAGMENT_OUTPUT: 'vec4(vec3(denoised), 1.)',
    },
    uniforms: {
        tDiffuse: { value: null },
        tNormal: { value: null },
        tDepth: { value: null },
        tNoise: { value: null },
        resolution: { value: new Vector2() },
        cameraProjectionMatrix: { value: new Matrix4() },
        cameraProjectionMatrixInverse: { value: new Matrix4() },
        cameraWorldMatrix: { value: new Matrix4() },
        lumaPhi: { value: 5 },
        depthPhi: { value: 5 },
        normalPhi: { value: 5 },
        radius: { value: 10 },
        radiusExponent: { value: 1 },
        index: { value: 0 },
        sceneBoxMin: { value: new Vector3(-1, -1, -1) },
        sceneBoxMax: { value: new Vector3(1, 1, 1) },
    },
    vertexShader: poissonDenoiseVertexShader,
    fragmentShader: poissonDenoiseFragmentShader,
};

const defaultPoissonDenoisePassParameters = {
    iterations: 2,
    samples: 16,
    rings: 2,
    radiusExponent: 1,
    radius: 5,
    lumaPhi: 10,
    depthPhi: 0.5,
    normalPhi: 1,
    nvOrientatedSamples: false,
};
class PoissonDenoiseRenderPass {
    get texture() {
        return this.parameters.iterations > 0 && this._renderTargets.length > 0
            ? this._renderTargets[this._outputRenderTargetIndex].texture
            : this._inputTexture;
    }
    set inputTexture(texture) {
        this._inputTexture = texture;
    }
    constructor(width, height, parameters) {
        this.needsUpdate = true;
        this.parameters = {
            ...defaultPoissonDenoisePassParameters,
        };
        this._width = 0;
        this._height = 0;
        this._normalVectorSourceType = NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL;
        this._depthValueSourceType = DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA;
        this._inputTexture = null;
        this.depthTexture = null;
        this.normalTexture = null;
        this._noiseTexture = null;
        this._renderTargets = [];
        this._outputRenderTargetIndex = 0;
        this._passRenderer = new PassRenderer();
        this._rgInputTexture = false;
        this._width = width;
        this._height = height;
        this._normalVectorSourceType =
            (parameters === null || parameters === void 0 ? void 0 : parameters.normalVectorSourceType) ||
                NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL;
        this._depthValueSourceType =
            (parameters === null || parameters === void 0 ? void 0 : parameters.depthValueSourceType) ||
                DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA;
        this._inputTexture = (parameters === null || parameters === void 0 ? void 0 : parameters.inputTexture) || null;
        this.depthTexture = (parameters === null || parameters === void 0 ? void 0 : parameters.depthTexture) || null;
        this.normalTexture = (parameters === null || parameters === void 0 ? void 0 : parameters.normalTexture) || null;
        this._rgInputTexture = (parameters === null || parameters === void 0 ? void 0 : parameters.rgInputTexture) || false;
        this._luminanceType = (parameters === null || parameters === void 0 ? void 0 : parameters.luminanceType) || 'vec3';
        this._sampleLuminance = (parameters === null || parameters === void 0 ? void 0 : parameters.sampleLuminance) || 'a';
        this._fragmentOutput =
            (parameters === null || parameters === void 0 ? void 0 : parameters.fragmentOutput) || 'vec4(denoised.xyz, 1.)';
        if (parameters === null || parameters === void 0 ? void 0 : parameters.poissonDenoisePassParameters) {
            this.parameters =
                parameters.poissonDenoisePassParameters;
        }
        if (parameters) {
            this.updateTextures(parameters);
        }
    }
    _getNoiseTexture(size = 64) {
        if (!this._noiseTexture) {
            const simplex = new SimplexNoise();
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const x = i;
                    const y = j;
                    data[(i * size + j) * 4] = (simplex.noise(x, y) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 1] =
                        (simplex.noise(x + size, y) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 2] =
                        (simplex.noise(x, y + size) + 1.0) * 127.5;
                    data[(i * size + j) * 4 + 3] =
                        (simplex.noise(x + size, y + size) + 1.0) * 127.5;
                }
            }
            this._noiseTexture = new DataTexture(data, size, size, RGBAFormat$1, UnsignedByteType);
            this._noiseTexture.wrapS = RepeatWrapping;
            this._noiseTexture.wrapT = RepeatWrapping;
            this._noiseTexture.needsUpdate = true;
        }
        return this._noiseTexture;
    }
    _getMaterial(camera, needsUpdate) {
        let updateShader = needsUpdate;
        if (!this._pdMaterial) {
            this._pdMaterial = new ShaderMaterial({
                defines: Object.assign({}, poissonDenoiseShader.defines),
                uniforms: UniformsUtils.clone(poissonDenoiseShader.uniforms),
                vertexShader: poissonDenoiseShader.vertexShader,
                fragmentShader: poissonDenoiseShader.fragmentShader,
                depthTest: false,
                depthWrite: false,
            });
            this._pdMaterial.uniforms.tNoise.value = this._getNoiseTexture();
            updateShader = true;
        }
        if (updateShader) {
            this._updateShader(this._pdMaterial);
        }
        this._updateUniforms(this._pdMaterial, camera, updateShader);
        return this._pdMaterial;
    }
    _updateShader(pdMaterial) {
        pdMaterial.defines.SAMPLES = this.parameters.samples;
        pdMaterial.defines.SAMPLE_VECTORS = generatePdSamplePointInitializer(this.parameters.samples, this.parameters.rings, this.parameters.radiusExponent);
        pdMaterial.defines.SAMPLE_DISTRIBUTION = this.parameters.nvOrientatedSamples
            ? 1
            : 0;
        pdMaterial.defines.NORMAL_VECTOR_TYPE =
            this._normalVectorSourceType ===
                NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL
                ? 2
                : 1;
        pdMaterial.defines.DEPTH_VALUE_SOURCE =
            this._depthValueSourceType ===
                DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
                ? 1
                : 0;
        pdMaterial.needsUpdate = true;
        pdMaterial.defines.LUMINANCE_TYPE = this._luminanceType;
        pdMaterial.defines.SAMPLE_LUMINANCE = this._sampleLuminance;
        pdMaterial.defines.FRAGMENT_OUTPUT = this._fragmentOutput;
        pdMaterial.defines.SCENE_CLIP_BOX = this._sceneClipBox ? 1 : 0;
        pdMaterial.needsUpdate = true;
    }
    _updateUniforms(pdMaterial, camera, updateShader) {
        const depthTexture = this._depthValueSourceType ===
            DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
            ? this.normalTexture
            : this.depthTexture;
        pdMaterial.uniforms.tDiffuse.value = this._inputTexture;
        pdMaterial.uniforms.tNormal.value = this.normalTexture;
        pdMaterial.uniforms.tDepth.value = depthTexture;
        pdMaterial.uniforms.resolution.value.set(this._width, this._height);
        pdMaterial.uniforms.cameraProjectionMatrix.value.copy(camera.projectionMatrix);
        pdMaterial.uniforms.cameraProjectionMatrixInverse.value.copy(camera.projectionMatrixInverse);
        pdMaterial.uniforms.cameraWorldMatrix.value.copy(camera.matrixWorld);
        if (updateShader) {
            pdMaterial.uniforms.lumaPhi.value = this.parameters.lumaPhi;
            pdMaterial.uniforms.depthPhi.value = this.parameters.depthPhi;
            pdMaterial.uniforms.normalPhi.value = this.parameters.normalPhi;
            pdMaterial.uniforms.radius.value = this.parameters.radius;
            pdMaterial.uniforms.radiusExponent.value = this.parameters.radiusExponent;
            if (this._sceneClipBox) {
                pdMaterial.uniforms.sceneBoxMin.value.copy(this._sceneClipBox.min);
                pdMaterial.uniforms.sceneBoxMax.value.copy(this._sceneClipBox.max);
            }
        }
    }
    _getRenderTargets() {
        if (this._renderTargets.length < 2) {
            this._renderTargets = [
                new WebGLRenderTarget(this._width, this._height, {
                    format: this._rgInputTexture ? RGFormat : RGBAFormat$1,
                    magFilter: LinearFilter,
                    minFilter: LinearFilter,
                }),
                new WebGLRenderTarget(this._width, this._height, {
                    format: this._rgInputTexture ? RGFormat : RGBAFormat$1,
                    magFilter: LinearFilter,
                    minFilter: LinearFilter,
                }),
            ];
        }
        return this._renderTargets;
    }
    dispose() {
        var _a, _b;
        (_a = this._noiseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._pdMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
        this._renderTargets.forEach((target) => target.dispose());
    }
    setSize(width, height) {
        this._width = width;
        this._height = height;
        this._renderTargets.forEach((target) => target.setSize(width, height));
        this.needsUpdate = true;
    }
    updateBounds(sceneClipBox) {
        this._sceneClipBox = new Box3().copy(sceneClipBox);
        this.needsUpdate = true;
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
                this.needsUpdate = true;
            }
        }
    }
    updateTextures(parameters) {
        if (parameters.inputTexture) {
            this._inputTexture = parameters.inputTexture;
            this.needsUpdate = true;
        }
        if (parameters.depthTexture) {
            this.depthTexture = parameters.depthTexture;
            this.needsUpdate = true;
        }
        if (parameters.normalTexture) {
            this.normalTexture = parameters.normalTexture;
            this.needsUpdate = true;
        }
    }
    render(renderer, camera) {
        const pdMaterial = this._getMaterial(camera, this.needsUpdate);
        this.needsUpdate = false;
        const renderTargets = this._getRenderTargets();
        for (let i = 0; i < this.parameters.iterations; i++) {
            const inputRenderTarget = renderTargets[(i + 1) % 2];
            this._outputRenderTargetIndex = i % 2;
            const outputRenderTarget = renderTargets[this._outputRenderTargetIndex];
            pdMaterial.uniforms.tDiffuse.value =
                i === 0 ? this._inputTexture : inputRenderTarget.texture;
            pdMaterial.uniforms.index.value = i;
            this._passRenderer.renderScreenSpace(renderer, pdMaterial, outputRenderTarget, 0xffffff, 1.0);
        }
    }
    renderToTarget(renderer, camera, renderTarget) {
        const pdMaterial = this._getMaterial(camera, this.needsUpdate);
        this.needsUpdate = false;
        this._passRenderer.renderScreenSpace(renderer, pdMaterial, renderTarget, 0xffffff, 1.0);
    }
}

const RGBAFormat = 1023;

const SHADOW_BLUR_TYPES = {
    OFF: 'off',
    HARD: 'hard',
    POISSON: 'poisson',
    FULL: 'full',
};
const defaultShadowParameters = {
    shadowRadius: 0.05,
};
const defaultPassParameters = {
    enabled: true,
    aoIntensity: 0.5,
    shadowIntensity: 0.35,
    aoOnGround: true,
    shadowOnGround: false,
    alwaysUpdate: false,
    progressiveDenoiseIterations: 0,
};
class ShadowAndAoPass extends RenderPass {
    get aoAndSoftShadowRenderTarget() {
        var _a;
        this._aoAndSoftShadowRenderTarget =
            (_a = this._aoAndSoftShadowRenderTarget) !== null && _a !== void 0 ? _a : new WebGLRenderTarget(this._width, this._height, {
                samples: 0,
                format: RGFormat,
                magFilter: LinearFilter,
                minFilter: LinearFilter,
            });
        return this._aoAndSoftShadowRenderTarget;
    }
    get aoRenderPass() {
        if (!this._aoPass) {
            this._aoPass = new AORenderPass(this._width, this._height, {
                normalVectorSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL
                    : NORMAL_VECTOR_SOURCE_TYPES.INPUT_RGB_NORMAL,
                depthValueSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
                    : DEPTH_VALUE_SOURCE_TYPES.SEPARATE_BUFFER,
                modulateRedChannel: true,
                aoParameters: this.parameters.ao,
            });
        }
        return this._aoPass;
    }
    get softShadowPass() {
        if (!this._softShadowPass) {
            this._softShadowPass = new PoissonDenoiseRenderPass(this._width, this._height, {
                inputTexture: undefined,
                depthTexture: this.gBufferTextures.depthBufferTexture,
                normalTexture: this.gBufferTextures.gBufferTexture,
                normalVectorSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL
                    : NORMAL_VECTOR_SOURCE_TYPES.INPUT_RGB_NORMAL,
                depthValueSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
                    : DEPTH_VALUE_SOURCE_TYPES.SEPARATE_BUFFER,
                rgInputTexture: true,
                luminanceType: 'float',
                sampleLuminance: 'a.x',
                fragmentOutput: 'vec4(1.0, denoised.x, 0.0, 1.0)',
                poissonDenoisePassParameters: {
                    iterations: 1,
                    samples: 16,
                    rings: 2,
                    radiusExponent: 1,
                    radius: this.parameters.shadow.shadowRadius,
                    lumaPhi: 10,
                    depthPhi: 0.1,
                    normalPhi: 4,
                    nvOrientatedSamples: true,
                },
            });
        }
        else {
            const softShadowPass = this._softShadowPass;
            softShadowPass.depthTexture = this.gBufferTextures.depthBufferTexture;
            softShadowPass.normalTexture = this.gBufferTextures.gBufferTexture;
        }
        return this._softShadowPass;
    }
    get fadeRenderTarget() {
        var _a;
        this._fadeRenderTarget =
            (_a = this._fadeRenderTarget) !== null && _a !== void 0 ? _a : new WebGLRenderTarget(this._width, this._height, {
                format: RGBAFormat,
                magFilter: LinearFilter,
                minFilter: LinearFilter,
            });
        return this._fadeRenderTarget;
    }
    get denoisePass() {
        if (!this._poissonDenoisePass) {
            this._poissonDenoisePass = new PoissonDenoiseRenderPass(this._width, this._height, {
                inputTexture: this.aoAndSoftShadowRenderTarget.texture,
                depthTexture: this.gBufferTextures.depthBufferTexture,
                normalTexture: this.gBufferTextures.gBufferTexture,
                normalVectorSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? NORMAL_VECTOR_SOURCE_TYPES.FLOAT_BUFFER_NORMAL
                    : NORMAL_VECTOR_SOURCE_TYPES.INPUT_RGB_NORMAL,
                depthValueSourceType: this.gBufferTextures
                    .isFloatGBufferWithRgbNormalAlphaDepth
                    ? DEPTH_VALUE_SOURCE_TYPES.NORMAL_VECTOR_ALPHA
                    : DEPTH_VALUE_SOURCE_TYPES.SEPARATE_BUFFER,
                rgInputTexture: true,
                poissonDenoisePassParameters: this.parameters.poissonDenoise,
            });
        }
        else {
            const denoisePass = this._poissonDenoisePass;
            denoisePass.depthTexture = this.gBufferTextures.depthBufferTexture;
            denoisePass.normalTexture = this.gBufferTextures.gBufferTexture;
        }
        return this._poissonDenoisePass;
    }
    get denoiseRenderTargetTexture() {
        return this.denoisePass ? this.denoisePass.texture : null;
    }
    constructor(renderPassManager, width, height, samples, parameters) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(renderPassManager);
        this.needsUpdate = true;
        this.shadowAndAoPassSettings = {
            shadowMapTexture: null,
            shadowBlurType: SHADOW_BLUR_TYPES.FULL,
            shadowFadeInBlurType: SHADOW_BLUR_TYPES.FULL,
            shadowFadeInMix: 0,
            noOStaticFrames: 0,
        };
        this._cameraUpdate = new CameraUpdate();
        this._width = width;
        this._height = height;
        this._samples = samples;
        this.parameters = {
            enabled: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.enabled) !== null && _a !== void 0 ? _a : defaultPassParameters.enabled,
            aoIntensity: (_b = parameters === null || parameters === void 0 ? void 0 : parameters.aoIntensity) !== null && _b !== void 0 ? _b : defaultPassParameters.aoIntensity,
            shadowIntensity: (_c = parameters === null || parameters === void 0 ? void 0 : parameters.shadowIntensity) !== null && _c !== void 0 ? _c : defaultPassParameters.shadowIntensity,
            aoOnGround: (_d = parameters === null || parameters === void 0 ? void 0 : parameters.aoOnGround) !== null && _d !== void 0 ? _d : defaultPassParameters.aoOnGround,
            shadowOnGround: (_e = parameters === null || parameters === void 0 ? void 0 : parameters.shadowOnGround) !== null && _e !== void 0 ? _e : defaultPassParameters.shadowOnGround,
            alwaysUpdate: (_f = parameters === null || parameters === void 0 ? void 0 : parameters.alwaysUpdate) !== null && _f !== void 0 ? _f : defaultPassParameters.alwaysUpdate,
            progressiveDenoiseIterations: (_g = parameters === null || parameters === void 0 ? void 0 : parameters.progressiveDenoiseIterations) !== null && _g !== void 0 ? _g : defaultPassParameters.progressiveDenoiseIterations,
            shadow: {
                ...defaultShadowParameters,
            },
            ao: {
                ...defaultAORenderPassParameters,
            },
            poissonDenoise: {
                ...defaultPoissonDenoisePassParameters,
            },
        };
        this._copyMaterial = new CopyTransformMaterial();
        this._blendMaterial = new CopyTransformMaterial({}, COLOR_COPY_BLEND_MODES.DEFAULT);
    }
    dispose() {
        var _a, _b, _c, _d, _e, _f, _g;
        super.dispose();
        (_a = this._aoAndSoftShadowRenderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._softShadowPass) === null || _b === void 0 ? void 0 : _b.dispose();
        (_c = this._aoPass) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = this._fadeRenderTarget) === null || _d === void 0 ? void 0 : _d.dispose();
        (_e = this._poissonDenoisePass) === null || _e === void 0 ? void 0 : _e.dispose();
        (_f = this._copyMaterial) === null || _f === void 0 ? void 0 : _f.dispose();
        (_g = this._blendMaterial) === null || _g === void 0 ? void 0 : _g.dispose();
    }
    setSize(width, height) {
        var _a, _b, _c, _d, _e;
        this._width = width;
        this._height = height;
        (_a = this._aoAndSoftShadowRenderTarget) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
        (_b = this._softShadowPass) === null || _b === void 0 ? void 0 : _b.setSize(width, height);
        (_c = this._aoPass) === null || _c === void 0 ? void 0 : _c.setSize(width, height);
        (_d = this._fadeRenderTarget) === null || _d === void 0 ? void 0 : _d.setSize(width, height);
        (_e = this._poissonDenoisePass) === null || _e === void 0 ? void 0 : _e.setSize(this._width, this._height);
        this.needsUpdate = true;
    }
    updateParameters(parameters) {
        if (parameters.enabled !== undefined) {
            this.parameters.enabled = parameters.enabled;
        }
        if (parameters.aoIntensity !== undefined) {
            this.parameters.aoIntensity = parameters.aoIntensity;
        }
        if (parameters.shadowIntensity !== undefined) {
            this.parameters.shadowIntensity = parameters.shadowIntensity;
        }
        if (parameters.aoOnGround !== undefined) {
            this.parameters.aoOnGround = parameters.aoOnGround;
        }
        if (parameters.shadowOnGround !== undefined) {
            this.parameters.shadowOnGround = parameters.shadowOnGround;
        }
        if (parameters.alwaysUpdate !== undefined) {
            this.parameters.alwaysUpdate = parameters.alwaysUpdate;
        }
        this._updatePassParameters(parameters);
    }
    _updatePassParameters(parameters) {
        var _a, _b;
        if (parameters === null || parameters === void 0 ? void 0 : parameters.shadow) {
            for (let propertyName in parameters.shadow) {
                if (this.parameters.shadow.hasOwnProperty(propertyName)) {
                    this.parameters.shadow[propertyName] =
                        parameters.shadow[propertyName];
                }
            }
            if (this._softShadowPass) {
                this._softShadowPass.needsUpdate = true;
            }
        }
        if (parameters === null || parameters === void 0 ? void 0 : parameters.ao) {
            for (let propertyName in parameters.ao) {
                if (this.parameters.ao.hasOwnProperty(propertyName)) {
                    this.parameters.ao[propertyName] = parameters.ao[propertyName];
                }
            }
            if (this._aoPass) {
                (_a = this._aoPass) === null || _a === void 0 ? void 0 : _a.updateParameters(parameters === null || parameters === void 0 ? void 0 : parameters.ao);
            }
        }
        if (parameters === null || parameters === void 0 ? void 0 : parameters.poissonDenoise) {
            if (this._poissonDenoisePass) {
                (_b = this._poissonDenoisePass) === null || _b === void 0 ? void 0 : _b.updateParameters(parameters === null || parameters === void 0 ? void 0 : parameters.poissonDenoise);
            }
            else {
                for (let propertyName in parameters.poissonDenoise) {
                    if (this.parameters.poissonDenoise.hasOwnProperty(propertyName)) {
                        this.parameters.poissonDenoise[propertyName] =
                            parameters.poissonDenoise[propertyName];
                    }
                }
            }
        }
    }
    updateBounds(sceneBounds, _shadowAndAoScale) {
        var _a, _b;
        (_a = this._softShadowPass) === null || _a === void 0 ? void 0 : _a.updateBounds(sceneBounds.bounds);
        (_b = this._aoPass) === null || _b === void 0 ? void 0 : _b.updateBounds(sceneBounds.bounds, _shadowAndAoScale);
    }
    _getRenderConditions(shadowFadeInBlurType = SHADOW_BLUR_TYPES.FULL, shadowFadeInMix = 0, noOStaticFrames = 0) {
        const fadeInPoissonShadow = shadowFadeInBlurType === SHADOW_BLUR_TYPES.POISSON &&
            shadowFadeInMix > 0.001;
        const fadeInHardShadow = shadowFadeInBlurType === SHADOW_BLUR_TYPES.HARD &&
            shadowFadeInMix > 0.001 &&
            shadowFadeInMix < 0.999;
        const onlyHardShadow = shadowFadeInBlurType === SHADOW_BLUR_TYPES.HARD && !fadeInHardShadow;
        const progressiveDenoise = !fadeInPoissonShadow &&
            !fadeInHardShadow &&
            noOStaticFrames > 1 &&
            noOStaticFrames <= this.parameters.progressiveDenoiseIterations + 1;
        return {
            fadeInPoissonShadow,
            fadeInHardShadow,
            onlyHardShadow,
            progressiveDenoise,
        };
    }
    renderPass(renderer) {
        if (!this._setRenderState()) {
            return;
        }
        const renderConditions = this._getRenderConditions(this.shadowAndAoPassSettings.shadowFadeInBlurType, this.shadowAndAoPassSettings.shadowFadeInMix, this.shadowAndAoPassSettings.noOStaticFrames);
        let needsDenoise = false;
        if (!renderConditions.onlyHardShadow &&
            this.shadowAndAoPassSettings.shadowBlurType === SHADOW_BLUR_TYPES.FULL &&
            this._evaluateIfUpdateIsNeeded(this.camera)) {
            this._renderShadowAndAo(renderer, this.scene, this.camera, this.shadowAndAoPassSettings.shadowMapTexture);
            needsDenoise = true;
        }
        let finalTexture = renderConditions.onlyHardShadow
            ? this.shadowAndAoPassSettings.shadowMapTexture
            : this.denoiseRenderTargetTexture;
        if (renderConditions.fadeInPoissonShadow) {
            finalTexture = this._renderDynamicShadow(renderer, this.aoAndSoftShadowRenderTarget.texture, this.shadowAndAoPassSettings.shadowMapTexture, this.shadowAndAoPassSettings.shadowFadeInMix);
            needsDenoise = true;
        }
        if (needsDenoise) {
            finalTexture = this._renderDenoise(renderer, this.camera, renderConditions.fadeInPoissonShadow, false);
        }
        else if (renderConditions.progressiveDenoise) {
            finalTexture = this._renderDenoise(renderer, this.camera, false, true);
        }
        if (renderConditions.fadeInHardShadow) {
            finalTexture = this._renderDynamicShadow(renderer, this.denoiseRenderTargetTexture, this.shadowAndAoPassSettings.shadowMapTexture, this.shadowAndAoPassSettings.shadowFadeInMix);
        }
        this._renderToTarget(renderer, finalTexture, renderConditions.onlyHardShadow);
    }
    _setRenderState() {
        if (!this.parameters.enabled ||
            !(this.parameters.ao.algorithm !== null ||
                this.parameters.shadowIntensity >= 0.01)) {
            return false;
        }
        if (this.needsUpdate) {
            if (this._aoPass) {
                this._aoPass.needsUpdate = true;
            }
            if (this._poissonDenoisePass) {
                this._poissonDenoisePass.needsUpdate = true;
            }
        }
        return true;
    }
    _evaluateIfUpdateIsNeeded(camera) {
        camera.updateProjectionMatrix();
        const needsUpdate = this.parameters.alwaysUpdate ||
            this.needsUpdate ||
            (camera != null && this._cameraUpdate.changed(camera));
        this.needsUpdate = false;
        return needsUpdate;
    }
    _renderShadowAndAo(renderer, scene, camera, shadowMapTexture) {
        var _a;
        const renderAo = this.parameters.ao.algorithm !== null &&
            this.parameters.aoIntensity > 0.01;
        if (!renderAo) {
            (_a = this._aoPass) === null || _a === void 0 ? void 0 : _a.clear(renderer, this.aoAndSoftShadowRenderTarget);
        }
        this._renderSoftShadow(renderer, camera, shadowMapTexture);
        if (renderAo) {
            this._renderAo(renderer, scene, camera);
        }
    }
    _renderAo(renderer, scene, camera) {
        const depthTexture = this.gBufferTextures.depthBufferTexture;
        const normalTexture = this.gBufferTextures.gBufferTexture;
        const renderTarget = this._aoAndSoftShadowRenderTarget;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        const aoPass = this.aoRenderPass;
        aoPass.depthTexture = depthTexture;
        aoPass.normalTexture = normalTexture;
        aoPass.render(renderer, camera, scene, renderTarget);
        renderer.autoClear = autoClear;
    }
    _renderSoftShadow(renderer, camera, shadowMapTexture) {
        const softShadowPass = this.softShadowPass;
        softShadowPass.parameters.radius = this.parameters.shadow.shadowRadius;
        softShadowPass.inputTexture = shadowMapTexture;
        this.softShadowPass.renderToTarget(renderer, camera, this.aoAndSoftShadowRenderTarget);
    }
    _renderDynamicShadow(renderer, passTexture, shadowMapTexture, shadowFadeInMix = 1) {
        const fade = shadowFadeInMix < 0.999;
        if (fade) {
            this._copyMaterial.update({
                texture: passTexture,
                blending: NoBlending,
                colorTransform: DEFAULT_TRANSFORM,
                multiplyChannels: 0,
            });
            this.passRenderer.renderScreenSpace(renderer, this._copyMaterial, this.fadeRenderTarget);
        }
        if (shadowFadeInMix > 0.001) {
            this._blendMaterial.update({
                texture: shadowMapTexture,
                blending: fade ? CustomBlending : NoBlending,
                // prettier-ignore
                colorTransform: new Matrix4().set(0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, fade ? shadowFadeInMix : 1),
                multiplyChannels: 0,
            });
            this.passRenderer.renderScreenSpace(renderer, this._blendMaterial, this.fadeRenderTarget);
        }
        return this.fadeRenderTarget.texture;
    }
    _renderDenoise(renderer, camera, fadeInShadow, progressiveDenoise) {
        const denoisePass = this.denoisePass;
        denoisePass.inputTexture = fadeInShadow
            ? this.fadeRenderTarget.texture
            : progressiveDenoise
                ? denoisePass.texture
                : this.aoAndSoftShadowRenderTarget.texture;
        denoisePass.render(renderer, camera);
        return denoisePass.texture;
    }
    _renderToTarget(renderer, finalTexture, onlyHardShadow) {
        const redChannel = onlyHardShadow
            ? this.parameters.shadowIntensity
            : this.parameters.aoIntensity;
        const greenChannel = onlyHardShadow ? 0 : this.parameters.shadowIntensity;
        this.passRenderer.renderScreenSpace(renderer, this._copyMaterial.update({
            texture: finalTexture,
            blending: CustomBlending,
            colorTransform: interpolationMatrix(redChannel, greenChannel, 0, 1),
            multiplyChannels: 1,
        }), renderer.getRenderTarget());
    }
}
// prettier-ignore
ShadowAndAoPass.shadowTransform = new Matrix4().set(0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);

class OutlineRenderer {
    get isOutlinePassActivated() {
        return this.outlinePassActivated;
    }
    get outlinePass() {
        return this._renderPassManager.outlinePass;
    }
    constructor(renderPassManager, _effectComposer, parameters) {
        this._effectComposer = null;
        this.outlinePassActivated = false;
        this._renderPassManager = renderPassManager;
        this._effectComposer = _effectComposer;
        this.parameters = {
            enabled: true,
            edgeStrength: 2.0,
            edgeGlow: 1.0,
            edgeThickness: 2.0,
            pulsePeriod: 0,
            usePatternTexture: false,
            visibleEdgeColor: 0xffffff,
            hiddenEdgeColor: 0xffffff,
            ...parameters,
        };
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
            }
        }
    }
    applyParameters() {
        if (!this.outlinePass) {
            return;
        }
        this.outlinePass.edgeStrength = this.parameters.edgeStrength;
        this.outlinePass.edgeGlow = this.parameters.edgeGlow;
        this.outlinePass.edgeThickness = this.parameters.edgeThickness;
        this.outlinePass.pulsePeriod = this.parameters.pulsePeriod;
        this.outlinePass.usePatternTexture = this.parameters.usePatternTexture;
        this.outlinePass.visibleEdgeColor.set(this.parameters.visibleEdgeColor);
        this.outlinePass.hiddenEdgeColor.set(this.parameters.hiddenEdgeColor);
    }
    activateOutline(scene, camera) {
        var _a;
        if (!this.parameters.enabled) {
            this.deactivateOutline();
            return;
        }
        const needsUpdate = ((_a = this.outlinePass) === null || _a === void 0 ? void 0 : _a.renderCamera) &&
            camera.isPerspectiveCamera !==
                this.outlinePass.renderCamera
                    .isPerspectiveCamera;
        if (this.outlinePass) {
            this.outlinePass.renderScene = scene;
            this.outlinePass.renderCamera = camera;
        }
        if (!needsUpdate && this.outlinePassActivated) {
            return;
        }
        if (needsUpdate || !this.outlinePass) {
            this._renderPassManager.createOutlinePass();
        }
        this.applyParameters();
        if (this._effectComposer) {
            this._effectComposer.addPass(this.outlinePass);
        }
        this.outlinePassActivated = true;
    }
    deactivateOutline() {
        if (!this.outlinePassActivated) {
            return;
        }
        if (this.outlinePass && this._effectComposer) {
            this._effectComposer.removePass(this.outlinePass);
        }
        this.outlinePassActivated = false;
    }
    updateOutline(scene, camera, selectedObjects) {
        if (selectedObjects.length > 0) {
            this.activateOutline(scene, camera);
            if (this.outlinePass) {
                this.outlinePass.selectedObjects = selectedObjects;
            }
        }
        else {
            this.deactivateOutline();
        }
    }
}

class RenderCacheMapItem {
    constructor(cache) {
        this.needsUpdate = true;
        this._cache = null;
        this._cache = cache;
    }
    dispose() {
        var _a;
        (_a = this._cache) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    clear() {
        var _a;
        (_a = this._cache) === null || _a === void 0 ? void 0 : _a.clear();
        this.needsUpdate = true;
    }
    update(object3d) {
        if (!this.needsUpdate || !this._cache) {
            return;
        }
        object3d.traverse((object) => {
            var _a, _b, _c;
            if (object.isLine ||
                object.isPoints) {
                (_a = this._cache) === null || _a === void 0 ? void 0 : _a.addLineOrPoint(object);
            }
            else if (object.isMesh) {
                (_b = this._cache) === null || _b === void 0 ? void 0 : _b.addMesh(object);
            }
            else {
                (_c = this._cache) === null || _c === void 0 ? void 0 : _c.addObject(object);
            }
        });
        this.needsUpdate = false;
    }
    onBeforeRender() {
        var _a;
        (_a = this._cache) === null || _a === void 0 ? void 0 : _a.onBeforeRender();
    }
    onAfterRender() {
        var _a;
        (_a = this._cache) === null || _a === void 0 ? void 0 : _a.onAfterRender();
    }
}
class RenderCacheManager {
    constructor() {
        this._cacheMap = new Map();
    }
    dispose() {
        this._cacheMap.forEach((cache) => {
            cache.dispose();
        });
    }
    registerCache(key, cache) {
        this._cacheMap.set(key, new RenderCacheMapItem(cache));
    }
    clearCache() {
        this._cacheMap.forEach((cache) => {
            cache.clear();
        });
    }
    clearObjectCache(key) {
        const cache = this._cacheMap.get(key);
        if (cache) {
            cache.clear();
        }
    }
    onBeforeRender(key, object3d) {
        const cache = this._cacheMap.get(key);
        if (cache) {
            cache.update(object3d);
            cache.onBeforeRender();
        }
    }
    onAfterRender(key) {
        const cache = this._cacheMap.get(key);
        if (cache) {
            cache.onAfterRender();
        }
    }
    render(key, object3d, renderMethod) {
        const cache = this._cacheMap.get(key);
        if (cache) {
            cache.update(object3d);
            cache.onBeforeRender();
        }
        renderMethod();
        if (cache) {
            cache.onAfterRender();
        }
    }
}
class VisibilityRenderCache {
    constructor(isObjectInvisible) {
        this._visibilityCache = new Map();
        this._isObjectInvisible = isObjectInvisible;
    }
    dispose() {
        this._visibilityCache.clear();
    }
    clear() {
        this._visibilityCache.clear();
    }
    addLineOrPoint(object3d) {
        this._visibilityCache.set(object3d, object3d.visible);
    }
    addMesh(mesh) {
        if (this._isObjectInvisible && this._isObjectInvisible(mesh)) {
            this._visibilityCache.set(mesh, mesh.visible);
        }
    }
    addObject(object3d) {
        if (this._isObjectInvisible && this._isObjectInvisible(object3d)) {
            this._visibilityCache.set(object3d, object3d.visible);
        }
    }
    onBeforeRender() {
        this._visibilityCache.forEach((_visible, object) => {
            object.visible = false;
        });
    }
    onAfterRender() {
        this._visibilityCache.forEach((visible, object) => {
            object.visible = visible;
        });
    }
}
class DepthWriteRenderCache {
    constructor(doNotWriteDepth) {
        this._depthWriteCache = new Set();
        this._doNotWriteDepth = doNotWriteDepth;
    }
    dispose() {
        this._depthWriteCache.clear();
    }
    clear() {
        this._depthWriteCache.clear();
    }
    addLineOrPoint(_) {
        // do nothing
    }
    addObject(_) {
        // do nothing
    }
    addMesh(mesh) {
        if (this._doNotWriteDepth &&
            this._doNotWriteDepth(mesh) &&
            mesh.material instanceof MeshStandardMaterial &&
            mesh.material.depthWrite) {
            this._depthWriteCache.add(mesh.material);
        }
    }
    onBeforeRender() {
        this._depthWriteCache.forEach((material) => {
            material.depthWrite = false;
        });
    }
    onAfterRender() {
        this._depthWriteCache.forEach((material) => {
            material.depthWrite = true;
        });
    }
}
class ObjectRenderCache {
    constructor() {
        this._objectCache = new Map();
    }
    clear() {
        this._objectCache.clear();
    }
    onBeforeRender() {
        this._objectCache.forEach((data, object) => {
            if (object instanceof Mesh) {
                // update the cache if the material of the object has changed
                if (object.material !== data.originalObjectData.material &&
                    object.material !== data.updateObjectData.material) {
                    data.originalObjectData.material = object.material;
                }
            }
            this._updateObject(object, data.updateObjectData);
        });
    }
    onAfterRender() {
        this._objectCache.forEach((data, object) => {
            this._updateObject(object, data.originalObjectData);
        });
    }
    addToCache(object, updateObjectData) {
        this._objectCache.set(object, {
            originalObjectData: {
                visible: object.visible,
                castShadow: object.castShadow,
                receiveShadow: object instanceof Mesh ? object.receiveShadow : undefined,
                material: object instanceof Mesh ? object.material : undefined,
            },
            updateObjectData,
        });
    }
    _updateObject(object, objectData) {
        if (objectData.visible !== undefined) {
            object.visible = objectData.visible;
        }
        if (objectData.castShadow !== undefined) {
            object.castShadow = objectData.castShadow;
        }
        if (object instanceof Mesh && objectData.receiveShadow !== undefined) {
            object.receiveShadow = objectData.receiveShadow;
        }
        if (object instanceof Mesh && objectData.material !== undefined) {
            object.material = objectData.material;
        }
    }
}

const castGroundContactShadow = (object) => {
    var _a;
    if (!object.isMesh) {
        return false;
    }
    if (!object.castShadow && !((_a = object.userData) === null || _a === void 0 ? void 0 : _a.meshId)) {
        return false;
    }
    const material = object.material;
    return !material.transparent || material.opacity > 0.5;
};
class BakedGroundContactShadowPass extends RenderPass {
    get shadowGroundPlane() {
        var _a;
        let shadowGroundPlaneMesh = this._sharedShadowGroundPlane;
        if (!shadowGroundPlaneMesh) {
            (_a = this._shadowGroundPlane) !== null && _a !== void 0 ? _a : (this._shadowGroundPlane = new ShadowGroundPlane(this.renderTarget.texture, this.parameters));
            shadowGroundPlaneMesh = this._shadowGroundPlane;
        }
        if (shadowGroundPlaneMesh.parent !== this._groundGroup) {
            this._groundGroup.add(shadowGroundPlaneMesh);
        }
        return shadowGroundPlaneMesh;
    }
    constructor(renderPassManager, renderer, groundGroup, parameters) {
        var _a, _b;
        super(renderPassManager);
        this.needsUpdate = true;
        this.noNeedOfUpdateCount = 0;
        this._blurScale = 1;
        this._shadowScale = 1;
        this._groundGroup = groundGroup;
        this.shadowMapSize = (_a = parameters.shadowMapSize) !== null && _a !== void 0 ? _a : 2048;
        this.parameters = this._getDefaultParameters(parameters);
        this._groundShadowFar = this.parameters.cameraFar;
        this._renderer = renderer;
        (_b = this.renderCacheManager) === null || _b === void 0 ? void 0 : _b.registerCache(this, new VisibilityRenderCache((object) => {
            return ((object.isMesh && !castGroundContactShadow(object)) ||
                (object.name !== undefined &&
                    ['Ground', 'Floor'].includes(object.name)));
        }));
        this.renderTarget = new WebGLRenderTarget(this.shadowMapSize, this.shadowMapSize);
        this.renderTarget.texture.generateMipmaps = false;
        this._renderTargetBlur = new WebGLRenderTarget(this.shadowMapSize, this.shadowMapSize);
        this._renderTargetBlur.texture.generateMipmaps = false;
        this._sharedShadowGroundPlane = parameters === null || parameters === void 0 ? void 0 : parameters.sharedShadowGroundPlane;
        this.shadowGroundPlane.setShadowMap(this.renderTarget.texture);
        this.shadowGroundPlane.updateMaterial(this.parameters);
        this._groundContactCamera = new GroundContactCamera();
        this._groundGroup.add(this._groundContactCamera);
        this._depthMaterial = new MeshDepthMaterial();
        this._depthMaterial.userData.fadeoutBias = {
            value: this.parameters.fadeoutBias,
        };
        this._depthMaterial.userData.fadeoutFalloff = {
            value: this.parameters.fadeoutFalloff,
        };
        this._depthMaterial.onBeforeCompile = (shader) => {
            shader.uniforms.fadeoutBias = this._depthMaterial.userData.fadeoutBias;
            shader.uniforms.fadeoutFalloff =
                this._depthMaterial.userData.fadeoutFalloff;
            shader.fragmentShader = `
              uniform float fadeoutBias;
              uniform float fadeoutFalloff;
              ${shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', ShadowGroundPlane.alphaMap
                ? 'gl_FragColor = vec4(clamp(pow(1.0 + fadeoutBias - fragCoordZ, 1.0/(1.0-fadeoutFalloff)), 0.0, 1.0));'
                : 'gl_FragColor = vec4(vec3(0.0), clamp(pow(1.0 + fadeoutBias - fragCoordZ, 1.0/(1.0-fadeoutFalloff)), 0.0, 1.0));')}
          `;
        };
        this._depthMaterial.side = DoubleSide;
        this._depthMaterial.depthTest = true;
        this._depthMaterial.depthWrite = true;
        this._blurPass = new BlurPass(BlurShader, {
            ...parameters,
            passRenderer: this.renderPassManager.passRenderer,
        });
        this.updatePlaneAndShadowCamera();
    }
    // eslint-disable-next-line complexity
    _getDefaultParameters(parameters) {
        return {
            enabled: true,
            cameraHelper: false,
            alwaysUpdate: false,
            fadeIn: false,
            blurMin: 0.001,
            blurMax: 0.1,
            fadeoutFalloff: 0.9,
            fadeoutBias: 0.03,
            opacity: 0.5,
            maximumPlaneSize: 40,
            planeSize: 10,
            cameraFar: 3,
            hardLayers: null,
            softLayers: null,
            polygonOffset: 2,
            excludeGroundObjects: true,
            ...parameters,
        };
    }
    dispose() {
        this.renderTarget.dispose();
        this._renderTargetBlur.dispose();
        this._blurPass.dispose();
        this._depthMaterial.dispose();
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
            }
        }
        if (parameters.cameraFar !== undefined) {
            this._groundShadowFar = this.parameters.cameraFar;
        }
    }
    applyParameters() {
        this.shadowGroundPlane.updateMaterial(this.parameters);
        this._groundContactCamera.updateCameraHelper(this.parameters.cameraHelper);
        if (this._groundContactCamera.far !== this.parameters.cameraFar) {
            this.updatePlaneAndShadowCamera();
        }
        const fadeoutFalloff = this.parameters.fadeoutFalloff;
        if (this._depthMaterial.userData.fadeoutFalloff.value !== fadeoutFalloff) {
            this._depthMaterial.userData.fadeoutFalloff.value =
                this.parameters.fadeoutFalloff;
        }
        const fadeoutBias = this.parameters.fadeoutBias / this._groundContactCamera.far;
        if (this._depthMaterial.userData.fadeoutBias.value !== fadeoutBias) {
            this._depthMaterial.userData.fadeoutBias.value = fadeoutBias;
        }
        this.needsUpdate = true;
    }
    setScale(groundContactShadowScale, _shadowScale) {
        this._blurScale = groundContactShadowScale;
        this._shadowScale = _shadowScale !== null && _shadowScale !== void 0 ? _shadowScale : groundContactShadowScale;
        this.needsUpdate = true;
    }
    updateBounds(sceneBounds, groundLevel) {
        var _a;
        this._groundShadowFar = this.parameters.cameraFar;
        if (this._groundShadowFar < sceneBounds.size.z) {
            this._groundShadowFar = sceneBounds.size.z * 1.01;
        }
        const maxPlanSideLength = Math.max(sceneBounds.size.x, sceneBounds.size.z);
        this.parameters.planeSize =
            maxPlanSideLength +
                2 * Math.max(this._blurScale, (_a = this._shadowScale) !== null && _a !== void 0 ? _a : 1, 1);
        if (this.parameters.planeSize > this.parameters.maximumPlaneSize) {
            this.parameters.planeSize = this.parameters.maximumPlaneSize;
            this._groundGroup.position.set(0, groundLevel !== null && groundLevel !== void 0 ? groundLevel : 0, 0);
        }
        else {
            this._groundGroup.position.set(sceneBounds.center.x, groundLevel !== null && groundLevel !== void 0 ? groundLevel : 0, sceneBounds.center.z);
        }
        this._groundGroup.updateMatrixWorld();
        this.updatePlaneAndShadowCamera();
    }
    updatePlaneAndShadowCamera() {
        const size = this.parameters.planeSize;
        this.shadowGroundPlane.scale.x = size;
        this.shadowGroundPlane.scale.y = size;
        this._groundContactCamera.updateCameraFormPlaneSize(size, this._groundShadowFar);
        this.needsUpdate = true;
    }
    setGroundVisibilityLayers(visible) {
        this.shadowGroundPlane.setVisibilityLayers(visible);
    }
    renderPass(_renderer) {
        this._groundContactCamera.updateCameraHelper(this.parameters.cameraHelper, this.scene);
        if (!this.parameters.enabled) {
            return;
        }
        const maxIterations = 10;
        this.shadowGroundPlane.visible = this.parameters.enabled;
        const needsUpdate = this.parameters.alwaysUpdate || this.needsUpdate;
        if (!needsUpdate) {
            this.noNeedOfUpdateCount++;
            if (this.noNeedOfUpdateCount >= maxIterations) {
                return;
            }
        }
        else {
            this.noNeedOfUpdateCount = 0;
        }
        this.needsUpdate = false;
        const shadowGroundMaterial = this.shadowGroundPlane
            .material;
        shadowGroundMaterial.opacity =
            this.parameters.alwaysUpdate || !this.parameters.fadeIn
                ? this.parameters.opacity
                : (this.parameters.opacity * (this.noNeedOfUpdateCount + 2)) /
                    (maxIterations + 2);
        const initialClearAlpha = this._renderer.getClearAlpha();
        this._renderer.setClearAlpha(0);
        this._groundGroup.visible = false;
        this.shadowGroundPlane.visible = false;
        this._groundContactCamera.setCameraHelperVisibility(false);
        if (this.noNeedOfUpdateCount === 0) {
            this._renderGroundContact(this.scene);
            this._renderBlur();
        }
        else if (this.noNeedOfUpdateCount === 1) {
            this._renderBlur();
        }
        this._renderReduceBandingBlur();
        this._renderer.setRenderTarget(null);
        this._renderer.setClearAlpha(initialClearAlpha);
        this._groundGroup.visible = true;
        this.shadowGroundPlane.visible = this.parameters.enabled;
        this._groundContactCamera.setCameraHelperVisibility(this.parameters.cameraHelper);
    }
    _renderGroundContact(scene) {
        const initialBackground = scene.background;
        scene.background = null;
        scene.overrideMaterial = this._depthMaterial;
        this._renderer.setRenderTarget(this.renderTarget);
        this._renderer.clear();
        const autoClearBackup = this._renderer.autoClear;
        this._renderer.autoClear = false;
        if (this.parameters.hardLayers) {
            this._groundContactCamera.layers.mask = this.parameters.hardLayers.mask;
            this._groundContactCamera.updateCameraFarPlane(10);
            this._depthMaterial.userData.fadeoutBias.value = 0.99;
            this._renderer.render(scene, this._groundContactCamera);
            this._groundContactCamera.updateCameraFarPlane(this._groundShadowFar);
            this._depthMaterial.userData.fadeoutBias.value =
                this.parameters.fadeoutBias / this._groundShadowFar;
        }
        this._groundContactCamera.layers.enableAll();
        if (this.parameters.softLayers) {
            this._groundContactCamera.layers.mask = this.parameters.softLayers.mask;
        }
        if (this.renderCacheManager) {
            this.renderCacheManager.render(this, scene, () => {
                this._renderer.render(scene, this._groundContactCamera);
            });
        }
        else {
            this._renderer.render(scene, this._groundContactCamera);
        }
        this._renderer.autoClear = autoClearBackup;
        scene.overrideMaterial = null;
        scene.background = initialBackground;
    }
    _renderBlur() {
        this._renderBlurPass((this._blurScale * this.parameters.blurMin) / this.parameters.planeSize, (this._blurScale * this.parameters.blurMax) / this.parameters.planeSize);
    }
    _renderReduceBandingBlur() {
        const finalBlurAmount = (this._blurScale * 0.01) / this.parameters.planeSize;
        this._renderBlurPass(finalBlurAmount, finalBlurAmount);
    }
    _renderBlurPass(uvMin, uvMax) {
        this._blurPass.render(this._renderer, [this.renderTarget, this._renderTargetBlur, this.renderTarget], [uvMin, uvMin], [uvMax, uvMax]);
    }
}
BakedGroundContactShadowPass.addTestMesh = false;
class GroundContactCamera extends OrthographicCamera {
    constructor() {
        super(-1, 1, -1, 1, -1, 1);
        this.rotation.x = Math.PI; // make camera look upwards
    }
    updateCameraFormPlaneSize(planeSize, farPlane) {
        var _a;
        this.left = -planeSize / 2;
        this.right = planeSize / 2;
        this.top = -planeSize / 2;
        this.bottom = planeSize / 2;
        this.near = 0;
        this.far = farPlane;
        this.updateProjectionMatrix();
        (_a = this.cameraHelper) === null || _a === void 0 ? void 0 : _a.update();
    }
    updateCameraFarPlane(farPlane) {
        var _a;
        this.far = farPlane;
        this.updateProjectionMatrix();
        (_a = this.cameraHelper) === null || _a === void 0 ? void 0 : _a.update();
    }
    updateCameraHelper(enabled, scene) {
        var _a, _b, _c;
        if (enabled) {
            this.cameraHelper = (_a = this.cameraHelper) !== null && _a !== void 0 ? _a : new CameraHelper(this);
            this.cameraHelper.visible = true;
            scene === null || scene === void 0 ? void 0 : scene.add(this.cameraHelper);
        }
        else if ((_b = this.cameraHelper) === null || _b === void 0 ? void 0 : _b.parent) {
            (_c = this.cameraHelper) === null || _c === void 0 ? void 0 : _c.removeFromParent();
        }
    }
    setCameraHelperVisibility(visible) {
        if (this.cameraHelper) {
            this.cameraHelper.visible = visible;
        }
    }
}

const glslNormalAndDepthVertexShader = `varying vec3 vNormal;
#if LINEAR_DEPTH == 1
    varying float vZ;  
#endif

  void main() {
      vNormal = normalMatrix * normal;
      vec4 viewPosition = modelViewMatrix * vec4(position, 1.0);
      #if LINEAR_DEPTH == 1
          vZ = viewPosition.z;  
      #endif
      gl_Position = projectionMatrix * viewPosition;
  }`;
const glslNormalAndDepthFragmentShader = `varying vec3 vNormal;
#if LINEAR_DEPTH == 1
  varying float vZ;  
  uniform float cameraNear;
  uniform float cameraFar;
#endif

  void main() {
      #if FLOAT_BUFFER == 1
          vec3 normal = normalize(vNormal);
      #else
          vec3 normal = normalize(vNormal) * 0.5 + 0.5;
      #endif
      #if LINEAR_DEPTH == 1
          float depth = (-vZ - cameraNear) / (cameraFar - cameraNear);
      #else
          float depth = gl_FragCoord.z;
      #endif
      gl_FragColor = vec4(normal, depth);
  }`;
class NormalAndDepthRenderMaterial extends ShaderMaterial {
    constructor(parameters) {
        var _a;
        super({
            defines: Object.assign({
                ...NormalAndDepthRenderMaterial._normalAndDepthShader.defines,
                FLOAT_BUFFER: (parameters === null || parameters === void 0 ? void 0 : parameters.floatBufferType) ? 1 : 0,
                LINEAR_DEPTH: (parameters === null || parameters === void 0 ? void 0 : parameters.linearDepth) ? 1 : 0,
            }),
            uniforms: UniformsUtils.clone(NormalAndDepthRenderMaterial._normalAndDepthShader.uniforms),
            vertexShader: NormalAndDepthRenderMaterial._normalAndDepthShader.vertexShader,
            fragmentShader: NormalAndDepthRenderMaterial._normalAndDepthShader.fragmentShader,
            blending: (_a = parameters === null || parameters === void 0 ? void 0 : parameters.blending) !== null && _a !== void 0 ? _a : NoBlending,
        });
        this.update(parameters);
    }
    update(parameters) {
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.camera) !== undefined) {
            const camera = (parameters === null || parameters === void 0 ? void 0 : parameters.camera) ||
                (parameters === null || parameters === void 0 ? void 0 : parameters.camera);
            this.uniforms.cameraNear.value = camera.near;
            this.uniforms.cameraFar.value = camera.far;
        }
        return this;
    }
}
NormalAndDepthRenderMaterial._normalAndDepthShader = {
    uniforms: {
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1 },
    },
    defines: {
        FLOAT_BUFFER: 0,
        LINEAR_DEPTH: 0,
    },
    vertexShader: glslNormalAndDepthVertexShader,
    fragmentShader: glslNormalAndDepthFragmentShader,
};

class GBufferRenderPass extends RenderPass {
    set groundDepthWrite(value) {
        if (this._gBufferMaterialCache) {
            this._gBufferMaterialCache.groundDepthWrite = value;
        }
    }
    get isFloatGBufferWithRgbNormalAlphaDepth() {
        return this.floatRgbNormalAlphaDepth;
    }
    get gBufferTexture() {
        return this.depthNormalRenderTarget.texture;
    }
    get depthBufferTexture() {
        return this.copyToSeparateDepthBuffer && this.floatRgbNormalAlphaDepth
            ? this.separateDeptRenderTarget.texture
            : this.depthNormalRenderTarget.depthTexture;
    }
    get textureWithDepthValue() {
        return this.floatRgbNormalAlphaDepth
            ? this.depthNormalRenderTarget.texture
            : this.depthNormalRenderTarget.depthTexture;
    }
    updateGBufferRenderMaterial(camera) {
        var _a;
        this._gBufferRenderMaterial =
            (_a = this._gBufferRenderMaterial) !== null && _a !== void 0 ? _a : (this.floatRgbNormalAlphaDepth
                ? new NormalAndDepthRenderMaterial({
                    blending: NoBlending,
                    floatBufferType: true,
                    linearDepth: false,
                })
                : new MeshNormalMaterial({ blending: NoBlending }));
        if (this._gBufferRenderMaterial instanceof NormalAndDepthRenderMaterial) {
            this._gBufferRenderMaterial.update({ camera });
        }
        return this._gBufferRenderMaterial;
    }
    get depthNormalRenderTarget() {
        if (!this._depthNormalRenderTarget) {
            if (this.floatRgbNormalAlphaDepth) {
                this._depthNormalRenderTarget = new WebGLRenderTarget(this._width * this.parameters.depthNormalScale, this._height * this.parameters.depthNormalScale, {
                    minFilter: this._targetMinificationTextureFilter,
                    magFilter: this._targetMagnificationTextureFilter,
                    type: FloatType,
                    samples: this._samples,
                });
            }
            else {
                const depthTexture = new DepthTexture(this._width * this.parameters.depthNormalScale, this._height * this.parameters.depthNormalScale);
                depthTexture.format = DepthStencilFormat;
                depthTexture.type = UnsignedInt248Type;
                this._depthNormalRenderTarget = new WebGLRenderTarget(this._width * this.parameters.depthNormalScale, this._height * this.parameters.depthNormalScale, {
                    minFilter: this._targetMinificationTextureFilter,
                    magFilter: this._targetMagnificationTextureFilter,
                    depthTexture,
                });
            }
        }
        return this._depthNormalRenderTarget;
    }
    get separateDeptRenderTarget() {
        if (!this._separateDeptRenderTarget) {
            this._separateDeptRenderTarget = new WebGLRenderTarget(this._width * this.parameters.depthNormalScale, this._height * this.parameters.depthNormalScale, {
                minFilter: this._targetMinificationTextureFilter,
                magFilter: this._targetMagnificationTextureFilter,
                //format: RedFormat,
                type: FloatType,
                samples: 0,
            });
        }
        return this._separateDeptRenderTarget;
    }
    constructor(renderPassManager, parameters) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super(renderPassManager);
        this.floatRgbNormalAlphaDepth = false;
        this.linearDepth = false;
        this.copyToSeparateDepthBuffer = false;
        this.needsUpdate = true;
        this.drawGround = true;
        this.floatRgbNormalAlphaDepth = (_b = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.capabilities) === null || _a === void 0 ? void 0 : _a.isWebGL2) !== null && _b !== void 0 ? _b : false;
        if (this.renderCacheManager) {
            this._gBufferMaterialCache = new GBufferMaterialCache();
            this.renderCacheManager.registerCache(this, this._gBufferMaterialCache);
        }
        this.parameters = {
            depthNormalScale: (_c = parameters === null || parameters === void 0 ? void 0 : parameters.depthNormalScale) !== null && _c !== void 0 ? _c : 1,
        };
        this._targetMinificationTextureFilter =
            (_d = parameters === null || parameters === void 0 ? void 0 : parameters.textureMinificationFilter) !== null && _d !== void 0 ? _d : NearestFilter;
        this._targetMagnificationTextureFilter =
            (_e = parameters === null || parameters === void 0 ? void 0 : parameters.textureMagnificationFilter) !== null && _e !== void 0 ? _e : NearestFilter;
        this._width = (_f = parameters === null || parameters === void 0 ? void 0 : parameters.width) !== null && _f !== void 0 ? _f : 1024;
        this._height = (_g = parameters === null || parameters === void 0 ? void 0 : parameters.height) !== null && _g !== void 0 ? _g : 1024;
        this._samples = (_h = parameters === null || parameters === void 0 ? void 0 : parameters.samples) !== null && _h !== void 0 ? _h : 0;
        this._shared = (_j = parameters === null || parameters === void 0 ? void 0 : parameters.shared) !== null && _j !== void 0 ? _j : false;
    }
    dispose() {
        var _a, _b;
        super.dispose();
        (_a = this._gBufferRenderMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._depthNormalRenderTarget) === null || _b === void 0 ? void 0 : _b.dispose();
    }
    setSize(width, height) {
        var _a;
        this._width = width;
        this._height = height;
        (_a = this._depthNormalRenderTarget) === null || _a === void 0 ? void 0 : _a.setSize(this._width * this.parameters.depthNormalScale, this._height * this.parameters.depthNormalScale);
    }
    renderPass(renderer) {
        if (this._shared && !this.needsUpdate) {
            return;
        }
        this.needsUpdate = false;
        this.renderPassManager.setGroundVisibility(this.drawGround);
        if (this.renderCacheManager) {
            this.renderCacheManager.render(this, this.scene, () => {
                this._renderGBuffer(renderer, this.scene, this.camera);
            });
        }
        else {
            this._renderGBuffer(renderer, this.scene, this.camera);
        }
        this.renderPassManager.setGroundVisibility(false);
        if (this.floatRgbNormalAlphaDepth && this.copyToSeparateDepthBuffer) {
            this._copyDepthToSeparateDepthTexture(renderer, this.depthNormalRenderTarget);
        }
    }
    _renderGBuffer(renderer, scene, camera) {
        this.passRenderer.renderWithOverrideMaterial(renderer, scene, camera, this.updateGBufferRenderMaterial(camera), this.depthNormalRenderTarget, 0x7777ff, 1.0);
    }
    getCopyMaterial(parameters) {
        var _a;
        (_a = this._copyMaterial) !== null && _a !== void 0 ? _a : (this._copyMaterial = new CopyTransformMaterial());
        return this._copyMaterial.update(parameters);
    }
    _copyDepthToSeparateDepthTexture(renderer, source) {
        this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
            texture: source.texture,
            blending: NoBlending,
            colorTransform: ALPHA_TRANSFORM,
            colorBase: ALPHA_RGBA,
            multiplyChannels: 0,
            uvTransform: DEFAULT_UV_TRANSFORM,
        }), this.separateDeptRenderTarget);
    }
}
class GBufferMaterialCache extends ObjectRenderCache {
    set groundDepthWrite(value) {
        this._groundDepthWrite = value;
    }
    constructor() {
        super();
        this._groundDepthWrite = true;
    }
    dispose() {
        // nothing to do
    }
    addLineOrPoint(object3d) {
        this.addToCache(object3d, { visible: false });
    }
    addMesh(mesh) {
        if (mesh.userData.isFloor) {
            this.addToCache(mesh, { visible: this._groundDepthWrite });
        }
        else if (mesh.visible) {
            if (mesh.material instanceof Material &&
                ((mesh.material.transparent && mesh.material.opacity < 0.7) ||
                    mesh.material.alphaTest > 0)) {
                this.addToCache(mesh, { visible: false });
            }
            else if (mesh.material instanceof MeshPhysicalMaterial &&
                mesh.material.transmission > 0) {
                this.addToCache(mesh, { visible: false });
            }
        }
    }
    addObject(_object3d) {
        // nothing to do
    }
}

class GroundReflectionPass extends RenderPass {
    get reflectionRenderTarget() {
        var _a;
        this._reflectionRenderTarget =
            (_a = this._reflectionRenderTarget) !== null && _a !== void 0 ? _a : this._newRenderTarget(true);
        return this._reflectionRenderTarget;
    }
    get intensityRenderTarget() {
        var _a;
        this._intensityRenderTarget =
            (_a = this._intensityRenderTarget) !== null && _a !== void 0 ? _a : this._newRenderTarget(false);
        return this._intensityRenderTarget;
    }
    get blurRenderTarget() {
        var _a;
        this._blurRenderTarget =
            (_a = this._blurRenderTarget) !== null && _a !== void 0 ? _a : this._newRenderTarget(false);
        return this._blurRenderTarget;
    }
    constructor(renderPassManager, width, height, parameters) {
        super(renderPassManager);
        this.reflectionFadeInScale = 1;
        this._width = width;
        this._height = height;
        this.parameters = {
            enabled: false,
            intensity: 0.25,
            fadeOutDistance: 1,
            fadeOutExponent: 4,
            brightness: 1.0,
            blurHorizontal: 3.0,
            blurVertical: 6.0,
            blurAscent: 0,
            groundLevel: 0,
            groundReflectionScale: 1,
            renderTargetDownScale: 4,
            ...parameters,
        };
        this._copyMaterial = new CopyTransformMaterial({});
        this._updateCopyMaterial(null);
        this._reflectionIntensityMaterial = new GroundReflectionIntensityMaterial({
            width: this._width / this.parameters.renderTargetDownScale,
            height: this._height / this.parameters.renderTargetDownScale,
        });
        this._blurPass = new BlurPass(BlurShader, {
            ...parameters,
            passRenderer: this.renderPassManager.passRenderer,
        });
    }
    _newRenderTarget(createDepthTexture) {
        const _width = this._width / this.parameters.renderTargetDownScale;
        const _height = this._height / this.parameters.renderTargetDownScale;
        let additionalParameters = {};
        if (createDepthTexture) {
            const depthTexture = new DepthTexture(_width, _height);
            depthTexture.format = DepthStencilFormat;
            depthTexture.type = UnsignedInt248Type;
            additionalParameters.minFilter = NearestFilter;
            additionalParameters.magFilter = NearestFilter;
            additionalParameters.depthTexture = depthTexture;
        }
        else {
            additionalParameters.samples = 1;
        }
        return new WebGLRenderTarget(_width, _height, {
            format: RGBAFormat$1,
            ...additionalParameters,
        });
    }
    dispose() {
        var _a, _b, _c;
        super.dispose();
        (_a = this._reflectionRenderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._intensityRenderTarget) === null || _b === void 0 ? void 0 : _b.dispose();
        (_c = this._blurRenderTarget) === null || _c === void 0 ? void 0 : _c.dispose();
        this._copyMaterial.dispose();
    }
    setSize(width, height) {
        var _a, _b, _c, _d;
        this._width = width;
        this._height = height;
        (_a = this._reflectionRenderTarget) === null || _a === void 0 ? void 0 : _a.setSize(this._width / this.parameters.renderTargetDownScale, this._height / this.parameters.renderTargetDownScale);
        (_b = this._intensityRenderTarget) === null || _b === void 0 ? void 0 : _b.setSize(this._width / this.parameters.renderTargetDownScale, this._height / this.parameters.renderTargetDownScale);
        (_c = this._blurRenderTarget) === null || _c === void 0 ? void 0 : _c.setSize(this._width / this.parameters.renderTargetDownScale, this._height / this.parameters.renderTargetDownScale);
        (_d = this._reflectionIntensityMaterial) === null || _d === void 0 ? void 0 : _d.update({
            width: this._width / this.parameters.renderTargetDownScale,
            height: this._height / this.parameters.renderTargetDownScale,
        });
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
            }
        }
    }
    updateBounds(groundLevel, groundReflectionScale) {
        this.parameters.groundLevel = groundLevel;
        this.parameters.groundReflectionScale = groundReflectionScale;
    }
    _updateCopyMaterial(renderTarget, reflectionFadeInScale = 1) {
        var _a;
        const intensity = this.parameters.intensity * reflectionFadeInScale;
        const brightness = this.parameters.brightness;
        this._copyMaterial.update({
            texture: (_a = renderTarget === null || renderTarget === void 0 ? void 0 : renderTarget.texture) !== null && _a !== void 0 ? _a : undefined,
            // prettier-ignore
            colorTransform: new Matrix4().set(brightness, 0, 0, 0, 0, brightness, 0, 0, 0, 0, brightness, 0, 0, 0, 0, intensity),
            multiplyChannels: 0,
            uvTransform: FLIP_Y_UV_TRANSFORM,
        });
        this._copyMaterial.depthTest = true;
        this._copyMaterial.depthWrite = false;
    }
    renderPass(renderer) {
        if (!this.parameters.enabled ||
            !(this.camera instanceof PerspectiveCamera)) {
            return;
        }
        const groundReflectionCamera = this._createGroundReflectionCamera(this.camera);
        this.renderCacheManager.render('inivisibleGround', this.scene, () => {
            this._renderGroundReflection(renderer, this.scene, groundReflectionCamera, this.reflectionRenderTarget);
        });
        this._renderGroundReflectionIntensity(renderer, groundReflectionCamera, this.intensityRenderTarget);
        if (this.parameters.blurHorizontal > 0 ||
            this.parameters.blurVertical > 0) {
            this.blurReflection(renderer, this.camera, [
                this.intensityRenderTarget,
                this.blurRenderTarget,
                this.intensityRenderTarget,
            ]);
        }
        this._updateCopyMaterial(this.intensityRenderTarget, this.reflectionFadeInScale);
        this.passRenderer.renderScreenSpace(renderer, this._copyMaterial, renderer.getRenderTarget());
    }
    _renderGroundReflection(renderer, scene, groundReflectionCamera, renderTarget) {
        const renderTargetBackup = renderer.getRenderTarget();
        if (renderTarget) {
            renderer.setRenderTarget(renderTarget);
        }
        renderer.render(scene, groundReflectionCamera);
        if (renderTarget) {
            renderer.setRenderTarget(renderTargetBackup);
        }
    }
    _renderGroundReflectionIntensity(renderer, groundReflectionCamera, renderTarget) {
        const renderTargetBackup = renderer.getRenderTarget();
        renderer.setRenderTarget(renderTarget);
        this.passRenderer.renderScreenSpace(renderer, this._reflectionIntensityMaterial.update({
            texture: this.reflectionRenderTarget.texture,
            depthTexture: this.reflectionRenderTarget.depthTexture,
            camera: groundReflectionCamera,
            groundLevel: this.parameters.groundLevel,
            fadeOutDistance: this.parameters.fadeOutDistance *
                this.parameters.groundReflectionScale,
            fadeOutExponent: this.parameters.fadeOutExponent,
        }), renderer.getRenderTarget());
        renderer.setRenderTarget(renderTargetBackup);
    }
    blurReflection(renderer, camera, renderTargets) {
        const cameraUpVector = new Vector3(camera.matrixWorld.elements[4], camera.matrixWorld.elements[5], camera.matrixWorld.elements[6]);
        const blurHorMin = this.parameters.blurHorizontal / this._width;
        const blurVerMin = (this.parameters.blurVertical / this._height) *
            Math.abs(cameraUpVector.dot(new Vector3(0, 0, 1)));
        this._blurPass.render(renderer, renderTargets, [blurHorMin * 4, blurVerMin * 4], [
            blurHorMin * 4 * (1 + this.parameters.blurAscent),
            blurVerMin * 4 * (1 + this.parameters.blurAscent),
        ]);
    }
    _createGroundReflectionCamera(camera) {
        const groundReflectionCamera = camera.clone();
        const cameraOffset = groundReflectionCamera;
        if (cameraOffset._offset) {
            cameraOffset._offset = {
                left: cameraOffset._offset.left,
                top: 1 - cameraOffset._offset.bottom,
                right: cameraOffset._offset.right,
                bottom: 1 - cameraOffset._offset.top,
            };
        }
        groundReflectionCamera.position.set(camera.position.x, -camera.position.y + 2 * this.parameters.groundLevel, camera.position.z);
        //groundReflectionCamera.lookAt(0, 2 * groundLevel, 0);
        groundReflectionCamera.rotation.set(-camera.rotation.x, camera.rotation.y, -camera.rotation.z);
        //groundReflectionCamera.scale.set(1, -1, 1);
        groundReflectionCamera.updateMatrixWorld();
        groundReflectionCamera.updateProjectionMatrix();
        return groundReflectionCamera;
    }
}
const glslGroundReflectionIntensityVertexShader = `
  varying vec2 vUv;
  void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }`;
const glslGroundReflectionIntensityFragmentShader = `
  uniform sampler2D tDiffuse;
  uniform sampler2D tDepth;
  uniform vec2 resolution;
  uniform float cameraNear;
  uniform float cameraFar;
  uniform mat4 cameraProjectionMatrix;
  uniform mat4 cameraInverseProjectionMatrix;
  uniform mat4 inverseViewMatrix;
  uniform float groundLevel;
  uniform float fadeOutDistance;
  uniform float fadeOutExponent;
  varying vec2 vUv;

  #include <packing>

  float getDepth(const in vec2 screenPosition) {
    return texture2D(tDepth, screenPosition).x;
  }

  float getLinearDepth(const in vec2 screenPosition) {
    #if PERSPECTIVE_CAMERA == 1
        float fragCoordZ = texture2D(tDepth, screenPosition).x;
        float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
        return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
    #else
        return texture2D(tDepth, screenPosition).x;
    #endif
  }

  float getViewZ(const in float depth) {
    #if PERSPECTIVE_CAMERA == 1
        return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    #else
        return 0.0;//orthographicDepthToViewZ(depth, cameraNear, cameraFar);
    #endif
  }

  vec3 getViewPosition(const in vec2 screenPosition, const in float depth, const in float viewZ ) {
    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
    vec4 clipPosition = vec4((vec3(screenPosition, depth) - 0.5) * 2.0, 1.0);
    clipPosition *= clipW;
    return (cameraInverseProjectionMatrix * clipPosition).xyz;
  }

  void main() {
    float verticalBias = 1.5 / resolution.y;
    vec2 uv = vUv.xy + vec2(0.0, verticalBias);
    float depth = getDepth(uv);
    float viewZ = getViewZ(depth);
    vec4 worldPosition = inverseViewMatrix * vec4(getViewPosition(uv, depth, viewZ), 1.0);
    float distance = worldPosition.y - groundLevel;
    vec4 fragColor = texture2D(tDiffuse, uv).rgba;
    #if LINEAR_TO_SRGB == 1
      fragColor.rgb = mix(fragColor.rgb * 12.92, 1.055 * pow(fragColor.rgb, vec3(0.41666)) - 0.055, step(0.0031308, fragColor.rgb));
    #endif
    float fadeOutAlpha = pow(clamp(1.0 - distance / fadeOutDistance, 0.0, 1.0), fadeOutExponent);
    fragColor.a *= fadeOutAlpha;
    gl_FragColor = fragColor * step(depth, 0.9999);
  }`;
class GroundReflectionIntensityMaterial extends ShaderMaterial {
    constructor(parameters) {
        super({
            defines: Object.assign({}, GroundReflectionIntensityMaterial.shader.defines),
            uniforms: UniformsUtils.clone(GroundReflectionIntensityMaterial.shader.uniforms),
            vertexShader: GroundReflectionIntensityMaterial.shader.vertexShader,
            fragmentShader: GroundReflectionIntensityMaterial.shader.fragmentShader,
            blending: NoBlending,
        });
        this.update(parameters);
    }
    update(parameters) {
        var _a, _b;
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.texture) !== undefined) {
            this.uniforms.tDiffuse.value = parameters === null || parameters === void 0 ? void 0 : parameters.texture;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.depthTexture) !== undefined) {
            this.uniforms.tDepth.value = parameters === null || parameters === void 0 ? void 0 : parameters.depthTexture;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.width) || (parameters === null || parameters === void 0 ? void 0 : parameters.height)) {
            const _width = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.width) !== null && _a !== void 0 ? _a : this.uniforms.resolution.value.x;
            const _height = (_b = parameters === null || parameters === void 0 ? void 0 : parameters.height) !== null && _b !== void 0 ? _b : this.uniforms.resolution.value.y;
            this.uniforms.resolution.value.set(_width, _height);
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.camera) !== undefined) {
            const camera = (parameters === null || parameters === void 0 ? void 0 : parameters.camera) ||
                (parameters === null || parameters === void 0 ? void 0 : parameters.camera);
            this.uniforms.cameraNear.value = camera.near;
            this.uniforms.cameraFar.value = camera.far;
            this.uniforms.cameraProjectionMatrix.value.copy(camera.projectionMatrix);
            this.uniforms.cameraInverseProjectionMatrix.value.copy(camera.projectionMatrixInverse);
            this.uniforms.inverseViewMatrix.value.copy(camera.matrixWorld);
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.groundLevel) !== undefined) {
            this.uniforms.groundLevel.value = parameters === null || parameters === void 0 ? void 0 : parameters.groundLevel;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.fadeOutDistance) !== undefined) {
            this.uniforms.fadeOutDistance.value = parameters === null || parameters === void 0 ? void 0 : parameters.fadeOutDistance;
        }
        if ((parameters === null || parameters === void 0 ? void 0 : parameters.fadeOutExponent) !== undefined) {
            this.uniforms.fadeOutExponent.value = parameters === null || parameters === void 0 ? void 0 : parameters.fadeOutExponent;
        }
        return this;
    }
}
GroundReflectionIntensityMaterial.shader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new Vector2() },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1 },
        cameraProjectionMatrix: { value: new Matrix4() },
        cameraInverseProjectionMatrix: { value: new Matrix4() },
        inverseViewMatrix: { value: new Matrix4() },
        groundLevel: { value: 0 },
        fadeOutDistance: { value: 1 },
        fadeOutExponent: { value: 1 },
    },
    defines: {
        PERSPECTIVE_CAMERA: 1,
        LINEAR_TO_SRGB: 1,
    },
    vertexShader: glslGroundReflectionIntensityVertexShader,
    fragmentShader: glslGroundReflectionIntensityFragmentShader,
};

/**
 *  This helper must be added as a child of the light
 */

class RectAreaLightHelper extends Line {

	constructor( light, color ) {

		const positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		const material = new LineBasicMaterial( { fog: false } );

		super( geometry, material );

		this.light = light;
		this.color = color; // optional hardwired color for the helper
		this.type = 'RectAreaLightHelper';

		//

		const positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );

	}

	updateMatrixWorld() {

		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );
			this.children[ 0 ].material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			// prevent hue shift
			const c = this.material.color;
			const max = Math.max( c.r, c.g, c.b );
			if ( max > 1 ) c.multiplyScalar( 1 / max );

			this.children[ 0 ].material.color.copy( this.material.color );

		}

		// ignore world scale on light
		this.matrixWorld.extractRotation( this.light.matrixWorld ).scale( this.scale ).copyPosition( this.light.matrixWorld );

		this.children[ 0 ].matrixWorld.copy( this.matrixWorld );

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

}

class IlluminationBufferMaterial extends MeshLambertMaterial {
    constructor(parameters) {
        super(parameters);
        this.customProgramCacheKey = this._customProgramCacheKey;
        this.onBeforeCompile = this._onBeforeCompile;
    }
    static setShadowParameters(enableGroundBoundary, directionalDependency, directionalExponent, groundBoundary, groundMapScale, distance, blur) {
        this._enableGroundBoundary = enableGroundBoundary;
        IlluminationBufferMaterial._distributionProperties.set(directionalDependency, directionalExponent, groundBoundary, groundMapScale);
        IlluminationBufferMaterial._shadowFadeOut.set(distance, blur);
    }
    static setBoundingBox(box) {
        IlluminationBufferMaterial._sceneBoxMin.copy(box.min);
        IlluminationBufferMaterial._sceneBoxMax.copy(box.max);
    }
    _customProgramCacheKey() {
        return IlluminationBufferMaterial._enableGroundBoundary
            ? 'GROUND_BOUNDARY'
            : 'NO_GROUND_BOUNDARY';
    }
    _onBeforeCompile(materialShader, _renderer) {
        materialShader.vertexShader = screenSpaceShadowMaterialVertexShader;
        materialShader.fragmentShader = screenSpaceShadowMaterialFragmentShader;
        materialShader.defines = Object.assign({
            ...materialShader.defines,
            DYNAMIC_SHADOW_RADIUS: '',
            GROUND_BOUNDARY: IlluminationBufferMaterial._enableGroundBoundary ? 1 : 0,
        });
        const uniforms = materialShader.uniforms;
        if (uniforms) {
            uniforms.distributionProperties = {
                value: IlluminationBufferMaterial._distributionProperties,
            };
            uniforms.shadowFadeOut = {
                value: IlluminationBufferMaterial._shadowFadeOut,
            };
            uniforms.sceneBoxMin = { value: IlluminationBufferMaterial._sceneBoxMin };
            uniforms.sceneBoxMax = { value: IlluminationBufferMaterial._sceneBoxMax };
        }
    }
}
IlluminationBufferMaterial._enableGroundBoundary = false;
IlluminationBufferMaterial._shadowFadeOut = new Vector2(0.1, 20);
IlluminationBufferMaterial._sceneBoxMin = new Vector3(-1, -1, -1);
IlluminationBufferMaterial._sceneBoxMax = new Vector3(1, 1, 1);
IlluminationBufferMaterial._distributionProperties = new Vector4(1, 1, 1, 1);
const screenSpaceShadowMaterialVertexShader = `
#define LAMBERT

varying vec3 vViewPosition;
varying vec3 vWorldPosition;

#include <common>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {
  #include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>

#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
  vWorldPosition = worldPosition.xyz;
#else
  vWorldPosition = (modelMatrix * vec4(transformed, 1.)).xyz;
#endif
}
`;
const screenSpaceShadowMaterialFragmentShader = `
#define LAMBERT

uniform vec3 diffuse;
uniform float opacity;

varying vec3 vViewPosition;
varying vec3 vWorldPosition;

#ifdef DYNAMIC_SHADOW_RADIUS
  uniform vec2 shadowFadeOut;
  #define fadeOutDistance shadowFadeOut.x
  #define fadeOutBlur shadowFadeOut.y
  uniform vec3 sceneBoxMin;
  uniform vec3 sceneBoxMax;
#endif
uniform vec4 distributionProperties;
#define directionalDependency distributionProperties.x
#define directionalExponent distributionProperties.y
#define groundBoundary distributionProperties.z
#define groundMapScale distributionProperties.w

#include <common>
#include <packing>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

vec2 getShadowDynamicScale() {
  vec2 dynamicScale = vec2(0.0, 1.0);
#ifdef DYNAMIC_SHADOW_RADIUS
  if (fadeOutDistance > 0.0) {
    vec3 boxDistanceVec = max(vec3(0.0), max(sceneBoxMin - vWorldPosition, vWorldPosition - sceneBoxMax));
    float boxDistance = length(boxDistanceVec);
    float shadowBase = clamp(boxDistance / fadeOutDistance, 0.0, 1.0);
    dynamicScale = vec2(shadowBase, 1.0 - shadowBase);
  }
#endif
  return dynamicScale;
}

float getShadowDynamicRadius(sampler2D shadowMap, float shadowBias, float shadowRadius, vec4 shadowCoord, vec2 shadowScale) {
  float dynamicRadius = shadowRadius;
#ifdef DYNAMIC_SHADOW_RADIUS
  shadowCoord.xyz /= shadowCoord.w;
  shadowCoord.z += shadowBias;
  bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
  bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
  if (frustumTest && fadeOutDistance > 0.0) {
    dynamicRadius = shadowRadius + fadeOutBlur * max(0.0, shadowScale.x);
  }
#endif
  return dynamicRadius;
}

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	
	#include <logdepthbuf_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	// accumulation

	vec3 geometryPosition = - vViewPosition;
  vec3 geometryNormal = normal;
  vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

  vec3 accumulatedShadowLight = vec3(0.0);
  vec3 directionDependentShadowLight = vec3(1.0);
  float groundDistance = clamp((vWorldPosition.y - sceneBoxMin.y) * 100.0, 0.0, 1.0);
  vec2 dynamicScale = getShadowDynamicScale();

  #if ( NUM_DIR_LIGHTS > 0 )
    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
      DirectionalLightShadow directionalLightShadow;
    #endif

    IncidentLight directLight;
    vec3 incidentLightSum = vec3(0.0);
    vec3 incidentShadowLight = vec3(0.0);
    float groundShadowFactor = 1.;
    float shadowFactor;
    float dynamicRadius;
    float dotNL;

  #pragma unroll_loop_start
    for ( int i = 0 ; i < NUM_DIR_LIGHTS; i ++ ) {
      directionalLight = directionalLights[ i ];
      getDirectionalLightInfo( directionalLight, directLight );

      #if defined( USE_SHADOWMAP ) && ( GROUND_BOUNDARY == 1 && UNROLLED_LOOP_INDEX == 0 )

        directionalLightShadow = directionalLightShadows[ i ];
        dynamicRadius = fadeOutDistance * groundMapScale;
        groundShadowFactor = groundDistance < 0.5 ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, dynamicRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

      #elif defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

        directionalLightShadow = directionalLightShadows[ i ];
        dynamicRadius = getShadowDynamicRadius(directionalShadowMap[i], directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[i], dynamicScale);
        shadowFactor = ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, dynamicRadius, vDirectionalShadowCoord[ i ] ) : 1.0;  
        accumulatedShadowLight += directLight.color * shadowFactor * saturate(min(dotNL * 10.0 + 0.9, 1.0));
        dotNL = dot(dot(geometryNormal, geometryPosition) >= 0.0 ? -geometryNormal : geometryNormal, directLight.direction);
        incidentLightSum += directLight.color;
        incidentShadowLight += directLight.color * mix(1.0, shadowFactor, pow(clamp(dotNL, 0.0, 1.0), directionalExponent));
    
      #endif
    }
  #pragma unroll_loop_end

    directionDependentShadowLight = incidentShadowLight / ( incidentLightSum + 1. - step(0., incidentLightSum) );
  #else
    accumulatedShadowLight = vec3(1.0);
  #endif  

	// modulation

	vec3 outgoingLight = mix(accumulatedShadowLight, directionDependentShadowLight, max(directionalDependency, 1.0 - groundDistance));
  #if GROUND_BOUNDARY == 1
    float groundWeight = 1. - groundShadowFactor + groundDistance - (1. - groundShadowFactor) * groundDistance;
    outgoingLight = mix(vec3(1.), outgoingLight, mix(dynamicScale.y, groundWeight, groundBoundary));
  #else
    outgoingLight = mix(vec3(1.), outgoingLight, dynamicScale.y);
  #endif

	#include <opaque_fragment>
	#include <premultiplied_alpha_fragment>
}
`;

const SHADOW_LIGHT_SOURCE_TYPES = {
    DIRECTION_LIGHT_SHADOW: 'DirectionalLightShadow',
    SPOT_LIGHT_SHADOW: 'SpotLightShadow',
};
const defaultScreenSpaceShadowMapParameters = {
    alwaysUpdate: false,
    enableShadowMap: true,
    enableGroundBoundary: true,
    layers: null,
    shadowLightSourceType: SHADOW_LIGHT_SOURCE_TYPES.DIRECTION_LIGHT_SHADOW,
    maximumNumberOfLightSources: -1,
    directionalDependency: 1.0,
    directionalExponent: 1.0,
    groundBoundary: 1.0,
    fadeOutDistance: 0.1,
    fadeOutBlur: 5.0,
};
class ScreenSpaceShadowMapPass extends RenderPass {
    get shadowTexture() {
        return this._shadowRenderTarget.texture;
    }
    set shadowOnGround(value) {
        this._shadowMapPassOverrideMaterialCache.shadowOnGround = value;
    }
    constructor(renderPassManager, viewportSize, parameters) {
        var _a, _b, _c;
        super(renderPassManager);
        this.needsUpdate = false;
        this.drawGround = true;
        this.shadowTypeNeedsUpdate = true;
        this.shadowConfiguration = new ShadowTypeConfiguration();
        this._shadowLightSources = [];
        this._shadowScale = 1;
        this._groundMapScale = 1;
        this._cameraUpdate = new CameraUpdate();
        this._viewportSize = new Vector2(viewportSize.x, viewportSize.y);
        this._samples = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.samples) !== null && _a !== void 0 ? _a : 0;
        this._shadowMapSize = (_b = parameters === null || parameters === void 0 ? void 0 : parameters.shadowMapSize) !== null && _b !== void 0 ? _b : 1024;
        this.parameters = this._getScreenSpaceShadowMapParameters(parameters);
        this.castShadow = this.parameters.enableShadowMap;
        this._shadowMapPassOverrideMaterialCache =
            new ShadowMapPassOverrideMaterialCache();
        (_c = this.renderCacheManager) === null || _c === void 0 ? void 0 : _c.registerCache(this, this._shadowMapPassOverrideMaterialCache);
        const samples = this._samples;
        this._shadowRenderTarget = new WebGLRenderTarget(this._viewportSize.x, this._viewportSize.y, { samples, format: RedFormat });
    }
    _getScreenSpaceShadowMapParameters(parameters) {
        return {
            ...defaultScreenSpaceShadowMapParameters,
            ...parameters,
        };
    }
    dispose() {
        super.dispose();
        this._shadowLightSources.forEach((item) => item.dispose());
        this._shadowRenderTarget.dispose();
        this._shadowMapPassOverrideMaterialCache.dispose();
    }
    updateParameters(parameters) {
        for (let propertyName in parameters) {
            if (this.parameters.hasOwnProperty(propertyName)) {
                this.parameters[propertyName] = parameters[propertyName];
            }
        }
    }
    updateBounds(sceneBounds, scaleShadow) {
        var _a;
        const currentScale = this._shadowScale;
        this._shadowScale = scaleShadow;
        if (Math.abs(currentScale - this._shadowScale) > 0.00001) {
            this.shadowTypeNeedsUpdate = true;
        }
        this._shadowLightSources.forEach((item) => item.updateBounds(sceneBounds));
        if (this._shadowLightSources.length > 0) {
            const shadowCamera = (_a = this._shadowLightSources[0].getShadowLight().shadow) === null || _a === void 0 ? void 0 : _a.camera;
            if (shadowCamera instanceof OrthographicCamera) {
                this._groundMapScale =
                    (2 * this._shadowMapSize) /
                        (Math.abs(shadowCamera.right - shadowCamera.left) +
                            Math.abs(shadowCamera.top - shadowCamera.bottom));
            }
        }
        else {
            this._groundMapScale = 1;
        }
        this._shadowMapPassOverrideMaterialCache.setBoundingBox(sceneBounds.bounds);
    }
    forceShadowUpdate() {
        this._shadowLightSources.forEach((item) => item.forceShadowUpdate());
        this.needsUpdate = true;
    }
    getShadowLightSources() {
        const lightSources = this._shadowLightSources.map((item) => item.getShadowLight());
        return lightSources;
    }
    findShadowLightSource(lightSource) {
        var _a;
        return (_a = this._shadowLightSources
            .find((item) => item.getOriginalLight() === lightSource)) === null || _a === void 0 ? void 0 : _a.getShadowLight();
    }
    addRectAreaLight(rectAreaLight, parent) {
        const rectAreaLightShadow = new RectAreaShadowLightSource(rectAreaLight, {
            shadowMapSize: this._shadowMapSize,
            shadowLightSourceType: this.parameters.shadowLightSourceType,
        });
        this._shadowLightSources.push(rectAreaLightShadow);
        rectAreaLightShadow.addTo(parent);
        rectAreaLightShadow.updatePositionAndTarget();
        this.needsUpdate = true;
    }
    updateRectAreaLights(rectAreaLights, parent) {
        const shadowLightSources = this._shadowLightSources;
        this._shadowLightSources = this._createShadowLightSourceArray(false);
        for (const lightSource of shadowLightSources) {
            if (lightSource instanceof RectAreaShadowLightSource) {
                const light = lightSource.getRectAreaLight();
                if (rectAreaLights.includes(light)) {
                    lightSource.updatePositionAndTarget();
                    this._shadowLightSources.push(lightSource);
                }
            }
            lightSource.removeFrom(parent);
            lightSource.dispose();
        }
        rectAreaLights.forEach((light) => {
            if (!this._shadowLightSources.find((item) => item instanceof RectAreaShadowLightSource &&
                item.getRectAreaLight() === light)) {
                this.addRectAreaLight(light, parent);
            }
        });
        this.needsUpdate = true;
        this.shadowTypeNeedsUpdate = true;
    }
    createShadowFromLightSources(parent, lightSources) {
        for (const lightSource of this._shadowLightSources) {
            lightSource.removeFrom(parent);
            lightSource.dispose();
        }
        this._shadowLightSources = this._createShadowLightSourceArray(true);
        const maxIntensity = lightSources.length > 0
            ? Math.max(...lightSources.map((lightSource) => lightSource.maxIntensity))
            : 1;
        const lightIntensityScale = 1 / maxIntensity;
        this._addShadowFromLightSources(lightSources, lightIntensityScale);
        this._shadowLightSources.forEach((item) => {
            item.addTo(parent);
            item.updatePositionAndTarget();
        });
        this.needsUpdate = true;
        this.shadowTypeNeedsUpdate = true;
    }
    _addShadowFromLightSources(lightSources, lightIntensityScale) {
        const lightIntensityThreshold = 0.1;
        const lightDistanceScale = 7;
        lightSources.forEach((lightSource) => {
            const lightIntensity = lightSource.maxIntensity * lightIntensityScale;
            if (lightIntensity >= lightIntensityThreshold &&
                lightSource.position.z >= 0) {
                const lightPosition = new Vector3(lightSource.position.x, lightSource.position.z, lightSource.position.y).multiplyScalar(lightDistanceScale);
                const environmentLightShadow = new EnvironmentShadowLightSource(lightPosition, lightIntensity, {
                    shadowMapSize: this._shadowMapSize,
                    shadowLightSourceType: this.parameters.shadowLightSourceType,
                });
                this._shadowLightSources.push(environmentLightShadow);
            }
        });
    }
    _createShadowLightSourceArray(groundBoundary) {
        const shadowLightSources = [];
        if (groundBoundary) {
            const groundShadowLight = new GroundShadowLightSource(new Vector3(0, 7, 0), {
                shadowMapSize: this._shadowMapSize,
            });
            shadowLightSources.push(groundShadowLight);
        }
        this.parameters.enableGroundBoundary = groundBoundary;
        return shadowLightSources;
    }
    setSize(width, height) {
        this._viewportSize = new Vector2(width, height);
        this._shadowRenderTarget.setSize(this._viewportSize.x, this._viewportSize.y);
    }
    updatePositionAndTarget() {
        this._shadowLightSources.forEach((item) => item.updatePositionAndTarget());
    }
    renderPass(renderer) {
        const needsUpdate = this.needsUpdate ||
            this.parameters.alwaysUpdate ||
            this._cameraUpdate.changed(this.camera);
        if (!needsUpdate) {
            return;
        }
        this.needsUpdate = false;
        if (this.shadowTypeNeedsUpdate) {
            this.shadowTypeNeedsUpdate = false;
            this.needsUpdate = true;
            this._updateShadowType(renderer);
        }
        const sceneBackground = this.scene.background;
        const sceneEnvironment = this.scene.environment;
        const layersMaskBackup = this.camera.layers.mask;
        this.scene.environment = null;
        this.scene.background = null;
        if (this.parameters.layers) {
            this.camera.layers.mask = this.parameters.layers.mask;
        }
        this.renderPassManager.setGroundVisibility(this.drawGround);
        this._renderSimpleShadowMapFromShadowLightSources(renderer, this.scene, this.camera);
        this.renderPassManager.setGroundVisibility(false);
        this.camera.layers.mask = layersMaskBackup;
        this.scene.environment = sceneEnvironment;
        this.scene.background = sceneBackground;
    }
    _renderSimpleShadowMapFromShadowLightSources(renderer, scene, camera) {
        var _a;
        this._shadowMapPassOverrideMaterialCache.setShadowParameters(this.parameters.enableGroundBoundary, this.parameters.directionalDependency, this.parameters.directionalExponent, this.parameters.groundBoundary, this._groundMapScale, this.parameters.fadeOutDistance * this._shadowScale, this.parameters.fadeOutBlur);
        const activeShadowLights = this._getSortedShadowLightSources();
        if (activeShadowLights.length === 0) {
            this.passRenderer.clear(renderer, this._shadowRenderTarget, 0xffffff, 1);
        }
        else {
            this._setShadowLightSourcesIntensity(activeShadowLights);
            (_a = this.renderCacheManager) === null || _a === void 0 ? void 0 : _a.render(this, scene, () => {
                this.passRenderer.render(renderer, scene, camera, this._shadowRenderTarget, 0xffffff, 1);
            });
            this._shadowLightSources.forEach((item) => item.finishRenderShadow());
        }
    }
    _getSortedShadowLightSources() {
        let activeShadowLights = [];
        this._shadowLightSources.forEach((item) => activeShadowLights.push(...item.prepareRenderShadow()));
        activeShadowLights.sort((a, b) => {
            if ((a.light.castShadow && !b.light.castShadow) ||
                (a.groundShadow && !b.groundShadow)) {
                return -1;
            }
            if ((!a.light.castShadow && b.light.castShadow) ||
                (!a.groundShadow && b.groundShadow)) {
                return 1;
            }
            return b.intensity - a.intensity;
        });
        return activeShadowLights;
    }
    _setShadowLightSourcesIntensity(activeShadowLights) {
        let sumOfShadowLightIntensity = 0;
        let maximumNumberOfLightSources = this.parameters.maximumNumberOfLightSources;
        let noOfLights = 0;
        activeShadowLights.forEach((shadowLight) => {
            if (maximumNumberOfLightSources < 0 ||
                noOfLights < maximumNumberOfLightSources) {
                sumOfShadowLightIntensity += shadowLight.groundShadow
                    ? 0
                    : shadowLight.intensity;
                if (!shadowLight.groundShadow) {
                    noOfLights++;
                }
            }
        });
        noOfLights = 0;
        activeShadowLights.forEach((shadowLight) => {
            var _a;
            if ((this.parameters.enableGroundBoundary || !shadowLight.groundShadow) &&
                (maximumNumberOfLightSources < 0 ||
                    noOfLights < maximumNumberOfLightSources)) {
                shadowLight.light.visible = true;
                shadowLight.light.intensity = shadowLight.groundShadow
                    ? shadowLight.intensity
                    : shadowLight.intensity / sumOfShadowLightIntensity;
                (_a = shadowLight.light).castShadow && (_a.castShadow = this.castShadow);
            }
            else {
                shadowLight.light.visible = false;
                shadowLight.light.intensity = 0;
                shadowLight.light.castShadow = false;
            }
            if (!shadowLight.groundShadow) {
                noOfLights++;
            }
        });
    }
    _updateShadowType(renderer) {
        renderer.shadowMap.type =
            this.shadowConfiguration.currentConfiguration.type;
        const castShadow = this.parameters.enableShadowMap &&
            this.shadowConfiguration.currentConfiguration.castShadow;
        renderer.shadowMap.enabled = castShadow;
        renderer.shadowMap.needsUpdate = true;
        this.castShadow =
            castShadow && this.shadowConfiguration.currentConfiguration.castShadow;
        this._shadowLightSources.forEach((item) => item._updateShadowType(this.shadowConfiguration.currentConfiguration, this._shadowScale));
    }
    switchType(type) {
        if (!this.shadowConfiguration.switchType(type)) {
            return false;
        }
        this.needsUpdate = true;
        this.shadowTypeNeedsUpdate = true;
        return true;
    }
}
const SHADOW_MATERIAL_TYPE = {
    DEFAULT: 'default',
    UNLIT: 'unlit',
    EMISSIVE: 'emissive',
    SHADOW: 'shadow',
};
class ShadowMapPassOverrideMaterialCache extends ObjectRenderCache {
    set shadowOnGround(value) {
        this._shadowOnGround = value;
    }
    constructor() {
        super();
        this._boundingBoxSet = false;
        this._shadowOnGround = true;
        this._shadowObjectMaterial = this._createShadowMaterial(SHADOW_MATERIAL_TYPE.DEFAULT);
        this._unlitMaterial = this._createShadowMaterial(SHADOW_MATERIAL_TYPE.UNLIT);
        this._emissiveMaterial = this._createShadowMaterial(SHADOW_MATERIAL_TYPE.EMISSIVE);
        this._receiveShadowMaterial = this._createShadowMaterial(SHADOW_MATERIAL_TYPE.SHADOW);
    }
    dispose() {
        this._shadowObjectMaterial.dispose();
        this._unlitMaterial.dispose();
        this._emissiveMaterial.dispose();
        this._receiveShadowMaterial.dispose();
    }
    setShadowParameters(enableGroundBoundary, directionalDependency, directionalExponent, groundBoundary, groundMapScale, distance, blur) {
        IlluminationBufferMaterial.setShadowParameters(enableGroundBoundary, directionalDependency, directionalExponent, groundBoundary, groundMapScale, distance, blur);
    }
    setBoundingBox(box) {
        this._boundingBoxSet = true;
        IlluminationBufferMaterial.setBoundingBox(box);
    }
    _createShadowMaterial(type) {
        let material;
        if (type === SHADOW_MATERIAL_TYPE.EMISSIVE) {
            material = new MeshBasicMaterial({
                color: 0xffffff,
                side: DoubleSide,
            });
        }
        else if (type === SHADOW_MATERIAL_TYPE.UNLIT) {
            material = new MeshBasicMaterial({
                color: 0xffffff,
                side: DoubleSide,
            });
        }
        else if (type === SHADOW_MATERIAL_TYPE.SHADOW) {
            material = new ShadowMaterial({
                side: DoubleSide,
            });
        }
        else if (ShadowMapPassOverrideMaterialCache.useModifiedMaterial) {
            material = this._createCustomerShadowMaterial();
        }
        else {
            material = new MeshPhongMaterial({
                color: 0xffffff,
                shininess: 0,
                polygonOffsetFactor: 0,
                polygonOffsetUnits: 0,
                side: DoubleSide,
            });
        }
        return material;
    }
    _createCustomerShadowMaterial() {
        const material = new IlluminationBufferMaterial({
            side: DoubleSide,
        });
        return material;
    }
    addLineOrPoint(object3d) {
        this.addToCache(object3d, { visible: false });
    }
    addMesh(mesh) {
        if (mesh.visible) {
            this._setMeshMaterialAndVisibility(mesh);
        }
    }
    addObject(object3d) {
        if (object3d.isLight && !object3d.userData.shadowLightSource) {
            this.addToCache(object3d, { visible: false });
        }
    }
    _setMeshMaterialAndVisibility(object) {
        if (object.userData.isFloor) {
            this._setMeshShadowFloorMaterial(object);
        }
        else if (object.material &&
            object.receiveShadow &&
            !Array.isArray(object.material) &&
            !(object.material.transparent === true && object.material.opacity < 0.9)) {
            this._setShadowMaterialForOpaqueObject(object);
        }
        else if (object.material &&
            object.material.transparent &&
            object.material.opacity < 0.9) {
            this.addToCache(object, { visible: false });
        }
        else if (object.receiveShadow) {
            this.addToCache(object, {
                castShadow: false,
                material: this._receiveShadowMaterial,
            });
        }
        else {
            this.addToCache(object, { visible: false });
        }
    }
    _setShadowMaterialForOpaqueObject(object) {
        const material = object.material;
        if (material instanceof LineBasicMaterial ||
            material instanceof MeshBasicMaterial) {
            this.addToCache(object, { material: this._unlitMaterial });
        }
        else if (material instanceof MeshStandardMaterial) {
            this._setMeshShadowStandardMaterial(object, material);
        }
        else {
            this.addToCache(object, {
                material: object.receiveShadow
                    ? this._shadowObjectMaterial
                    : this._unlitMaterial,
            });
        }
    }
    _setMeshShadowStandardMaterial(object, material) {
        const isEmissive = material.emissiveIntensity > 0 &&
            (material.emissive.r > 0 ||
                material.emissive.g > 0 ||
                material.emissive.b > 0);
        this.addToCache(object, {
            castShadow: isEmissive ? false : object.castShadow,
            material: isEmissive
                ? this._emissiveMaterial
                : object.receiveShadow
                    ? this._shadowObjectMaterial
                    : this._unlitMaterial,
        });
    }
    _setMeshShadowFloorMaterial(object) {
        if (this._boundingBoxSet && this._shadowOnGround) {
            this.addToCache(object, {
                visible: true,
                castShadow: false,
                receiveShadow: true,
                material: this._shadowObjectMaterial,
            });
        }
        else {
            this.addToCache(object, { visible: false });
        }
    }
}
ShadowMapPassOverrideMaterialCache.useModifiedMaterial = true;
class ShadowTypeConfiguration {
    constructor() {
        var _a;
        this.types = new Map([
            ['off', ShadowTypeConfiguration._noShadow],
            ['BasicShadowMap', ShadowTypeConfiguration._basicShadow],
            ['PCFShadowMap', ShadowTypeConfiguration._pcfShadow],
            ['PCFSoftShadowMap', ShadowTypeConfiguration._pcfSoftShadow],
            ['VSMShadowMap', ShadowTypeConfiguration._vcmShadow],
        ]);
        this.shadowType = 'PCFShadowMap'; // 'VSMShadowMap'
        this.currentConfiguration = (_a = this.types.get(this.shadowType)) !== null && _a !== void 0 ? _a : ShadowTypeConfiguration._defaultType;
    }
    switchType(type) {
        var _a;
        if (!this.types.has(type)) {
            return false;
        }
        this.currentConfiguration =
            (_a = this.types.get(type)) !== null && _a !== void 0 ? _a : ShadowTypeConfiguration._defaultType;
        return true;
    }
}
// see LightShadow - https://threejs.org/docs/#api/en/lights/shadows/LightShadow
// bias: Shadow map bias, how much to add or subtract from the normalized depth when deciding whether a surface is in shadow.
//       This value depends on the normalized depth and must not be scaled with the size of the scene.
// normalBias: Defines how much the _position used to query the shadow map is offset along the object normal.
//       This value is in world space units and must be scaled with the size of the scene.
ShadowTypeConfiguration._noShadow = {
    castShadow: false,
    type: PCFShadowMap,
    bias: 0,
    normalBias: 0,
    radius: 0,
};
ShadowTypeConfiguration._basicShadow = {
    castShadow: true,
    type: BasicShadowMap,
    bias: -0.00005,
    normalBias: 0.005,
    radius: 0,
};
ShadowTypeConfiguration._pcfShadow = {
    castShadow: true,
    type: PCFShadowMap,
    bias: -0.00005,
    normalBias: 0.01,
    radius: 4,
};
ShadowTypeConfiguration._pcfSoftShadow = {
    castShadow: true,
    type: PCFSoftShadowMap,
    bias: -0.00005,
    normalBias: 0.01,
    radius: 1,
};
ShadowTypeConfiguration._vcmShadow = {
    castShadow: true,
    type: VSMShadowMap,
    bias: 0.0001,
    normalBias: 0,
    radius: 15,
};
ShadowTypeConfiguration._defaultType = ShadowTypeConfiguration._pcfShadow;
class BaseShadowLightSource {
    constructor(lightSource, parameters) {
        var _a, _b;
        this._isVisibleBackup = true;
        this._castShadowBackup = true;
        this._shadowMapSize = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.shadowMapSize) !== null && _a !== void 0 ? _a : 1024;
        this._blurSamples = (_b = parameters === null || parameters === void 0 ? void 0 : parameters.blurSamples) !== null && _b !== void 0 ? _b : 8;
        this._shadowLightSource = lightSource;
        this._shadowLightSource.visible = false;
        this._shadowLightSource.castShadow = true;
        if (this._shadowLightSource.shadow) {
            this._shadowLightSource.shadow.mapSize = new Vector2(this._shadowMapSize, this._shadowMapSize);
            this._shadowLightSource.shadow.blurSamples = this._blurSamples;
            this._shadowLightSource.shadow.autoUpdate = false;
        }
        this._shadowLightSource.userData.shadowLightSource = this;
    }
    getPosition() {
        return this._shadowLightSource.position;
    }
    getShadowLight() {
        return this._shadowLightSource;
    }
    getOriginalLight() {
        return null;
    }
    dispose() {
        this._shadowLightSource.dispose();
    }
    addTo(parent) {
        parent.add(this._shadowLightSource);
    }
    removeFrom(parent) {
        parent.remove(this._shadowLightSource);
    }
    updatePositionAndTarget() {
        this._updateShadowPositionAndTarget(this.getPosition(), new Vector3(0, 0, 0));
    }
    updateBounds(sceneBounds) {
        if (this._shadowLightSource instanceof SpotLight) {
            const camera = this._shadowLightSource.shadow.camera;
            const cameraViewBounds = sceneBounds.bounds
                .clone()
                .applyMatrix4(camera.matrixWorldInverse);
            const near = Math.max(0.001, Math.min(-cameraViewBounds.min.z, -cameraViewBounds.max.z));
            const far = Math.max(-cameraViewBounds.min.z, -cameraViewBounds.max.z);
            const halfWidth = Math.max(Math.abs(cameraViewBounds.min.x), Math.abs(cameraViewBounds.max.x));
            const halfHeight = Math.max(Math.abs(cameraViewBounds.min.y), Math.abs(cameraViewBounds.max.y));
            const angle = Math.atan2(Math.hypot(halfHeight, halfWidth) * 1.05, near);
            camera.aspect = 1;
            camera.near = near;
            camera.far = far;
            this._shadowLightSource.angle = angle;
        }
        else if (this._shadowLightSource.shadow) {
            const camera = this._shadowLightSource.shadow.camera;
            sceneBounds.updateCameraViewVolumeFromBounds(camera);
            const c = camera;
            c.far += c.far - c.near;
            c.updateProjectionMatrix();
        }
        if (this._shadowLightSource.shadow) {
            this._shadowLightSource.shadow.needsUpdate = true;
        }
    }
    forceShadowUpdate() {
        if (this._shadowLightSource.shadow) {
            this._shadowLightSource.shadow.needsUpdate = true;
        }
    }
    _updateShadowPositionAndTarget(cameraPosition, targetPosition) {
        var _a, _b, _c;
        if (this._shadowLightSource instanceof SpotLight) {
            const lightDirection = targetPosition.clone().sub(cameraPosition);
            const distance = lightDirection.length();
            lightDirection.normalize();
            const shadowCameraPosition = targetPosition
                .clone()
                .sub(lightDirection.clone().multiplyScalar(distance * 4));
            this._shadowLightSource.shadow.camera.position.copy(shadowCameraPosition);
            this._shadowLightSource.shadow.camera.position.copy(shadowCameraPosition);
            this._shadowLightSource.shadow.camera.lookAt(targetPosition);
            this._shadowLightSource.position.copy(shadowCameraPosition);
            this._shadowLightSource.lookAt(targetPosition);
        }
        else {
            this._shadowLightSource.position.copy(cameraPosition);
            this._shadowLightSource.lookAt(targetPosition);
            (_a = this._shadowLightSource.shadow) === null || _a === void 0 ? void 0 : _a.camera.position.copy(cameraPosition);
            (_b = this._shadowLightSource.shadow) === null || _b === void 0 ? void 0 : _b.camera.lookAt(targetPosition);
        }
        (_c = this._shadowLightSource.shadow) === null || _c === void 0 ? void 0 : _c.camera.updateMatrixWorld();
        this._shadowLightSource.updateMatrixWorld();
    }
    _updateShadowType(typeParameters, shadowScale) {
        const shadow = this._shadowLightSource.shadow;
        if (shadow) {
            shadow.bias = typeParameters.bias;
            shadow.normalBias = typeParameters.normalBias * shadowScale;
            shadow.radius = typeParameters.radius;
            shadow.needsUpdate = true;
        }
    }
    prepareRenderShadow() {
        return [];
    }
    finishRenderShadow() {
        return;
    }
}
class RectAreaShadowLightSource extends BaseShadowLightSource {
    constructor(rectAreaLight, parameters) {
        let lightSource;
        switch (parameters === null || parameters === void 0 ? void 0 : parameters.shadowLightSourceType) {
            default:
            case SHADOW_LIGHT_SOURCE_TYPES.DIRECTION_LIGHT_SHADOW:
                lightSource = new DirectionalLight(0xffffff, 1);
                break;
            case SHADOW_LIGHT_SOURCE_TYPES.SPOT_LIGHT_SHADOW:
                lightSource = new SpotLight(0xffffff, 1, 0, Math.PI / 4, 0);
                break;
        }
        lightSource.position.copy(rectAreaLight.position);
        lightSource.lookAt(0, 0, 0);
        super(lightSource, parameters);
        this._rectAreaLight = rectAreaLight;
        this._rectAreaLight.userData.shadowLightSource = this;
        if (parameters === null || parameters === void 0 ? void 0 : parameters.addHelper) {
            this._rectLightHelper = new RectAreaLightHelper(this._rectAreaLight);
            this._rectLightHelper.material.depthWrite = false;
            this._rectAreaLight.add(this._rectLightHelper);
        }
    }
    getPosition() {
        return this._rectAreaLight.position;
    }
    getRectAreaLight() {
        return this._rectAreaLight;
    }
    getOriginalLight() {
        return this._rectAreaLight;
    }
    prepareRenderShadow() {
        this._isVisibleBackup = this._rectAreaLight.visible;
        this._castShadowBackup = this._shadowLightSource.castShadow;
        this._shadowLightSource.visible = this._rectAreaLight.visible;
        this._rectAreaLight.visible = false;
        if (!this._shadowLightSource.visible) {
            return [];
        }
        return [
            {
                light: this._shadowLightSource,
                intensity: this._rectAreaLight.intensity,
                groundShadow: false,
            },
        ];
    }
    finishRenderShadow() {
        this._shadowLightSource.visible = false;
        this._shadowLightSource.castShadow = this._castShadowBackup;
        this._rectAreaLight.visible = this._isVisibleBackup;
    }
}
class EnvironmentShadowLightSource extends BaseShadowLightSource {
    constructor(position, lightIntensity, parameters) {
        const directionalLight = new DirectionalLight(0xffffff, lightIntensity);
        directionalLight.position.copy(position);
        directionalLight.lookAt(0, 0, 0);
        directionalLight.updateMatrix();
        directionalLight.castShadow = true;
        super(directionalLight, parameters);
        this._position = position.clone();
        this._intensity = lightIntensity;
    }
    getPosition() {
        return this._position;
    }
    prepareRenderShadow() {
        this._castShadowBackup = this._shadowLightSource.castShadow;
        this._shadowLightSource.visible = true;
        return [
            {
                light: this._shadowLightSource,
                intensity: this._intensity,
                groundShadow: false,
            },
        ];
    }
    finishRenderShadow() {
        this._shadowLightSource.castShadow = this._castShadowBackup;
        this._shadowLightSource.visible = false;
    }
}
class GroundShadowLightSource extends BaseShadowLightSource {
    constructor(position, parameters) {
        const directionalLight = new DirectionalLight(0xffffff, 1);
        directionalLight.position.copy(position);
        directionalLight.lookAt(0, 0, 0);
        directionalLight.updateMatrix();
        directionalLight.castShadow = true;
        super(directionalLight, parameters);
        this._position = position.clone();
    }
    getPosition() {
        return this._position;
    }
    prepareRenderShadow() {
        this._castShadowBackup = this._shadowLightSource.castShadow;
        this._shadowLightSource.visible = true;
        return [
            {
                light: this._shadowLightSource,
                intensity: 1,
                groundShadow: true,
            },
        ];
    }
    finishRenderShadow() {
        this._shadowLightSource.castShadow = this._castShadowBackup;
        this._shadowLightSource.visible = false;
    }
}

/**
 * Full-screen textured quad shader
 */

const CopyShader = {

	name: 'CopyShader',

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`

};

/**
 * NVIDIA FXAA by Timothy Lottes
 * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 * Further improved by Daniel Sturk
 */

const FXAAShader = {

	name: 'FXAAShader',

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`
		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

		//----------------------------------------------------------------------------------
		// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
		// SDK Version: v3.00
		// Email:       gameworks@nvidia.com
		// Site:        http://developer.nvidia.com/
		//
		// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
		//
		// Redistribution and use in source and binary forms, with or without
		// modification, are permitted provided that the following conditions
		// are met:
		//  * Redistributions of source code must retain the above copyright
		//    notice, this list of conditions and the following disclaimer.
		//  * Redistributions in binary form must reproduce the above copyright
		//    notice, this list of conditions and the following disclaimer in the
		//    documentation and/or other materials provided with the distribution.
		//  * Neither the name of NVIDIA CORPORATION nor the names of its
		//    contributors may be used to endorse or promote products derived
		//    from this software without specific prior written permission.
		//
		// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
		// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
		// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
		// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
		// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
		// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
		// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
		// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		//
		//----------------------------------------------------------------------------------

		#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
		#endif

		/*--------------------------------------------------------------------------*/
		#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
		#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
		/*--------------------------------------------------------------------------*/

		#define NUM_SAMPLES 5

		// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
		float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
		}

		/*============================================================================

									FXAA3 QUALITY - PC

		============================================================================*/

		/*--------------------------------------------------------------------------*/
		vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
		) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
				if(earlyExit) FxaaDiscard;
			#else
				if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
				// locate the edge
				vec2 dirToEdge;
				dirToEdge.x = contrastE > contrastW ? 1. : -1.;
				dirToEdge.y = contrastS > contrastN ? 1. : -1.;
				// . 2 .      . 1 .
				// 1 0 2  ~=  0 0 1
				// . 1 .      . 0 .

				// tap 2 pixels and see which ones are "outside" the edge, to
				// determine if the edge is vertical or horizontal

				vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongH = contrast( rgbaM, rgbaAlongH );
				// . 1 .
				// 0 0 1
				// . 0 H

				vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
				float matchAlongV = contrast( rgbaM, rgbaAlongV );
				// V 1 .
				// 0 0 1
				// . 0 .

				relativeVContrast = matchAlongV - matchAlongH;
				relativeVContrast *= fxaaQualityinvEdgeThreshold;

				if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
					// 1 1 .
					// 0 0 1
					// . 0 1

					// do a simple blur
					return mix(
						rgbaM,
						(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
						.4
					);
				}

				horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
				iterationsUsed = i;

				float increment = float(i + 1);

				if(!doneN) {
					nDist += increment;
					posN = posM + offNP * nDist;
					vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
					doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
					iterationsUsedN = i;
				}

				if(!doneP) {
					pDist += increment;
					posP = posM - offNP * pDist;
					vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
					doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
					iterationsUsedP = i;
				}

				if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
				doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
				doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
				rgbaM,
				rgbaN,
				dist * .5
			);
		}

		void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
				vUv,
				tDiffuse,
				resolution,
				edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
				invEdgeDetectionQuality
			);

		}
	`

};

class OutlinePass extends RenderPass {
    constructor(renderPassManager, resolution, scene, camera, selectedObjects, parameters) {
        var _a;
        super(renderPassManager);
        this.patternTexture = null;
        this.clearBackground = true;
        this.renderScene = scene;
        this.renderCamera = camera;
        this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];
        this.visibleEdgeColor = new Color$1(1, 1, 1);
        this.hiddenEdgeColor = new Color$1(0.1, 0.04, 0.02);
        this.edgeGlow = 0.0;
        this.usePatternTexture = false;
        this.edgeThickness = 1.0;
        this.edgeStrength = 3.0;
        this.downSampleRatio = (parameters === null || parameters === void 0 ? void 0 : parameters.downSampleRatio) || 2;
        this.pulsePeriod = 0;
        this.edgeDetectionFxaa = (parameters === null || parameters === void 0 ? void 0 : parameters.edgeDetectionFxaa) || false;
        this._visibilityCache = new Map();
        this.resolution =
            resolution !== undefined
                ? new Vector2(resolution.x, resolution.y)
                : new Vector2(256, 256);
        const resx = Math.round(this.resolution.x / this.downSampleRatio);
        const resy = Math.round(this.resolution.y / this.downSampleRatio);
        this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
        this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';
        this.renderTargetMaskBuffer.texture.generateMipmaps = false;
        this.prepareMaskMaterial = this._getPrepareMaskMaterial((_a = this.gBufferTextures) === null || _a === void 0 ? void 0 : _a.isFloatGBufferWithRgbNormalAlphaDepth);
        this.prepareMaskMaterial.side = DoubleSide;
        this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);
        if (this.edgeDetectionFxaa) {
            this.fxaaRenderMaterial = new ShaderMaterial(FXAAShader);
            this.fxaaRenderMaterial.uniforms.tDiffuse.value =
                this.renderTargetMaskBuffer.texture;
            this.fxaaRenderMaterial.uniforms.resolution.value.set(1 / this.resolution.x, 1 / this.resolution.y);
            this.renderTargetFxaaBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);
            this.renderTargetFxaaBuffer.texture.name = 'OutlinePass.fxaa';
            this.renderTargetFxaaBuffer.texture.generateMipmaps = false;
        }
        this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);
        this.renderTargetMaskDownSampleBuffer.texture.name =
            'OutlinePass.depthDownSample';
        this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;
        this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);
        this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';
        this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
        this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
        this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';
        this.renderTargetBlurBuffer2.texture.generateMipmaps = false;
        this.edgeDetectionMaterial = this._getEdgeDetectionMaterial();
        this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);
        this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';
        this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
        this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));
        this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';
        this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
        const MAX_EDGE_THICKNESS = 4;
        const MAX_EDGE_GLOW = 4;
        this.separableBlurMaterial1 =
            this._getSeperableBlurMaterial(MAX_EDGE_THICKNESS);
        this.separableBlurMaterial1.uniforms.texSize.value.set(resx, resy);
        this.separableBlurMaterial1.uniforms.kernelRadius.value = 1;
        this.separableBlurMaterial2 = this._getSeperableBlurMaterial(MAX_EDGE_GLOW);
        this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(resx / 2), Math.round(resy / 2));
        this.separableBlurMaterial2.uniforms.kernelRadius.value = MAX_EDGE_GLOW;
        // Overlay material
        this.overlayMaterial = this._getOverlayMaterial();
        // copy material
        const copyShader = CopyShader;
        this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
        this.copyUniforms.opacity.value = 1.0;
        this.materialCopy = new ShaderMaterial({
            uniforms: this.copyUniforms,
            vertexShader: copyShader.vertexShader,
            fragmentShader: copyShader.fragmentShader,
            blending: NoBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true,
        });
        this.enabled = true;
        this.needsSwap = false;
        this.oldClearColor = new Color$1();
        this.oldClearAlpha = 1;
        this.fsQuad = new FullScreenQuad(undefined);
        this.tempPulseColor1 = new Color$1();
        this.tempPulseColor2 = new Color$1();
        this.textureMatrix = new Matrix4();
        function replaceDepthToViewZ(string, actualCamera) {
            // @ts-ignore -- wrong typing isPerspectiveCamera is there
            const type = actualCamera.isPerspectiveCamera
                ? 'perspective'
                : 'orthographic';
            return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');
        }
    }
    dispose() {
        var _a, _b;
        super.dispose();
        this.renderTargetMaskBuffer.dispose();
        (_a = this.renderTargetFxaaBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
        this.renderTargetMaskDownSampleBuffer.dispose();
        this.renderTargetBlurBuffer1.dispose();
        this.renderTargetBlurBuffer2.dispose();
        this.renderTargetEdgeBuffer1.dispose();
        this.renderTargetEdgeBuffer2.dispose();
        this.prepareMaskMaterial.dispose();
        (_b = this.fxaaRenderMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
        this.edgeDetectionMaterial.dispose();
        this.separableBlurMaterial1.dispose();
        this.separableBlurMaterial2.dispose();
        this.overlayMaterial.dispose();
        this.materialCopy.dispose();
        this.fsQuad.dispose();
    }
    setSize(width, height) {
        var _a, _b;
        this.renderTargetMaskBuffer.setSize(width, height);
        let resx = Math.round(width / this.downSampleRatio);
        let resy = Math.round(height / this.downSampleRatio);
        this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
        this.renderTargetBlurBuffer1.setSize(resx, resy);
        this.renderTargetEdgeBuffer1.setSize(resx, resy);
        this.separableBlurMaterial1.uniforms.texSize.value.set(resx, resy);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
        this.renderTargetBlurBuffer2.setSize(resx, resy);
        this.renderTargetEdgeBuffer2.setSize(resx, resy);
        this.separableBlurMaterial2.uniforms.texSize.value.set(resx, resy);
        (_a = this.fxaaRenderMaterial) === null || _a === void 0 ? void 0 : _a.uniforms.resolution.value.set(1 / this.resolution.x, 1 / this.resolution.y);
        (_b = this.renderTargetFxaaBuffer) === null || _b === void 0 ? void 0 : _b.setSize(width, height);
    }
    _canBeHighlighted(object) {
        return (object.isMesh ||
            (OutlinePass.highlightLines && object.isLine));
    }
    _changeVisibilityOfSelectedObjects(bVisible) {
        const cache = this._visibilityCache;
        this.selectedObjects.forEach((selectedObject) => selectedObject.traverse((object) => {
            if (this._canBeHighlighted(object)) {
                if (bVisible === true) {
                    object.visible = cache.get(object);
                }
                else {
                    cache.set(object, object.visible);
                    object.visible = bVisible;
                }
            }
        }));
    }
    _changeVisibilityOfNonSelectedObjects(bVisible) {
        const cache = this._visibilityCache;
        const selectedMeshes = [];
        this.selectedObjects.forEach((selectedObject) => selectedObject.traverse((object) => {
            if (this._canBeHighlighted(object)) {
                selectedMeshes.push(object);
            }
        }));
        this.renderScene.traverse((object) => {
            if (this._canBeHighlighted(object) ||
                object.isSprite) {
                let bFound = selectedMeshes.some((selectedMesh) => selectedMesh.id === object.id);
                if (bFound === false) {
                    const visibility = object.visible;
                    if (bVisible === false || cache.get(object) === true) {
                        object.visible = bVisible;
                    }
                    cache.set(object, visibility);
                }
            }
            else if (object.isPoints) {
                if (bVisible === true) {
                    object.visible = cache.get(object); // restore
                }
                else {
                    cache.set(object, object.visible);
                    object.visible = bVisible;
                }
            }
        });
    }
    _updateTextureMatrix() {
        // prettier-ignore
        this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
        this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
    }
    render(renderer, _writeBuffer, readBuffer, _deltaTime, maskActive) {
        if (this.selectedObjects.length > 0) {
            renderer.getClearColor(this.oldClearColor);
            this.oldClearAlpha = renderer.getClearAlpha();
            const oldAutoClear = renderer.autoClear;
            if (this.clearBackground) {
                renderer.setClearColor(0x000000, 0xff);
                renderer.clear(true, false, false);
            }
            renderer.autoClear = false;
            if (maskActive) {
                renderer.state.buffers.stencil.setTest(false);
            }
            renderer.setClearColor(0xffffff, 1);
            // Make selected objects invisible
            this._changeVisibilityOfSelectedObjects(false);
            const currentBackground = this.renderScene.background;
            this.renderScene.background = null;
            // Make selected objects visible
            this._changeVisibilityOfSelectedObjects(true);
            this._visibilityCache.clear();
            // Update Texture Matrix for Depth compare
            this._updateTextureMatrix();
            // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects
            this._changeVisibilityOfNonSelectedObjects(false);
            this.renderScene.overrideMaterial = this.prepareMaskMaterial;
            this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(
            // @ts-ignore -- wrong typing near is there
            this.renderCamera.near, 
            // @ts-ignore -- wrong typing far is there
            this.renderCamera.far);
            this.prepareMaskMaterial.uniforms.depthTexture.value =
                this.gBufferTextures.textureWithDepthValue;
            this.prepareMaskMaterial.uniforms.textureMatrix.value =
                this.textureMatrix;
            renderer.setRenderTarget(this.renderTargetMaskBuffer);
            renderer.clear();
            renderer.render(this.renderScene, this.renderCamera);
            this.renderScene.overrideMaterial = null;
            this._changeVisibilityOfNonSelectedObjects(true);
            this._visibilityCache.clear();
            this.renderScene.background = currentBackground;
            // FXAA
            let renderTargetMaskBuffer = this.renderTargetMaskBuffer;
            if (this.edgeDetectionFxaa &&
                this.fxaaRenderMaterial &&
                this.renderTargetFxaaBuffer) {
                this.fxaaRenderMaterial.uniforms.tDiffuse.value =
                    this.renderTargetMaskBuffer.texture;
                this.fsQuad.material = this.fxaaRenderMaterial;
                renderer.setRenderTarget(this.renderTargetFxaaBuffer);
                renderer.clear();
                this.fsQuad.render(renderer);
                renderTargetMaskBuffer = this.renderTargetFxaaBuffer;
            }
            // 2. Downsample to Half resolution
            this.fsQuad.material = this.materialCopy;
            this.copyUniforms.tDiffuse.value = renderTargetMaskBuffer.texture;
            renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);
            renderer.clear();
            this.fsQuad.render(renderer);
            this.tempPulseColor1.copy(this.visibleEdgeColor);
            this.tempPulseColor2.copy(this.hiddenEdgeColor);
            if (this.pulsePeriod > 0) {
                const scalar = (1 + 0.25) / 2 +
                    (Math.cos((performance.now() * 0.01) / this.pulsePeriod) *
                        (1.0 - 0.25)) /
                        2;
                this.tempPulseColor1.multiplyScalar(scalar);
                this.tempPulseColor2.multiplyScalar(scalar);
            }
            // 3. Apply Edge Detection Pass
            this.fsQuad.material = this.edgeDetectionMaterial;
            this.edgeDetectionMaterial.uniforms.maskTexture.value =
                this.renderTargetMaskDownSampleBuffer.texture;
            this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
            this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value =
                this.tempPulseColor1;
            this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value =
                this.tempPulseColor2;
            renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
            renderer.clear();
            this.fsQuad.render(renderer);
            // 4. Apply Blur on Half res
            this.fsQuad.material = this.separableBlurMaterial1;
            this.separableBlurMaterial1.uniforms.colorTexture.value =
                this.renderTargetEdgeBuffer1.texture;
            this.separableBlurMaterial1.uniforms.direction.value =
                OutlinePass.BlurDirectionX;
            this.separableBlurMaterial1.uniforms.kernelRadius.value =
                this.edgeThickness;
            renderer.setRenderTarget(this.renderTargetBlurBuffer1);
            renderer.clear();
            this.fsQuad.render(renderer);
            this.separableBlurMaterial1.uniforms.colorTexture.value =
                this.renderTargetBlurBuffer1.texture;
            this.separableBlurMaterial1.uniforms.direction.value =
                OutlinePass.BlurDirectionY;
            renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
            renderer.clear();
            this.fsQuad.render(renderer);
            // Apply Blur on quarter res
            this.fsQuad.material = this.separableBlurMaterial2;
            this.separableBlurMaterial2.uniforms.colorTexture.value =
                this.renderTargetEdgeBuffer1.texture;
            this.separableBlurMaterial2.uniforms.direction.value =
                OutlinePass.BlurDirectionX;
            renderer.setRenderTarget(this.renderTargetBlurBuffer2);
            renderer.clear();
            this.fsQuad.render(renderer);
            this.separableBlurMaterial2.uniforms.colorTexture.value =
                this.renderTargetBlurBuffer2.texture;
            this.separableBlurMaterial2.uniforms.direction.value =
                OutlinePass.BlurDirectionY;
            renderer.setRenderTarget(this.renderTargetEdgeBuffer2);
            renderer.clear();
            this.fsQuad.render(renderer);
            // Blend it additively over the input texture
            this.fsQuad.material = this.overlayMaterial;
            this.overlayMaterial.uniforms.maskTexture.value =
                renderTargetMaskBuffer.texture;
            this.overlayMaterial.uniforms.edgeTexture1.value =
                this.renderTargetEdgeBuffer1.texture;
            this.overlayMaterial.uniforms.edgeTexture2.value =
                this.renderTargetEdgeBuffer2.texture;
            this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture;
            this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength;
            this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow;
            this.overlayMaterial.uniforms.usePatternTexture.value =
                this.usePatternTexture;
            if (maskActive) {
                renderer.state.buffers.stencil.setTest(true);
            }
            renderer.setRenderTarget(readBuffer);
            this.fsQuad.render(renderer);
            renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
            renderer.autoClear = oldAutoClear;
        }
        if (this.renderToScreen && readBuffer) {
            this.fsQuad.material = this.materialCopy;
            this.copyUniforms.tDiffuse.value = readBuffer.texture;
            renderer.setRenderTarget(null);
            this.fsQuad.render(renderer);
        }
    }
    renderPass(renderer) {
        this.render(renderer, null, null, 0, false);
    }
    _getPrepareMaskMaterial(floatAlphaDepth) {
        return new ShaderMaterial({
            uniforms: {
                depthTexture: { value: null },
                cameraNearFar: { value: new Vector2(0.5, 0.5) },
                textureMatrix: { value: null },
            },
            defines: {
                FLOAT_ALPHA_DEPTH: floatAlphaDepth ? 1 : 0,
            },
            vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;

					vec4 worldPosition = vec4( transformed, 1.0 );

					#ifdef USE_INSTANCING

						worldPosition = instanceMatrix * worldPosition;

					#endif
					
					worldPosition = modelMatrix * worldPosition;

					projTexCoord = textureMatrix * worldPosition;

				}`,
            fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

          #if FLOAT_ALPHA_DEPTH == 1
					  float depth = texture2DProj( depthTexture, projTexCoord ).w;
          #else
            float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
          #endif
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`,
        });
    }
    _getEdgeDetectionMaterial() {
        return new ShaderMaterial({
            uniforms: {
                maskTexture: { value: null },
                texSize: { value: new Vector2(0.5, 0.5) },
                visibleEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },
                hiddenEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },
            },
            vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`,
        });
    }
    _getSeperableBlurMaterial(maxRadius) {
        return new ShaderMaterial({
            defines: {
                MAX_RADIUS: maxRadius,
            },
            uniforms: {
                colorTexture: { value: null },
                texSize: { value: new Vector2(0.5, 0.5) },
                direction: { value: new Vector2(0.5, 0.5) },
                kernelRadius: { value: 1.0 },
            },
            vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float sigma = kernelRadius/2.0;
					float weightSum = gaussianPdf(0.0, sigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float x = kernelRadius * float(i) / float(MAX_RADIUS);
						float w = gaussianPdf(x, sigma);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`,
        });
    }
    _getOverlayMaterial() {
        return new ShaderMaterial({
            uniforms: {
                maskTexture: { value: null },
                edgeTexture1: { value: null },
                edgeTexture2: { value: null },
                patternTexture: { value: null },
                edgeStrength: { value: 1.0 },
                edgeGlow: { value: 1.0 },
                usePatternTexture: { value: 0.0 },
            },
            vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
                }`,
            blending: AdditiveBlending,
            //blending: CustomBlending,
            depthTest: false,
            depthWrite: false,
            transparent: true,
        });
    }
}
OutlinePass.BlurDirectionX = new Vector2(1.0, 0.0);
OutlinePass.BlurDirectionY = new Vector2(0.0, 1.0);
OutlinePass.highlightLines = true;

const sphereToEquirectangular = (pointOnSphere) => {
    const u = Math.atan2(pointOnSphere.y, pointOnSphere.x) / (2 * Math.PI) + 0.5;
    const v = Math.asin(pointOnSphere.z) / Math.PI + 0.5;
    return new Vector2(u, v);
};
class TextureConverter {
    get colorRenderTarget() {
        var _a;
        this._colorRenderTarget =
            (_a = this._colorRenderTarget) !== null && _a !== void 0 ? _a : new WebGLRenderTarget();
        return this._colorRenderTarget;
    }
    environmentMapDecodeTarget(renderer) {
        var _a;
        const targetType = renderer.capabilities.isWebGL2
            ? FloatType
            : UnsignedByteType;
        this._environmentMapDecodeTarget =
            (_a = this._environmentMapDecodeTarget) !== null && _a !== void 0 ? _a : new WebGLRenderTarget(1, 1, { type: targetType });
        return this._environmentMapDecodeTarget;
    }
    environmentMapDecodeMaterial(decodePmrem) {
        var _a, _b;
        if (decodePmrem) {
            this._equirectangularDecodeMaterial =
                (_a = this._equirectangularDecodeMaterial) !== null && _a !== void 0 ? _a : new EnvironmentMapDecodeMaterial(true, false);
            return this._equirectangularDecodeMaterial;
        }
        else {
            this._pmremDecodeMaterial =
                (_b = this._pmremDecodeMaterial) !== null && _b !== void 0 ? _b : new EnvironmentMapDecodeMaterial(false, false);
            return this._pmremDecodeMaterial;
        }
    }
    get camera() {
        var _a;
        this._camera = (_a = this._camera) !== null && _a !== void 0 ? _a : new OrthographicCamera(-1, 1, 1, -1, -1, 1);
        return this._camera;
    }
    scaleTexture(renderer, texture, targetWidth, targetHeight) {
        var _a;
        this.colorRenderTarget.setSize(targetWidth, targetHeight);
        this._planeMesh =
            (_a = this._planeMesh) !== null && _a !== void 0 ? _a : new Mesh(new PlaneGeometry(2, 2), new MeshBasicMaterial({ map: texture }));
        const renderTargetBackup = renderer.getRenderTarget();
        renderer.setRenderTarget(this.colorRenderTarget);
        renderer.render(this._planeMesh, this.camera);
        renderer.setRenderTarget(renderTargetBackup);
        const colorTexture = this.environmentMapDecodeTarget(renderer).texture;
        const pixelBuffer = new Uint8Array(targetWidth * targetHeight * 4);
        renderer.readRenderTargetPixels(this.colorRenderTarget, 0, 0, targetWidth, targetHeight, pixelBuffer);
        return { texture: colorTexture, pixels: pixelBuffer, sRgbaPixels: false };
    }
    newGrayscaleTexture(renderer, texture, targetWidth, targetHeight) {
        var _a;
        const decodeMaterial = this.environmentMapDecodeMaterial(texture.name === 'PMREM.cubeUv');
        const envMapDecodeTarget = this.environmentMapDecodeTarget(renderer);
        envMapDecodeTarget.setSize(targetWidth, targetHeight);
        decodeMaterial.setSourceTexture(texture);
        this._planeMesh =
            (_a = this._planeMesh) !== null && _a !== void 0 ? _a : new Mesh(new PlaneGeometry(2, 2), decodeMaterial);
        const renderTargetBackup = renderer.getRenderTarget();
        renderer.setRenderTarget(envMapDecodeTarget);
        renderer.render(this._planeMesh, this.camera);
        renderer.setRenderTarget(renderTargetBackup);
        const grayscaleTexture = envMapDecodeTarget.texture;
        const floatType = envMapDecodeTarget.texture.type === FloatType;
        let pixelBuffer = floatType
            ? new Float32Array(targetWidth * targetHeight * 4)
            : new Uint8Array(targetWidth * targetHeight * 4);
        renderer.readRenderTargetPixels(envMapDecodeTarget, 0, 0, targetWidth, targetHeight, pixelBuffer);
        return {
            texture: grayscaleTexture,
            pixels: pixelBuffer,
            sRgbaPixels: floatType,
        };
    }
}
const EnvironmentMapDecodeShader = {
    uniforms: {
        tDiffuse: { value: null },
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = (projectionMatrix * modelViewMatrix * vec4(position, 1.0)).xyww;
        }`,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        
        float getFace( vec3 direction ) {
          vec3 absDirection = abs( direction );
          float face = - 1.0;
          if ( absDirection.x > absDirection.z ) {
            if ( absDirection.x > absDirection.y )
              face = direction.x > 0.0 ? 0.0 : 3.0;
            else
              face = direction.y > 0.0 ? 1.0 : 4.0;
          } else {
            if ( absDirection.z > absDirection.y )
              face = direction.z > 0.0 ? 2.0 : 5.0;
            else
              face = direction.y > 0.0 ? 1.0 : 4.0;
          }
          return face;
        }

        vec2 getUV( vec3 direction, float face ) {
          vec2 uv;
          if ( face == 0.0 ) {
            uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x
          } else if ( face == 1.0 ) {
            uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y
          } else if ( face == 2.0 ) {
            uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z
          } else if ( face == 3.0 ) {
            uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x
          } else if ( face == 4.0 ) {
            uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y
          } else {
            uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z
          }
          return 0.5 * ( uv + 1.0 );
        }

        void main() {
            #if PMREM_DECODE == 1
                float altitude = (vUv.y - 0.5) * 3.141593;
                float azimuth = vUv.x * 2.0 * 3.141593;
                vec3 direction = vec3(
                  cos(altitude) * cos(azimuth) * -1.0, 
                  sin(altitude), 
                  cos(altitude) * sin(azimuth) * -1.0
                );
                float face = getFace(direction);
                vec2 uv = getUV(direction, face) / vec2(3.0, 4.0);
                if (face > 2.5) {
                    uv.y += 0.25;
                    face -= 3.0;
                }
                uv.x += face / 3.0;
                vec4 color = texture2D(tDiffuse, uv);
            #else
                vec4 color = texture2D(tDiffuse, vUv);
            #endif    
            #if GRAYSCALE_CONVERT == 1
                float grayscale = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
                //float grayscale = dot(color.rgb, vec3(1.0/3.0));
                gl_FragColor = vec4(vec3(grayscale), 1.0);
            #else
                gl_FragColor = vec4(color.rgb, 1.0);
            #endif
        }`,
};
class EnvironmentMapDecodeMaterial extends ShaderMaterial {
    constructor(decodePmrem, grayscale) {
        super({
            uniforms: UniformsUtils.clone(EnvironmentMapDecodeShader.uniforms),
            vertexShader: EnvironmentMapDecodeShader.vertexShader,
            fragmentShader: EnvironmentMapDecodeShader.fragmentShader,
            defines: {
                PMREM_DECODE: decodePmrem ? 1 : 0,
                GRAYSCALE_CONVERT: grayscale ? 1 : 0,
            },
        });
    }
    setSourceTexture(map) {
        this.uniforms.tDiffuse.value = map;
    }
}
class LightSourceDetector {
    constructor(parameters) {
        var _a, _b, _c, _d;
        this.samplePoints = [];
        this.sampleUVs = [];
        this.grayscaleTexture = {
            texture: new Texture(),
            pixels: new Uint8Array(0),
            sRgbaPixels: false,
        };
        this.detectorTexture = new Texture();
        this.detectorArray = new Float32Array(0);
        this.lightSamples = [];
        this.lightGraph = new LightGraph(0);
        this.lightSources = [];
        this._grayScale = new Vector3(0.2126, 0.7152, 0.0722);
        this._createEquirectangularSamplePoints = (numberOfPoints) => {
            const points = [];
            for (let i = 0; i < numberOfPoints; i++) {
                const spiralAngle = i * Math.PI * (3 - Math.sqrt(5));
                const z = 1 - (i / (numberOfPoints - 1)) * 2;
                const radius = Math.sqrt(1 - z * z);
                const x = Math.cos(spiralAngle) * radius;
                const y = Math.sin(spiralAngle) * radius;
                points.push(new Vector3(x, y, z));
            }
            return points;
        };
        this._numberOfSamples = (_a = parameters === null || parameters === void 0 ? void 0 : parameters.numberOfSamples) !== null && _a !== void 0 ? _a : 1000;
        this._width = (_b = parameters === null || parameters === void 0 ? void 0 : parameters.width) !== null && _b !== void 0 ? _b : 1024;
        this._height = (_c = parameters === null || parameters === void 0 ? void 0 : parameters.height) !== null && _c !== void 0 ? _c : 512;
        this._sampleThreshold = (_d = parameters === null || parameters === void 0 ? void 0 : parameters.sampleThreshold) !== null && _d !== void 0 ? _d : 0.707;
        this.pointDistance =
            Math.sqrt(4 * Math.PI) / Math.sqrt(this._numberOfSamples);
        this.pixelDistance = (Math.sqrt(2) * Math.PI * 2) / this._width;
        this.samplePoints = this._createEquirectangularSamplePoints(this._numberOfSamples);
        this.sampleUVs = this.samplePoints.map((point) => sphereToEquirectangular(point));
    }
    detectLightSources(renderer, equirectangularTexture, textureData) {
        var _a;
        this.textureData = textureData;
        this._textureConverter = (_a = this._textureConverter) !== null && _a !== void 0 ? _a : new TextureConverter();
        this.grayscaleTexture = this._textureConverter.newGrayscaleTexture(renderer, equirectangularTexture, this._width, this._height);
        this.detectorArray = this._redFromRgbaToNormalizedFloatArray(this.grayscaleTexture.pixels, this.grayscaleTexture.sRgbaPixels);
        this.detectorTexture = this._grayscaleTextureFromFloatArray(this.detectorArray, this._width, this._height);
        this.lightSamples = this._filterLightSamples(this._sampleThreshold);
        this.lightGraph = this._findClusterSegments(this.lightSamples, this._sampleThreshold);
        this.lightGraph.findConnectedComponents();
        this.lightSources = this.createLightSourcesFromLightGraph(this.lightSamples, this.lightGraph);
        this.lightSources.sort((a, b) => b.maxIntensity - a.maxIntensity);
    }
    _redFromRgbaToNormalizedFloatArray(rgba, sRgbaPixels, exponent) {
        const floatArray = new Float32Array(rgba.length / 4);
        let minimumValue = 1;
        let maximumValue = 0;
        for (let i = 0; i < rgba.length / 4; ++i) {
            const color = new Color$1(...rgba.slice(i * 4, i * 4 + 3));
            if (rgba instanceof Float32Array) {
                color.convertSRGBToLinear();
            }
            const value = new Vector3(color.r, color.g, color.b).dot(this._grayScale);
            minimumValue = Math.min(minimumValue, value);
            maximumValue = Math.max(maximumValue, value);
            floatArray[i] = value;
        }
        if (exponent) {
            for (let i = 0; i < floatArray.length; ++i) {
                const normalizedValue = sRgbaPixels
                    ? floatArray[i]
                    : (floatArray[i] - minimumValue) / (maximumValue - minimumValue);
                floatArray[i] = Math.pow(normalizedValue, exponent);
            }
        }
        else if (!sRgbaPixels) {
            for (let i = 0; i < floatArray.length; ++i) {
                floatArray[i] =
                    (floatArray[i] - minimumValue) / (maximumValue - minimumValue);
            }
        }
        return floatArray;
    }
    _grayscaleTextureFromFloatArray(floatArray, _width, _height) {
        const noOfPixels = _width * _height;
        const uint8data = new Uint8Array(4 * noOfPixels);
        for (let i = 0; i < noOfPixels; i++) {
            const grayscale = floatArray[i] * 255;
            uint8data[i * 4 + 0] = grayscale;
            uint8data[i * 4 + 1] = grayscale;
            uint8data[i * 4 + 2] = grayscale;
            uint8data[i * 4 + 3] = 255;
        }
        const dataTexture = new DataTexture(uint8data, _width, _height);
        dataTexture.needsUpdate = true;
        return dataTexture;
    }
    _filterLightSamples(threshold) {
        const lightSamples = [];
        for (let i = 0; i < this.sampleUVs.length; i++) {
            const uv = this.sampleUVs[i];
            const value = this._detectorTextureLuminanceValueFromUV(uv);
            if (value > threshold) {
                lightSamples.push(new LightSample(this.samplePoints[i], uv));
            }
        }
        return lightSamples;
    }
    _detectorTextureLuminanceValueFromUV(uv) {
        const column = Math.floor(uv.x * this._width);
        const row = Math.floor(uv.y * this._height);
        const index = row * this._width + column;
        return this.detectorArray[index];
    }
    _originalLuminanceValueFromUV(uv) {
        if (!this.textureData ||
            !this.textureData.data ||
            !this.textureData._width ||
            !this.textureData._height) {
            return this._detectorTextureLuminanceValueFromUV(uv) * 256;
        }
        const column = Math.floor(uv.x * this.textureData._width);
        const row = Math.floor(uv.y * this.textureData._height);
        let luminance = 0;
        for (let x = Math.max(0, column - 2); x < Math.max(0, column + 2); ++x) {
            for (let y = Math.max(0, row - 2); y < Math.max(0, row + 2); ++y) {
                const index = y * this.textureData._width + x;
                const grayValue = (this.textureData.data[index * 4] +
                    this.textureData.data[index * 4 + 1] +
                    this.textureData.data[index * 4 + 2]) /
                    3;
                luminance = Math.max(luminance, grayValue);
            }
        }
        return luminance;
    }
    _findClusterSegments(samples, threshold) {
        const stepDistance = this.pixelDistance * 2;
        const maxDistance = this.pointDistance * 1.5;
        const lightGraph = new LightGraph(samples.length);
        for (let i = 0; i < samples.length; i++) {
            for (let j = i + 1; j < samples.length; j++) {
                if (samples[i].position.angleTo(samples[j].position) < maxDistance) {
                    const direction = samples[j].position
                        .clone()
                        .sub(samples[i].position);
                    const steps = Math.floor(direction.length() / stepDistance);
                    let inTreshold = true;
                    let outOfTresholdCount = 0;
                    for (let k = 1; k < steps; k++) {
                        const step = direction.clone().multiplyScalar(k / steps);
                        const uv = sphereToEquirectangular(samples[i].position.clone().add(step).normalize());
                        const value = this._detectorTextureLuminanceValueFromUV(uv);
                        if (value < threshold) {
                            outOfTresholdCount++;
                            if (outOfTresholdCount > 1) {
                                inTreshold = false;
                                break;
                            }
                        }
                        else {
                            outOfTresholdCount = 0;
                        }
                    }
                    if (inTreshold) {
                        lightGraph.adjacent[i].push(j);
                        lightGraph.adjacent[j].push(i);
                        lightGraph.edges.push([i, j]);
                    }
                }
            }
        }
        return lightGraph;
    }
    createLightSourcesFromLightGraph(samples, lightGraph) {
        const lightSources = lightGraph.components
            .filter((component) => component.length > 1)
            .map((component) => new LightSource(component.map((index) => samples[index])));
        lightSources.forEach((lightSource) => lightSource.calculateLightSourceProperties((uv) => this._originalLuminanceValueFromUV(uv)));
        return lightSources;
    }
}
class LightSample {
    constructor(position, uv) {
        this.position = position;
        this.uv = uv;
    }
}
class LightGraph {
    constructor(noOfNodes) {
        this.edges = [];
        this.adjacent = [];
        this.components = [];
        this.noOfNodes = noOfNodes;
        for (let i = 0; i < noOfNodes; i++) {
            this.adjacent.push([]);
        }
    }
    findConnectedComponents() {
        const visited = new Array(this.noOfNodes).fill(false);
        this.components = [];
        for (let i = 0; i < this.noOfNodes; i++) {
            if (!visited[i]) {
                const component = [];
                this._dfs(i, visited, component);
                this.components.push(component);
            }
        }
        this.components.sort((a, b) => b.length - a.length);
    }
    _dfs(node, visited, component) {
        visited[node] = true;
        component.push(node);
        for (const adjacentNode of this.adjacent[node]) {
            if (!visited[adjacentNode]) {
                this._dfs(adjacentNode, visited, component);
            }
        }
    }
}
class LightSource {
    constructor(lightSamples) {
        this.position = new Vector3();
        this.uv = new Vector2();
        this.averageIntensity = 0;
        this.maxIntensity = 0;
        this.size = 0;
        this.lightSamples = lightSamples;
    }
    calculateLightSourceProperties(luminanceFunction) {
        this.position = new Vector3();
        this.averageIntensity = 0;
        this.maxIntensity = 0;
        for (const lightSample of this.lightSamples) {
            this.position.add(lightSample.position);
            const luminanceValue = luminanceFunction(lightSample.uv);
            this.averageIntensity += luminanceValue;
            this.maxIntensity = Math.max(this.maxIntensity, luminanceValue);
        }
        this.averageIntensity /= this.lightSamples.length;
        this.position.normalize();
        this.uv = sphereToEquirectangular(this.position);
        let averageDistance = 0;
        for (const lightSample of this.lightSamples) {
            averageDistance += lightSample.position.distanceTo(this.position);
        }
        averageDistance /= this.lightSamples.length;
        this.size = averageDistance / Math.PI;
    }
}

class DebugPass extends RenderPass {
    constructor(renderPassManager) {
        super(renderPassManager);
        this.debugOutput = '';
        this._environmentMapDecodeMaterial = new EnvironmentMapDecodeMaterial(true, false);
        this._environmentMapDecodeMaterial.blending = NoBlending;
        this._environmentMapDecodeMaterial.depthTest = false;
    }
    dispose() {
        var _a, _b;
        (_a = this._depthRenderMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._copyMaterial) === null || _b === void 0 ? void 0 : _b.dispose();
    }
    getCopyMaterial(parameters) {
        var _a;
        this._copyMaterial = (_a = this._copyMaterial) !== null && _a !== void 0 ? _a : new CopyTransformMaterial();
        return this._copyMaterial.update(parameters);
    }
    _getDepthRenderMaterial(camera) {
        var _a;
        this._depthRenderMaterial =
            (_a = this._depthRenderMaterial) !== null && _a !== void 0 ? _a : new LinearDepthRenderMaterial({
                depthTexture: this.gBufferTextures.textureWithDepthValue,
                depthFilter: this.gBufferTextures.isFloatGBufferWithRgbNormalAlphaDepth
                    ? new Vector4(0, 0, 0, 1)
                    : new Vector4(1, 0, 0, 0),
            });
        return this._depthRenderMaterial.update({ camera });
    }
    // eslint-disable-next-line complexity
    renderPass(renderer) {
        var _a, _b, _c, _d, _e, _f;
        switch (this.debugOutput) {
            default:
                break;
            case 'lineardepth':
                this.passRenderer.renderScreenSpace(renderer, this._getDepthRenderMaterial(this.camera), null);
                break;
            case 'g-normal':
                if (this.gBufferTextures.isFloatGBufferWithRgbNormalAlphaDepth) {
                    this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                        texture: (_a = this.gBufferTextures) === null || _a === void 0 ? void 0 : _a.gBufferTexture,
                        blending: NoBlending,
                        // prettier-ignore
                        colorTransform: new Matrix4().set(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0),
                        colorBase: new Vector4(0.5, 0.5, 0.5, 1),
                        multiplyChannels: 0,
                        uvTransform: DEFAULT_UV_TRANSFORM,
                    }), null);
                }
                else {
                    this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                        texture: (_b = this.gBufferTextures) === null || _b === void 0 ? void 0 : _b.gBufferTexture,
                        blending: NoBlending,
                        colorTransform: RGB_TRANSFORM,
                        colorBase: ALPHA_RGBA,
                        multiplyChannels: 0,
                        uvTransform: DEFAULT_UV_TRANSFORM,
                    }), null);
                }
                break;
            case 'g-depth':
                if (this.gBufferTextures.isFloatGBufferWithRgbNormalAlphaDepth) {
                    this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                        texture: (_c = this.gBufferTextures) === null || _c === void 0 ? void 0 : _c.gBufferTexture,
                        blending: NoBlending,
                        colorTransform: ALPHA_TRANSFORM,
                        colorBase: ALPHA_RGBA,
                        multiplyChannels: 0,
                        uvTransform: DEFAULT_UV_TRANSFORM,
                    }), null);
                }
                else {
                    this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                        texture: (_d = this.gBufferTextures) === null || _d === void 0 ? void 0 : _d.depthBufferTexture,
                        blending: NoBlending,
                        colorTransform: RED_TRANSFORM,
                        colorBase: ALPHA_RGBA,
                        multiplyChannels: 0,
                        uvTransform: DEFAULT_UV_TRANSFORM,
                    }), null);
                }
                break;
            case 'ssao':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.aoAndSoftShadowRenderTarget
                        .texture,
                    blending: NoBlending,
                    colorTransform: GRAYSCALE_TRANSFORM,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'ssaodenoise':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.denoiseRenderTargetTexture,
                    blending: NoBlending,
                    colorTransform: GRAYSCALE_TRANSFORM,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'shadowmap':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.screenSpaceShadowMapPass.shadowTexture,
                    blending: NoBlending,
                    colorTransform: GRAYSCALE_TRANSFORM,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'shadowsoft':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.aoAndSoftShadowRenderTarget
                        .texture,
                    blending: NoBlending,
                    colorTransform: ShadowAndAoPass.shadowTransform,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'shadowdenoise':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.denoiseRenderTargetTexture,
                    blending: NoBlending,
                    colorTransform: ShadowAndAoPass.shadowTransform,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'shadowfadein':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.fadeRenderTarget.texture,
                    blending: NoBlending,
                    colorTransform: ShadowAndAoPass.shadowTransform,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'shadowandao':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.shadowAndAoPass.denoiseRenderTargetTexture,
                    blending: NoBlending,
                    colorTransform: interpolationMatrix(this.renderPassManager.shadowAndAoPass.parameters.aoIntensity, this.renderPassManager.shadowAndAoPass.parameters.shadowIntensity, 0, 1),
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 1,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'groundreflection':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.groundReflectionPass.reflectionRenderTarget
                        .texture,
                    blending: NoBlending,
                    colorTransform: DEFAULT_TRANSFORM,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: FLIP_Y_UV_TRANSFORM,
                }), null);
                break;
            case 'bakedgroundshadow':
                this.passRenderer.renderScreenSpace(renderer, this.getCopyMaterial({
                    texture: this.renderPassManager.bakedGroundContactShadowPass.renderTarget
                        .texture,
                    blending: NoBlending,
                    colorTransform: DEFAULT_TRANSFORM,
                    colorBase: ZERO_RGBA,
                    multiplyChannels: 0,
                    uvTransform: DEFAULT_UV_TRANSFORM,
                }), null);
                break;
            case 'environmentmap':
                this._environmentMapDecodeMaterial.setSourceTexture(this.scene.environment);
                this.passRenderer.renderScreenSpace(renderer, this._environmentMapDecodeMaterial, null);
                break;
            case 'lightsourcedetection':
                if ((_e = this.scene.userData) === null || _e === void 0 ? void 0 : _e.environmentDefinition) {
                    const aspect = this.renderPassManager.aspect;
                    const environmentCamera = new OrthographicCamera(-1, 1, 1 / aspect, -1 / aspect, -1, 1);
                    const environmentScene = (_f = this.scene.userData) === null || _f === void 0 ? void 0 : _f.environmentDefinition.createDebugScene(renderer, this.scene, this.renderPassManager.screenSpaceShadowMapPass.parameters
                        .maximumNumberOfLightSources);
                    environmentScene.background = new Color$1(0xffffff);
                    renderer.render(environmentScene, environmentCamera);
                }
                break;
        }
    }
}

class SceneRenderPass extends RenderPass {
    constructor(renderPassManager) {
        super(renderPassManager);
        this.drawGround = true;
        this.drawWithDebugMaterial = false;
        this.grayDebugMaterial = new MeshStandardMaterial({
            color: 0xc0c0c0,
            side: DoubleSide,
            envMapIntensity: 0.4,
        });
    }
    dispose() {
        super.dispose();
        this.grayDebugMaterial.dispose();
    }
    renderPass(renderer) {
        this.renderCacheManager.onBeforeRender('floorDepthWrite', this.scene);
        this.renderPassManager.setGroundVisibility(this.drawGround);
        if (this.drawWithDebugMaterial) {
            this.renderCacheManager.render('debug', this.scene, () => {
                this.passRenderer.renderWithOverrideMaterial(renderer, this.scene, this.camera, this.grayDebugMaterial, null, 0, 1);
            });
        }
        else {
            renderer.render(this.scene, this.camera);
        }
        this.renderPassManager.setGroundVisibility(false);
        this.renderCacheManager.onAfterRender('floorDepthWrite');
    }
}

class RenderPassManager {
    get passRenderer() {
        return this._passRenderer;
    }
    get scene() {
        return this._scene;
    }
    get camera() {
        return this._camera;
    }
    get aspect() {
        return this._sceneRenderer.width / this._sceneRenderer.height;
    }
    get cameraChanged() {
        return this._cameraChanged;
    }
    get noOStaticFrames() {
        return this._noOStaticFrames;
    }
    get renderCacheManager() {
        return this._sceneRenderer.renderCacheManager;
    }
    get parameters() {
        return this._sceneRenderer.parameters;
    }
    get sceneRenderPass() {
        return this._sceneRenderPass;
    }
    get bakedGroundContactShadowPass() {
        return this._bakedGroundContactShadowPass;
    }
    get gBufferRenderPass() {
        return this._gBufferRenderPass;
    }
    get groundReflectionPass() {
        return this._groundReflectionPass;
    }
    get screenSpaceShadowMapPass() {
        return this._screenSpaceShadowMapPass;
    }
    get shadowAndAoPass() {
        return this._shadowAndAoPass;
    }
    get outlinePass() {
        return this._outlinePass;
    }
    get outlineRenderer() {
        return this._sceneRenderer.outlineRenderer;
    }
    get debugPass() {
        var _a;
        (_a = this._debugPass) !== null && _a !== void 0 ? _a : (this._debugPass = new DebugPass(this));
        return this._debugPass;
    }
    get debugOutput() {
        return this._sceneRenderer.debugOutput;
    }
    constructor(sceneRender) {
        this._passRenderer = new PassRenderer();
        this._outlinePass = null;
        this._debugPass = null;
        this._cameraUpdate = new CameraUpdate();
        this._cameraChanged = true;
        this._noUpdateNeededCount = 0;
        this._noOStaticFrames = 0;
        this._maxSamples = 1;
        this._passUpdateStates = {
            updateGroundReflection: false,
            updateGBuffer: false,
            updateScreenSpaceShadow: false,
            updateShadowAndAoPass: false,
            updateOutlinePass: false,
            updateDebugPass: false,
        };
        this._sceneRenderer = sceneRender;
        this._maxSamples = getMaxSamples(this._sceneRenderer.renderer);
        this._sceneRenderPass = new SceneRenderPass(this);
        this._bakedGroundContactShadowPass = new BakedGroundContactShadowPass(this, this._sceneRenderer.renderer, this._sceneRenderer.groundGroup, {
            sharedShadowGroundPlane: this._sceneRenderer.shadowAndAoGroundPlane,
        });
        const gBufferAndAoSamples = 1;
        this._gBufferRenderPass = new GBufferRenderPass(this, {
            shared: true,
            capabilities: this._sceneRenderer.renderer.capabilities,
            width: this._sceneRenderer.width,
            height: this._sceneRenderer.height,
            samples: gBufferAndAoSamples,
        });
        this._groundReflectionPass = new GroundReflectionPass(this, this._sceneRenderer.width, this._sceneRenderer.height, {});
        this._screenSpaceShadowMapPass = new ScreenSpaceShadowMapPass(this, new Vector2(this._sceneRenderer.width, this._sceneRenderer.height), {
            samples: this._maxSamples,
            alwaysUpdate: false,
        });
        this._shadowAndAoPass = new ShadowAndAoPass(this, this._sceneRenderer.width, this._sceneRenderer.height, gBufferAndAoSamples);
    }
    dispose() {
        var _a;
        this._sceneRenderPass.dispose();
        this._bakedGroundContactShadowPass.dispose();
        this._gBufferRenderPass.dispose();
        this._groundReflectionPass.dispose();
        this._screenSpaceShadowMapPass.dispose();
        this._shadowAndAoPass.dispose();
        (_a = this._outlinePass) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    setSize(width, height) {
        var _a;
        this._gBufferRenderPass.setSize(width, height);
        this._groundReflectionPass.setSize(width, height);
        this._screenSpaceShadowMapPass.setSize(width, height);
        this._shadowAndAoPass.setSize(width, height);
        (_a = this._outlinePass) === null || _a === void 0 ? void 0 : _a.setSize(width, height);
    }
    createOutlinePass() {
        if (!this._outlinePass) {
            this._outlinePass = new OutlinePass(this, new Vector2(this._sceneRenderer.width, this._sceneRenderer.height), this.scene, this.camera, [], {
                downSampleRatio: 2,
                edgeDetectionFxaa: true,
            });
        }
        return this._outlinePass;
    }
    setGroundVisibility(visible) {
        this._sceneRenderer.shadowAndAoGroundPlane.setVisibility(visible);
    }
    updatePasses(scene, camera) {
        this._scene = scene;
        this._camera = camera;
        this._cameraChanged = this._cameraUpdate.changed(camera);
        const updateRequirements = this._evaluateIfShadowAndAoUpdateIsNeeded();
        this._updateSceneRenderPass();
        this._updateBakedGroundContactShadowPass();
        this._updateGBufferPass(updateRequirements);
        this._updateGroundReflectionPass(updateRequirements);
        this._updateScreenSpaceShadowPass(updateRequirements);
        this._updateShadowAndAoPass(updateRequirements);
        this._updateOutlinePass();
        this._updateDebugPass();
    }
    _evaluateIfShadowAndAoUpdateIsNeeded() {
        const updateNow = this._shadowAndAoPass.parameters.alwaysUpdate ||
            this._screenSpaceShadowMapPass.needsUpdate ||
            this._screenSpaceShadowMapPass.shadowTypeNeedsUpdate;
        let needsUpdate = (this._shadowAndAoPass.parameters.enabled ||
            this._groundReflectionPass.parameters.enabled) &&
            this._cameraChanged;
        let intensityScale = 1;
        if (needsUpdate) {
            this._noUpdateNeededCount = 0;
            this._noOStaticFrames = 0;
        }
        if (!updateNow) {
            this._noUpdateNeededCount++;
            needsUpdate =
                this._noUpdateNeededCount >= this.parameters.effectSuspendFrames;
            intensityScale = Math.max(0, Math.min(1, (this._noUpdateNeededCount - this.parameters.effectSuspendFrames) /
                this.parameters.effectFadeInFrames));
        }
        if (!updateNow && intensityScale === 1) {
            this._noOStaticFrames++;
        }
        needsUpdate = updateNow || needsUpdate;
        const shadowOnCameraChange = !needsUpdate || intensityScale < 0.99
            ? this.parameters.shadowOnCameraChange
            : SHADOW_BLUR_TYPES.OFF;
        return { needsUpdate, shadowOnCameraChange, intensityScale };
    }
    _dynamicChanges(updateRequirements) {
        return (updateRequirements.needsUpdate ||
            updateRequirements.shadowOnCameraChange !== SHADOW_BLUR_TYPES.OFF);
    }
    _updateSceneRenderPass() {
        this._sceneRenderPass.drawWithDebugMaterial = false;
    }
    _updateBakedGroundContactShadowPass() {
        if (this._bakedGroundContactShadowPass.needsUpdate) {
            this._bakedGroundContactShadowPass.updateBounds(this._sceneRenderer.boundingVolume, this._sceneRenderer.groundLevel);
        }
        this._sceneRenderPass.drawGround =
            this._bakedGroundContactShadowPass.parameters.enabled;
    }
    _updateGBufferPass(updateRequirements) {
        this._passUpdateStates.updateGBuffer = false;
        this._gBufferRenderPass.needsUpdate =
            updateRequirements.needsUpdate ||
                updateRequirements.shadowOnCameraChange === SHADOW_BLUR_TYPES.POISSON;
        this.gBufferRenderPass.drawGround =
            this._sceneRenderer.boundingVolumeSet &&
                this._shadowAndAoPass.parameters.aoOnGround;
    }
    _updateGroundReflectionPass(updateRequirements) {
        this._passUpdateStates.updateGroundReflection = false;
        if (this._groundReflectionPass.parameters.enabled &&
            this._dynamicChanges(updateRequirements) &&
            (!this.parameters.suspendGroundReflection ||
                updateRequirements.needsUpdate)) {
            this._groundReflectionPass.reflectionFadeInScale = this.parameters
                .suspendGroundReflection
                ? updateRequirements.intensityScale
                : 1.0;
            this._passUpdateStates.updateGroundReflection = true;
        }
    }
    _updateScreenSpaceShadowPass(updateRequirements) {
        if (!this._dynamicChanges(updateRequirements)) {
            this._passUpdateStates.updateScreenSpaceShadow = false;
            return;
        }
        this._screenSpaceShadowMapPass.parameters.alwaysUpdate =
            this._shadowAndAoPass.parameters.alwaysUpdate;
        this._screenSpaceShadowMapPass.drawGround =
            this._shadowAndAoPass.parameters.shadowOnGround;
        this._passUpdateStates.updateScreenSpaceShadow =
            this._shadowAndAoPass.parameters.shadowIntensity > 0;
        this._passUpdateStates.updateScreenSpaceShadow = true;
        this._passUpdateStates.updateGBuffer = true;
    }
    _updateShadowAndAoPass(updateRequirements) {
        if (!this._dynamicChanges(updateRequirements)) {
            this._passUpdateStates.updateShadowAndAoPass = false;
            return;
        }
        this._shadowAndAoPass.shadowAndAoPassSettings = {
            shadowMapTexture: this._screenSpaceShadowMapPass.shadowTexture,
            shadowBlurType: updateRequirements.needsUpdate
                ? SHADOW_BLUR_TYPES.FULL
                : updateRequirements.shadowOnCameraChange,
            shadowFadeInBlurType: updateRequirements.shadowOnCameraChange,
            shadowFadeInMix: 1 - updateRequirements.intensityScale,
            noOStaticFrames: this.noOStaticFrames,
        };
        this._passUpdateStates.updateShadowAndAoPass = true;
        this._passUpdateStates.updateGBuffer = true;
    }
    _updateOutlinePass() {
        if (!this.outlineRenderer.outlinePassActivated ||
            !this.outlineRenderer.outlinePass) {
            this._passUpdateStates.updateOutlinePass = false;
            return;
        }
        this.outlineRenderer.outlinePass.renderToScreen = false;
        this.outlineRenderer.outlinePass.clearBackground = true;
        this._passUpdateStates.updateOutlinePass = true;
        this._passUpdateStates.updateGBuffer = true;
    }
    _updateDebugPass() {
        if (!this.debugOutput ||
            this.debugOutput === '' ||
            this.debugOutput === 'off') {
            this._passUpdateStates.updateDebugPass = false;
            return;
        }
        if (this.debugOutput === 'outline' && this.outlineRenderer.outlinePass) {
            this.outlineRenderer.outlinePass.clearBackground = true;
            this._passUpdateStates.updateDebugPass = false;
            return;
        }
        if (this.debugOutput === 'color' || this.debugOutput === 'grayscale') {
            this._passUpdateStates.updateGroundReflection = false;
            this._passUpdateStates.updateGBuffer = false;
            this._passUpdateStates.updateScreenSpaceShadow = false;
            this._passUpdateStates.updateShadowAndAoPass = false;
            this._passUpdateStates.updateOutlinePass = false;
            this._passUpdateStates.updateDebugPass = false;
            this._sceneRenderPass.drawWithDebugMaterial =
                this.debugOutput === 'grayscale';
            return;
        }
        this.debugPass.debugOutput = this.debugOutput;
        this._passUpdateStates.updateDebugPass = true;
    }
    renderPasses(renderer) {
        var _a, _b;
        renderer.setRenderTarget(null);
        this._bakedGroundContactShadowPass.renderPass(renderer);
        this._sceneRenderPass.renderPass(renderer);
        if (this._passUpdateStates.updateGBuffer) {
            this._gBufferRenderPass.renderPass(renderer);
        }
        if (this._passUpdateStates.updateGroundReflection) {
            this._groundReflectionPass.renderPass(renderer);
        }
        if (this._passUpdateStates.updateScreenSpaceShadow) {
            this._screenSpaceShadowMapPass.renderPass(renderer);
        }
        if (this._passUpdateStates.updateShadowAndAoPass) {
            this._shadowAndAoPass.renderPass(renderer);
        }
        if (this._passUpdateStates.updateOutlinePass) {
            (_a = this._outlinePass) === null || _a === void 0 ? void 0 : _a.renderPass(renderer);
        }
        if (this._passUpdateStates.updateDebugPass) {
            (_b = this._debugPass) === null || _b === void 0 ? void 0 : _b.renderPass(renderer);
        }
    }
}

const QUALITY_LEVELS = {
    HIGHEST: 'highest',
    HIGH: 'high',
    MEDIUM: 'medium',
    LOW: 'low',
};
class SceneRenderer {
    get sceneRenderPass() {
        return this._renderPassManager.sceneRenderPass;
    }
    get bakedGroundContactShadowPass() {
        return this._renderPassManager.bakedGroundContactShadowPass;
    }
    get gBufferRenderPass() {
        return this._renderPassManager.gBufferRenderPass;
    }
    get groundReflectionPass() {
        return this._renderPassManager.groundReflectionPass;
    }
    get screenSpaceShadowMapPass() {
        return this._renderPassManager.screenSpaceShadowMapPass;
    }
    get shadowAndAoPass() {
        return this._renderPassManager.shadowAndAoPass;
    }
    get debugPass() {
        return this._renderPassManager.debugPass;
    }
    get shadowAndAoGroundPlane() {
        return this._shadowAndAoGroundPlane;
    }
    constructor(renderer, width, height) {
        this.debugOutput = 'off';
        this.outputColorSpace = '';
        this.toneMapping = '';
        this.environmentLights = false;
        this.movingCamera = false;
        this.groundLevel = 0;
        this.uiInteractionMode = false;
        this.width = 0;
        this.height = 0;
        this.boundingVolume = new SceneVolume();
        this.boundingVolumeSet = false;
        this.renderCacheManager = new RenderCacheManager();
        this.selectedObjects = [];
        this.groundGroup = new Group();
        this._shadingType = SCENE_SHADING_TYPES.DEFAULT;
        this._qualityLevel = QUALITY_LEVELS.HIGHEST;
        this._qualityMap = new Map();
        this.width = width;
        this.height = height;
        this.renderer = renderer;
        this.renderCacheManager.registerCache('inivisibleGround', new VisibilityRenderCache((object) => {
            return object === this.groundGroup;
        }));
        this.renderCacheManager.registerCache('debug', new VisibilityRenderCache());
        this.renderCacheManager.registerCache('floorDepthWrite', new DepthWriteRenderCache((mesh) => {
            var _a;
            return (_a = mesh.userData) === null || _a === void 0 ? void 0 : _a.isFloor;
        }));
        this._shadowAndAoGroundPlane = new ShadowGroundPlane(null);
        this.groundGroup.rotateX(-Math.PI / 2);
        this._renderPassManager = new RenderPassManager(this);
        this.outlineRenderer = new OutlineRenderer(this._renderPassManager, null, {});
        this.parameters = {
            gBufferRenderTargetParameters: this.gBufferRenderPass.parameters,
            bakedGroundContactShadowParameters: this.bakedGroundContactShadowPass.parameters,
            screenSpaceShadowMapParameters: this.screenSpaceShadowMapPass.parameters,
            shAndAoPassParameters: this.shadowAndAoPass.parameters,
            groundReflectionParameters: this.groundReflectionPass.parameters,
            outlineParameters: this.outlineRenderer.parameters,
            effectSuspendFrames: 0,
            effectFadeInFrames: 0,
            suspendGroundReflection: false,
            shadowOnCameraChange: SHADOW_BLUR_TYPES.OFF,
        };
        this._addEventListeners(this.renderer);
    }
    _addEventListeners(renderer) {
        renderer.domElement.addEventListener('webglcontextlost', () => {
            console.log('webglcontextlost');
        });
        renderer.domElement.addEventListener('webglcontextrestored', () => {
            console.log('webglcontextrestored');
            this._forceEnvironmentMapUpdate(this.renderer);
        });
    }
    dispose() {
        var _a;
        (_a = this._copyMaterial) === null || _a === void 0 ? void 0 : _a.dispose();
        this._renderPassManager.dispose();
        this.renderer.dispose();
    }
    setSize(width, height) {
        this.width = width;
        this.height = height;
        this._renderPassManager.setSize(width, height);
        this.renderer.setSize(width, height);
    }
    getQualityLevel() {
        return this._qualityLevel;
    }
    setShadingType(shadingType) {
        if (this._shadingType === shadingType) {
            return;
        }
        this._shadingType = shadingType;
        this.applyCurrentParameters();
    }
    setQualityLevel(_qualityLevel) {
        if (this._qualityLevel === _qualityLevel) {
            return;
        }
        if (this._qualityMap.has(this._qualityLevel)) {
            this._qualityLevel = _qualityLevel;
        }
        this.applyCurrentParameters();
    }
    setQualityMap(_qualityMap) {
        this._qualityMap = _qualityMap;
        this.applyCurrentParameters();
    }
    applyCurrentParameters() {
        let parameterArray = [];
        if (this._qualityMap.has(this._qualityLevel)) {
            parameterArray.push(this._qualityMap.get(this._qualityLevel));
        }
        const shadingTypeParameters = getShadingParameters(this._shadingType);
        if (shadingTypeParameters) {
            parameterArray.push(shadingTypeParameters);
        }
        const uiInteractionParameters = getInteractionParameters(this.uiInteractionMode);
        if (uiInteractionParameters) {
            parameterArray.push(uiInteractionParameters);
        }
        if (parameterArray.length > 0) {
            const parameters = mergeRendererParameters(...parameterArray);
            this.updateParameters(parameters);
            this.bakedGroundContactShadowPass.applyParameters();
        }
    }
    clearCache() {
        this.renderCacheManager.clearCache();
    }
    forceShadowUpdates(updateBakedGroundShadow) {
        this.clearCache();
        this.gBufferRenderPass.needsUpdate = true;
        this.screenSpaceShadowMapPass.forceShadowUpdate();
        this.shadowAndAoPass.needsUpdate = true;
        if (updateBakedGroundShadow) {
            this.bakedGroundContactShadowPass.needsUpdate = true;
        }
    }
    updateParameters(parameters) {
        if (parameters.shadowType) {
            this.screenSpaceShadowMapPass.switchType(parameters.shadowType);
        }
        if (parameters.shAndAoPassParameters !== undefined) {
            this.shadowAndAoPass.updateParameters(parameters.shAndAoPassParameters);
        }
        if (parameters.bakedGroundContactShadowParameters !== undefined) {
            this.bakedGroundContactShadowPass.updateParameters(parameters.bakedGroundContactShadowParameters);
        }
        if (parameters.screenSpaceShadowMapParameters !== undefined) {
            this.screenSpaceShadowMapPass.updateParameters(parameters.screenSpaceShadowMapParameters);
        }
        if (parameters.groundReflectionParameters !== undefined) {
            this.groundReflectionPass.updateParameters(parameters.groundReflectionParameters);
        }
        if (parameters.outlineParameters !== undefined) {
            this.outlineRenderer.updateParameters(parameters.outlineParameters);
        }
        if (parameters.effectSuspendFrames !== undefined) {
            this.parameters.effectSuspendFrames = parameters.effectSuspendFrames;
        }
        if (parameters.effectFadeInFrames !== undefined) {
            this.parameters.effectFadeInFrames = parameters.effectFadeInFrames;
        }
        if (parameters.suspendGroundReflection !== undefined) {
            this.parameters.suspendGroundReflection =
                parameters.suspendGroundReflection;
        }
        if (parameters.shadowOnCameraChange !== undefined) {
            this.parameters.shadowOnCameraChange = parameters.shadowOnCameraChange;
        }
    }
    addRectAreaLight(rectAreaLight, parent) {
        this.environmentLights = false;
        this.screenSpaceShadowMapPass.addRectAreaLight(rectAreaLight, parent);
        this.shadowAndAoPass.needsUpdate = true;
    }
    setCameraType(cameraType) {
        this._cameraType = cameraType;
    }
    updateRectAreaLights(rectAreaLights, parent) {
        if (rectAreaLights.length > 0) {
            this.environmentLights = false;
        }
        this.screenSpaceShadowMapPass.updateRectAreaLights(rectAreaLights, parent);
        this.shadowAndAoPass.needsUpdate = true;
    }
    createShadowFromLightSources(parent, lightSources) {
        this.environmentLights = true;
        this.screenSpaceShadowMapPass.createShadowFromLightSources(parent, lightSources);
        this.shadowAndAoPass.needsUpdate = true;
    }
    selectObjects(selectedObjects) {
        this.selectedObjects = selectedObjects;
    }
    updateBounds(bounds, scaleShadowAndAo) {
        this.clearCache();
        const sceneBounds = bounds.clone();
        if (sceneBounds.min.y > this.groundLevel) {
            sceneBounds.min.y = this.groundLevel;
        }
        this.boundingVolumeSet = true;
        this.gBufferRenderPass.groundDepthWrite =
            this.shadowAndAoPass.parameters.aoOnGround;
        this.boundingVolume.updateFromBox(sceneBounds);
        const size = this.boundingVolume.size;
        const shadowAndAoScale = (size.x + size.y + size.z) / 3;
        const minBoundsSize = Math.min(size.x, size.y, size.z);
        const maxBoundsSize = Math.max(size.x, size.y, size.z);
        const defaultScale = minBoundsSize < 0.5 ? minBoundsSize / 0.5 : size.z > 5 ? size.z / 5 : 1;
        this.bakedGroundContactShadowPass.setScale(scaleShadowAndAo ? shadowAndAoScale : defaultScale, shadowAndAoScale);
        this.groundReflectionPass.updateBounds(this.groundLevel, Math.min(1, maxBoundsSize));
        this.screenSpaceShadowMapPass.updateBounds(this.boundingVolume, shadowAndAoScale);
        this.shadowAndAoPass.updateBounds(this.boundingVolume, scaleShadowAndAo ? shadowAndAoScale : Math.min(1, maxBoundsSize * 2));
    }
    updateNearAndFarPlaneOfPerspectiveCamera(camera, minimumFar) {
        // bring the near and far plane as close as possible to geometry
        // this is very likely the most important part for a glitch free and nice SSAO
        const nearFar = this.boundingVolume.getNearAndFarForPerspectiveCamera(camera.position, 3);
        camera.near = Math.max(0.00001, nearFar[0] * 0.9);
        camera.far = Math.max(minimumFar !== null && minimumFar !== void 0 ? minimumFar : camera.near, nearFar[1]);
        camera.updateProjectionMatrix();
    }
    _forceEnvironmentMapUpdate(renderer) {
        const rendererUserData = renderer.userData;
        if (rendererUserData === null || rendererUserData === void 0 ? void 0 : rendererUserData.environmentTexture) {
            const environmentTexture = rendererUserData.environmentTexture;
            rendererUserData.environmentTexture = undefined;
            environmentTexture.dispose();
        }
    }
    _updateEnvironment(renderer, scene) {
        var _a, _b;
        if (!((_a = scene.userData) === null || _a === void 0 ? void 0 : _a.environmentDefinition)) {
            return;
        }
        if (!renderer.userData) {
            renderer.userData = {};
        }
        const rendererUserData = renderer.userData;
        if (rendererUserData &&
            (((_b = scene.userData) === null || _b === void 0 ? void 0 : _b.environmentDefinition.needsUpdate) ||
                !rendererUserData.environmentTexture ||
                rendererUserData.environmentDefinition !==
                    scene.userData.environmentDefinition)) {
            const environmentDefinition = scene.userData.environmentDefinition;
            rendererUserData.environmentDefinition = environmentDefinition;
            rendererUserData.environmentTexture =
                environmentDefinition.createNewEnvironment(renderer);
            if (scene.userData.shadowFromEnvironment) {
                const maxNoOfLightSources = environmentDefinition.maxNoOfLightSources;
                if (maxNoOfLightSources !== undefined) {
                    this.screenSpaceShadowMapPass.parameters.maximumNumberOfLightSources =
                        maxNoOfLightSources;
                }
                this.createShadowFromLightSources(scene, environmentDefinition.lightSources);
            }
        }
        scene.environment = rendererUserData === null || rendererUserData === void 0 ? void 0 : rendererUserData.environmentTexture;
        if (scene.userData.showEnvironmentBackground) {
            scene.background = scene.environment;
        }
        else if (scene.background === scene.environment) {
            scene.background = null;
        }
    }
    render(scene, camera) {
        scene.add(this.groundGroup);
        this._updateEnvironment(this.renderer, scene);
        this.outlineRenderer.updateOutline(scene, camera, this.movingCamera || this._cameraType === CAMERA_TYPE.CAMERA_FP
            ? []
            : this.selectedObjects);
        this._renderPassManager.updatePasses(scene, camera);
        this._renderPassManager.renderPasses(this.renderer);
        scene.remove(this.groundGroup);
    }
}

class SceneRendererGUI {
    constructor(sceneRenderer) {
        this._qualityLevel = '';
        this._ambientOcclusionType = '';
        this._sceneRenderer = sceneRenderer;
    }
    addGUI(gui, updateCallback) {
        this._addRepresentationalGUI(gui, updateCallback);
        this._addDebugGUI(gui, updateCallback);
        const shadowTypeFolder = gui.addFolder('Shadow type');
        this._addShadowTypeGUI(shadowTypeFolder, updateCallback);
        const shadowAndAoFolder = gui.addFolder('Shadow and Ambient Occlusion');
        this._addShadowAndAoGUI(shadowAndAoFolder, updateCallback);
        const groundReflectionFolder = gui.addFolder('Ground Reflection');
        this._addGroundReflectionGUI(groundReflectionFolder, updateCallback);
        const bakedGroundContactShadowFolder = gui.addFolder('Baked Ground Contact Shadow');
        this._addBakedGroundContactShadowGUI(bakedGroundContactShadowFolder, updateCallback);
        const outlineFolder = gui.addFolder('Outline');
        this._addOutlineGUI(outlineFolder, updateCallback);
    }
    _addRepresentationalGUI(gui, updateCallback) {
        const outputColorSpaces = new Map([
            ['LinearSRGBColorSpace', LinearSRGBColorSpace],
            ['SRGBColorSpace', SRGBColorSpace],
        ]);
        const outputColorSpaceNames = [];
        outputColorSpaces.forEach((value, key) => {
            outputColorSpaceNames.push(key);
            if (this._sceneRenderer.renderer.outputColorSpace === value) {
                this._sceneRenderer.outputColorSpace = key;
            }
        });
        gui
            .add(this._sceneRenderer, 'outputColorSpace', outputColorSpaceNames)
            .onChange((colorSpace) => {
            var _a;
            if (outputColorSpaces.has(colorSpace)) {
                this._sceneRenderer.renderer.outputColorSpace =
                    (_a = outputColorSpaces.get(colorSpace)) !== null && _a !== void 0 ? _a : SRGBColorSpace;
                updateCallback();
            }
        });
        const toneMappings = new Map([
            ['NoToneMapping', NoToneMapping],
            ['LinearToneMapping', LinearToneMapping],
            ['ReinhardToneMapping', ReinhardToneMapping],
            ['CineonToneMapping', CineonToneMapping],
            ['ACESFilmicToneMapping', ACESFilmicToneMapping],
        ]);
        const toneMappingNames = [];
        toneMappings.forEach((value, key) => {
            toneMappingNames.push(key);
            if (this._sceneRenderer.renderer.toneMapping === value) {
                this._sceneRenderer.toneMapping = key;
            }
        });
        gui
            .add(this._sceneRenderer, 'toneMapping', toneMappingNames)
            .onChange((toneMapping) => {
            var _a;
            if (toneMappings.has(toneMapping)) {
                this._sceneRenderer.renderer.toneMapping =
                    (_a = toneMappings.get(toneMapping)) !== null && _a !== void 0 ? _a : NoToneMapping;
                updateCallback();
            }
        });
    }
    _addDebugGUI(gui, updateCallback) {
        const qualityLevels = new Map([
            ['HIGHEST', QUALITY_LEVELS.HIGHEST],
            ['HIGH', QUALITY_LEVELS.HIGH],
            ['MEDIUM', QUALITY_LEVELS.MEDIUM],
            ['LOW', QUALITY_LEVELS.LOW],
        ]);
        const outputQualityNames = [];
        qualityLevels.forEach((value, key) => outputQualityNames.push(key));
        gui
            .add(this, '_qualityLevel', outputQualityNames)
            .onChange((qualityLevel) => {
            var _a;
            if (qualityLevels.has(qualityLevel)) {
                this._sceneRenderer.setQualityLevel((_a = qualityLevels.get(qualityLevel)) !== null && _a !== void 0 ? _a : QUALITY_LEVELS.HIGHEST);
            }
        });
        gui
            .add(this._sceneRenderer, 'debugOutput', {
            'off ': 'off',
            'grayscale (no textures)': 'grayscale',
            'color buffer': 'color',
            'linear depth': 'lineardepth',
            'g-buffer normal vector': 'g-normal',
            'g-buffer depth': 'g-depth',
            'AO pure': 'ssao',
            'AO denoised': 'ssaodenoise',
            'shadow map': 'shadowmap',
            'shadow soft': 'shadowsoft',
            'shadow denoised': 'shadowdenoise',
            'shadow fade in': 'shadowfadein',
            'shadow and AO': 'shadowandao',
            'ground reflection': 'groundreflection',
            'baked ground shadow': 'bakedgroundshadow',
            'selection outline': 'outline',
            'environment map': 'environmentmap',
            'light source detection': 'lightsourcedetection',
        })
            .onChange(() => updateCallback());
    }
    _addShadowTypeGUI(gui, updateCallback) {
        const shadowConfiguration = this._sceneRenderer.screenSpaceShadowMapPass.shadowConfiguration;
        const shadowMapNames = [];
        shadowConfiguration.types.forEach((_, key) => {
            shadowMapNames.push(key);
        });
        const updateShadow = () => {
            this._sceneRenderer.screenSpaceShadowMapPass.needsUpdate = true;
            this._sceneRenderer.screenSpaceShadowMapPass.shadowTypeNeedsUpdate = true;
            this._sceneRenderer.shadowAndAoPass.needsUpdate = true;
            updateCallback();
        };
        gui
            .add(shadowConfiguration, 'shadowType', shadowMapNames)
            .onChange((type) => {
            if (this._sceneRenderer.screenSpaceShadowMapPass.switchType(type)) {
                shadowBiasController.object =
                    shadowConfiguration.currentConfiguration;
                shadowNormalBiasController.object =
                    shadowConfiguration.currentConfiguration;
                shadowRadiusController.object =
                    shadowConfiguration.currentConfiguration;
                shadowBiasController.updateDisplay();
                shadowNormalBiasController.updateDisplay();
                shadowRadiusController.updateDisplay();
                updateShadow();
            }
        });
        const shadowBiasController = gui
            .add(shadowConfiguration.currentConfiguration, 'bias', -0.001, 0.001, 0.00001)
            .onChange(() => updateShadow());
        const shadowNormalBiasController = gui
            .add(shadowConfiguration.currentConfiguration, 'normalBias', -0.05, 0.05)
            .onChange(() => updateShadow());
        const shadowRadiusController = gui
            .add(shadowConfiguration.currentConfiguration, 'radius', 0, 100)
            .onChange(() => updateShadow());
    }
    _addShadowAndAoGUI(gui, updateCallback) {
        const updateParameters = () => {
            this._sceneRenderer.gBufferRenderPass.needsUpdate = true;
            this._sceneRenderer.screenSpaceShadowMapPass.needsUpdate = true;
            this._sceneRenderer.shadowAndAoPass.needsUpdate = true;
            this._sceneRenderer.shadowAndAoPass.softShadowPass.needsUpdate = true;
            updateCallback();
        };
        const parameters = this._sceneRenderer.shadowAndAoPass.parameters;
        const shadowParameters = parameters.shadow;
        const shadowMapParameters = this._sceneRenderer.screenSpaceShadowMapPass.parameters;
        const aoParameters = parameters.ao;
        const denoiseParameters = parameters.poissonDenoise;
        gui.add(parameters, 'enabled').onChange(() => updateParameters());
        const aoTypes = new Map([
            ['none', null],
            ['SSAO', AO_ALGORITHMS.SSAO],
            ['SAO', AO_ALGORITHMS.SAO],
            ['N8AO', AO_ALGORITHMS.N8AO],
            ['HBAO', AO_ALGORITHMS.HBAO],
            ['GTAO', AO_ALGORITHMS.GTAO],
        ]);
        const aoNames = Array.from(aoTypes.keys());
        aoTypes.forEach((value, key) => {
            if (value === aoParameters.algorithm) {
                this._ambientOcclusionType = key;
            }
        });
        gui.add(parameters, 'aoIntensity', 0, 1).onChange(() => {
            updateParameters();
        });
        gui.add(parameters, 'aoOnGround').onChange(() => {
            updateParameters();
            this._sceneRenderer.clearCache();
        });
        gui.add(parameters, 'shadowOnGround').onChange(() => {
            updateParameters();
            this._sceneRenderer.clearCache();
        });
        gui
            .add(parameters, 'shadowIntensity', 0, 1)
            .onChange(() => updateParameters());
        gui.add(parameters, 'alwaysUpdate').onChange(() => updateParameters());
        gui
            .add(parameters, 'progressiveDenoiseIterations', 0, 3, 1)
            .onChange(() => updateParameters());
        const shFolder = gui.addFolder('Environment Shadow');
        shFolder
            .add(shadowMapParameters, 'maximumNumberOfLightSources', -1, 10, 1)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'enableGroundBoundary')
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'directionalDependency', 0.0, 1.0, 0.01)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'directionalExponent', 0.0, 2.0, 0.01)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'groundBoundary', 0.0, 1.0, 0.01)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'fadeOutDistance', 0.0, 5.0, 0.01)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowMapParameters, 'fadeOutBlur', 0.0, 20.0, 1.0)
            .onChange(() => updateParameters());
        shFolder
            .add(shadowParameters, 'shadowRadius', 0.001, 0.5)
            .onChange(() => updateParameters());
        const aoFolder = gui.addFolder('AO');
        aoFolder
            .add(this, '_ambientOcclusionType', aoNames)
            .onChange((aoType) => {
            if (aoTypes.has(aoType)) {
                const type = aoTypes.get(aoType);
                aoParameters.algorithm =
                    type !== undefined ? type : AO_ALGORITHMS.SSAO;
                updateParameters();
            }
        });
        aoFolder
            .add(aoParameters, 'samples', 1, 64, 1)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'radius', 0.01, 2, 0.01)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'distanceExponent', 0.1, 4, 0.1)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'thickness', 0.01, 2, 0.01)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'distanceFallOff', 0, 1)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'scale', 0.01, 2, 0.01)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'bias', 0.0001, 0.01, 0.0001)
            .onChange(() => updateParameters());
        aoFolder
            .add(aoParameters, 'screenSpaceRadius')
            .onChange(() => updateParameters());
        const denoiseFolder = gui.addFolder('Possion Denoise');
        denoiseFolder
            .add(denoiseParameters, 'iterations', 0, 4, 1)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'samples', 0, 32, 1)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'rings', 0, 16, 0.125)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'radiusExponent', 0.1, 4, 0.01)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'radius', 0, 50, 1)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'lumaPhi', 0, 20, 0.001)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'depthPhi', 0, 20, 0.001)
            .onChange(() => updateParameters());
        denoiseFolder
            .add(denoiseParameters, 'normalPhi', 0, 20, 0.001)
            .onChange(() => updateParameters());
    }
    _addGroundReflectionGUI(gui, updateCallback) {
        const parameters = this._sceneRenderer.parameters.groundReflectionParameters;
        gui.add(parameters, 'enabled');
        gui
            .add(parameters, 'intensity', 0.0, 1.0)
            .onChange(() => updateCallback());
        gui
            .add(parameters, 'fadeOutDistance', 0.0, 4.0)
            .onChange(() => updateCallback());
        gui
            .add(parameters, 'fadeOutExponent', 0.1, 10.0)
            .onChange(() => updateCallback());
        gui
            .add(parameters, 'brightness', 0.0, 2.0)
            .onChange(() => updateCallback());
        gui
            .add(parameters, 'blurHorizontal', 0.0, 10.0)
            .onChange(() => updateCallback());
        gui
            .add(parameters, 'blurVertical', 0.0, 10.0)
            .onChange(() => updateCallback());
    }
    _addBakedGroundContactShadowGUI(gui, updateCallback) {
        const updateParameters = () => {
            this._sceneRenderer.bakedGroundContactShadowPass.applyParameters();
            updateCallback();
        };
        const parameters = this._sceneRenderer.parameters.bakedGroundContactShadowParameters;
        gui.add(parameters, 'enabled');
        gui.add(parameters, 'cameraHelper').onChange(() => updateParameters());
        gui.add(parameters, 'alwaysUpdate');
        gui.add(parameters, 'fadeIn');
        gui
            .add(parameters, 'blurMin', 0, 0.2, 0.001)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'blurMax', 0, 0.5, 0.01)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'fadeoutFalloff', 0.0, 1.0, 0.01)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'fadeoutBias', 0.0, 0.5)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'opacity', 0, 1, 0.01)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'maximumPlaneSize', 0, 50, 1)
            .onChange(() => updateParameters());
        gui
            .add(parameters, 'cameraFar', 0.1, 10, 0.1)
            .onChange(() => updateParameters());
    }
    _addOutlineGUI(gui, updateCallback) {
        const updateOutlineParameters = () => {
            this._sceneRenderer.outlineRenderer.applyParameters();
            updateCallback();
        };
        const parameters = this._sceneRenderer.outlineRenderer.parameters;
        gui.add(parameters, 'enabled');
        gui
            .add(parameters, 'edgeStrength', 0.5, 20)
            .onChange(() => updateOutlineParameters());
        gui
            .add(parameters, 'edgeGlow', 0, 20)
            .onChange(() => updateOutlineParameters());
        gui
            .add(parameters, 'edgeThickness', 0.5, 20)
            .onChange(() => updateOutlineParameters());
        gui
            .add(parameters, 'pulsePeriod', 0, 5)
            .onChange(() => updateOutlineParameters());
        gui
            .addColor(parameters, 'visibleEdgeColor')
            .onChange(() => updateOutlineParameters());
        gui
            .addColor(parameters, 'hiddenEdgeColor')
            .onChange(() => updateOutlineParameters());
    }
}

const noEffectsSuspension = {
    effectSuspendFrames: 0,
    effectFadeInFrames: 0,
    suspendGroundReflection: false,
    shadowOnCameraChange: SHADOW_BLUR_TYPES.FULL,
};
const partialEffectsSuspension = {
    effectSuspendFrames: 5,
    effectFadeInFrames: 5,
    suspendGroundReflection: false,
    shadowOnCameraChange: SHADOW_BLUR_TYPES.POISSON,
};
const fullEffectsSuspension = {
    effectSuspendFrames: 5,
    effectFadeInFrames: 5,
    suspendGroundReflection: true,
    shadowOnCameraChange: SHADOW_BLUR_TYPES.POISSON,
};
const configuratorAoSettings = {
    algorithm: AO_ALGORITHMS.SSAO,
    samples: 32,
    radius: 0.15,
    distanceExponent: 2,
    thickness: 0.25,
    distanceFallOff: 1,
    bias: 0.01,
};
const configuratorDenoiseSettings = {
    iterations: 2,
    samples: 16,
    radius: 5,
    radiusExponent: 1,
    lumaPhi: 10,
    depthPhi: 2,
    normalPhi: 4,
};
const plannerAoSettings = {
    algorithm: AO_ALGORITHMS.N8AO,
    samples: 16,
    radius: 0.5,
    distanceExponent: 2,
    thickness: 0.5,
    distanceFallOff: 1,
    bias: 0.01,
};
const plannerDenoiseSettings = {
    iterations: 2,
    samples: 16,
    radius: 5,
    radiusExponent: 1,
    lumaPhi: 10,
    depthPhi: 2,
    normalPhi: 4,
};
const standaloneConfiguratorQualityLevels = new Map([
    [
        QUALITY_LEVELS.HIGHEST,
        {
            ...noEffectsSuspension,
            shAndAoPassParameters: {
                enabled: true,
                aoOnGround: true,
                shadowOnGround: true,
                ao: configuratorAoSettings,
                poissonDenoise: configuratorDenoiseSettings,
            },
            groundReflectionParameters: {
                enabled: true,
            },
            bakedGroundContactShadowParameters: {
                enabled: false,
            },
        },
    ],
    [
        QUALITY_LEVELS.HIGH,
        {
            ...partialEffectsSuspension,
            shAndAoPassParameters: {
                enabled: true,
                aoOnGround: true,
                shadowOnGround: true,
                ao: configuratorAoSettings,
                poissonDenoise: configuratorDenoiseSettings,
            },
            groundReflectionParameters: {
                enabled: true,
            },
            bakedGroundContactShadowParameters: {
                enabled: false,
            },
        },
    ],
    [
        QUALITY_LEVELS.MEDIUM,
        {
            ...fullEffectsSuspension,
            shAndAoPassParameters: {
                enabled: true,
                aoOnGround: true,
                shadowOnGround: true,
                ao: configuratorAoSettings,
                poissonDenoise: configuratorDenoiseSettings,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: {
                enabled: false,
            },
        },
    ],
    [
        QUALITY_LEVELS.LOW,
        {
            shAndAoPassParameters: {
                enabled: false,
                aoOnGround: false,
                shadowOnGround: false,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: {
                enabled: true,
            },
        },
    ],
]);
const screenSpaceShadowLayers = new Layers();
screenSpaceShadowLayers.enable(3 /* LAYER.OBJECT */);
const bakedGroundShadowHardLayers = new Layers();
bakedGroundShadowHardLayers.disableAll();
bakedGroundShadowHardLayers.enable(9 /* LAYER.CONSTRUCTION */);
const aoConfiguratorParameters = {
    enabled: true,
    aoIntensity: 0.5,
    shadowIntensity: 0,
    aoOnGround: true,
    shadowOnGround: false,
    ao: configuratorAoSettings,
    poissonDenoise: configuratorDenoiseSettings,
};
const aoPlan3dParameters = {
    enabled: true,
    aoIntensity: 0.5,
    shadowIntensity: 0,
    aoOnGround: true,
    shadowOnGround: false,
    ao: plannerAoSettings,
    poissonDenoise: plannerDenoiseSettings,
};
const aoPlan2dParameters = aoPlan3dParameters;
const bakedGroundContactConfiguratorParameters = {
    enabled: true,
    fadeoutFalloff: 0.9,
    blurMax: 0.1,
    opacity: 0.5,
    hardLayers: null,
    softLayers: null,
    polygonOffset: 2,
};
const bakedGroundContactPlan3dParameters = {
    enabled: true,
    fadeoutFalloff: 0.8,
    blurMax: 0.15,
    opacity: 0.5,
    hardLayers: bakedGroundShadowHardLayers,
    softLayers: null,
    polygonOffset: -1,
};
const bakedGroundContactPlan2dParameters = {
    enabled: false,
};
const plannerConfiguratorQualityLevels = new Map([
    [
        QUALITY_LEVELS.HIGHEST,
        {
            ...noEffectsSuspension,
            shAndAoPassParameters: aoConfiguratorParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: true,
            },
            bakedGroundContactShadowParameters: bakedGroundContactConfiguratorParameters,
        },
    ],
    [
        QUALITY_LEVELS.HIGH,
        {
            ...partialEffectsSuspension,
            shAndAoPassParameters: aoConfiguratorParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: true,
            },
            bakedGroundContactShadowParameters: bakedGroundContactConfiguratorParameters,
        },
    ],
    [
        QUALITY_LEVELS.MEDIUM,
        {
            ...fullEffectsSuspension,
            shAndAoPassParameters: aoConfiguratorParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: true,
            },
            bakedGroundContactShadowParameters: bakedGroundContactConfiguratorParameters,
        },
    ],
    [
        QUALITY_LEVELS.LOW,
        {
            shAndAoPassParameters: {
                enabled: false,
                aoOnGround: false,
                shadowOnGround: false,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactConfiguratorParameters,
        },
    ],
]);
const planner3dQualityLevels = new Map([
    [
        QUALITY_LEVELS.HIGHEST,
        {
            ...noEffectsSuspension,
            shAndAoPassParameters: aoPlan3dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan3dParameters,
        },
    ],
    [
        QUALITY_LEVELS.HIGH,
        {
            ...partialEffectsSuspension,
            shAndAoPassParameters: aoPlan3dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan3dParameters,
        },
    ],
    [
        QUALITY_LEVELS.MEDIUM,
        {
            ...fullEffectsSuspension,
            shAndAoPassParameters: aoPlan3dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan3dParameters,
        },
    ],
    [
        QUALITY_LEVELS.LOW,
        {
            shAndAoPassParameters: {
                enabled: false,
                aoOnGround: false,
                shadowOnGround: false,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan3dParameters,
        },
    ],
]);
const planner2dQualityLevels = new Map([
    [
        QUALITY_LEVELS.HIGHEST,
        {
            ...noEffectsSuspension,
            shAndAoPassParameters: aoPlan2dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan2dParameters,
        },
    ],
    [
        QUALITY_LEVELS.HIGH,
        {
            ...partialEffectsSuspension,
            shAndAoPassParameters: aoPlan2dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan2dParameters,
        },
    ],
    [
        QUALITY_LEVELS.MEDIUM,
        {
            ...fullEffectsSuspension,
            shAndAoPassParameters: aoPlan2dParameters,
            screenSpaceShadowMapParameters: {
                layers: screenSpaceShadowLayers,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan2dParameters,
        },
    ],
    [
        QUALITY_LEVELS.LOW,
        {
            shAndAoPassParameters: {
                enabled: false,
                aoOnGround: false,
                shadowOnGround: false,
            },
            groundReflectionParameters: {
                enabled: false,
            },
            bakedGroundContactShadowParameters: bakedGroundContactPlan2dParameters,
        },
    ],
]);

const FPS_LIST_SIZE = 2;
class FpsCounter {
    constructor() {
        this._index = 0;
        this._prevTime = 0;
        this._frames = 0;
        this._fps = -1;
        this._fpsList = Array(FPS_LIST_SIZE).fill(0);
        this._prevTime = (performance || Date).now();
        this.reset();
    }
    update() {
        this._frames++;
        const time = (performance || Date).now();
        if (time >= this._prevTime + 1000) {
            this._fpsList[this._index % FPS_LIST_SIZE] =
                (this._frames * 1000) / (time - this._prevTime);
            if (this._index >= FPS_LIST_SIZE) {
                this._fps =
                    this._fpsList.reduce((pv, cv) => (pv += cv)) / this._fpsList.length;
            }
            this._prevTime = time;
            this._frames = 0;
            this._index++;
        }
    }
    start() {
        this._prevTime = (performance || Date).now();
        this._frames = 0;
    }
    reset() {
        this._fps = -1;
        this._fpsList = Array(FPS_LIST_SIZE).fill(0);
        this._index = 0;
    }
    getFps() {
        return this._fps;
    }
}

var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["Mode3D"] = 0] = "Mode3D";
    RenderMode[RenderMode["Mode2D"] = 1] = "Mode2D";
})(RenderMode || (RenderMode = {}));
class RoomleWebGLRenderer {
    get renderer() {
        return this._renderer;
    }
    get sceneRenderer() {
        return this._sceneRenderer;
    }
    get screenSpaceShadowParameters() {
        return this.sceneRenderer.screenSpaceShadowMapPass.parameters;
    }
    get shadowAndAoPassParameters() {
        return this._sceneRenderer.shadowAndAoPass.parameters;
    }
    get bakedGroundContactShadowParameters() {
        return this.sceneRenderer.bakedGroundContactShadowPass.parameters;
    }
    get groundReflectionParameters() {
        return this._sceneRenderer.groundReflectionPass.parameters;
    }
    get outlineParameters() {
        return this._sceneRenderer.outlineRenderer.parameters;
    }
    constructor(renderer, width, height) {
        this.configuratorMode = true;
        this.uiInteractionMode = true;
        this._renderer = renderer;
        this._sceneRenderer = new SceneRenderer(this._renderer, width, height);
        this.outlineParameters.enabled = true;
        this.outlineParameters.edgeStrength = 2.0;
        this.outlineParameters.edgeGlow = 1.0;
        this.outlineParameters.edgeThickness = 2.0;
        this.outlineParameters.pulsePeriod = 0;
        this.outlineParameters.usePatternTexture = false;
        this.outlineParameters.visibleEdgeColor = 0xffffff; // 0xdb0000,
        this.outlineParameters.hiddenEdgeColor = 0xffffff; // 0xdb0000,
        if (RoomleWebGLRenderer.enableRectAreaLightShadow) {
            DynamicLightSettingLoader.rectAreaLightReplacement = false;
            DynamicLightSettingLoader.rectAreaLightLoadingListener =
                this.loadRectAreLight;
        }
        this.sceneRenderer.setQualityLevel(QUALITY_LEVELS.HIGHEST);
        this.SceneRendererGUI = new SceneRendererGUI(this.sceneRenderer);
    }
    dispose() {
        this._sceneRenderer.dispose();
    }
    setSize(width, height) {
        this._sceneRenderer.setSize(width, height);
    }
    setShadingType(shadingType) {
        this.sceneRenderer.setShadingType(shadingType);
    }
    setAutoQuality(autoQuality) {
        if (!this._fpsCounter && autoQuality) {
            this._fpsCounter = new FpsCounter();
        }
        else if (this._fpsCounter && !autoQuality) {
            this._fpsCounter = null;
        }
    }
    setQualityLevel(qualityLevel) {
        this._sceneRenderer.setQualityLevel(qualityLevel);
    }
    setQualityMap(qualityMap) {
        this._sceneRenderer.setQualityMap(qualityMap);
    }
    enableUiInteractionMode() {
        this._sceneRenderer.uiInteractionMode = true;
        this._sceneRenderer.applyCurrentParameters();
    }
    disableUiInteractionMode() {
        this._sceneRenderer.uiInteractionMode = false;
        this._sceneRenderer.applyCurrentParameters();
    }
    loadRectAreLight(_) {
        RoomleWebGLRenderer.rectAreaLightsNeedsUpdate = true;
    }
    updateRectAreaLight(scene) {
        let rectAreaLights = [];
        scene.traverse((child) => {
            if (child instanceof RectAreaLight) {
                rectAreaLights.push(child);
            }
        });
        this._sceneRenderer.updateRectAreaLights(rectAreaLights, scene);
        RoomleWebGLRenderer.rectAreaLightsNeedsUpdate = false;
    }
    clearCache() {
        this._sceneRenderer.clearCache();
    }
    forceShadowUpdates(updateBakedGroundShadow) {
        this._sceneRenderer.forceShadowUpdates(updateBakedGroundShadow);
    }
    switchToConfigurator() {
        // three-refactor - remove after refactoring
        console.log('RENDERER: switch to configurator');
        this.configuratorMode = true;
        this._sceneRenderer.setQualityMap(plannerConfiguratorQualityLevels);
    }
    switchToPlanner(renderMode) {
        // three-refactor - remove after refactoring
        console.log(renderMode === RenderMode.Mode3D
            ? 'RENDERER: switch to planner 3d'
            : 'RENDERER: switch to planner 2d');
        this.configuratorMode = false;
        if (renderMode === RenderMode.Mode3D) {
            this._sceneRenderer.setQualityMap(planner3dQualityLevels);
        }
        else {
            this._sceneRenderer.setQualityMap(planner2dQualityLevels);
        }
    }
    updateBounds(bounds) {
        this._sceneRenderer.updateBounds(bounds, false);
    }
    updateEnvironment(bounds, _force = false) {
        if (bounds) {
            this.updateBounds(bounds);
        }
    }
    movingCameraStarts() {
        var _a;
        this._sceneRenderer.movingCamera = true;
        (_a = this._fpsCounter) === null || _a === void 0 ? void 0 : _a.start();
    }
    movingCameraStops() {
        this._sceneRenderer.movingCamera = false;
    }
    highlightObjects(selectedMeshes) {
        this._sceneRenderer.selectObjects(selectedMeshes);
    }
    render(scene, camera) {
        var _a;
        if (RoomleWebGLRenderer.rectAreaLightsNeedsUpdate) {
            this.updateRectAreaLight(scene);
        }
        camera.updateMatrixWorld();
        if (camera instanceof PerspectiveCamera) {
            camera.updateProjectionMatrix();
        }
        else if (camera instanceof OrthographicCamera) {
            camera.updateProjectionMatrix();
        }
        const renderCamera = RoomleWebGLRenderer.updateNearAndFarPlaneOfPerspectiveCamera
            ? this.createRenderCamera(camera)
            : camera;
        this._sceneRenderer.render(scene, renderCamera);
        if (this._sceneRenderer.movingCamera && this._fpsCounter) {
            (_a = this._fpsCounter) === null || _a === void 0 ? void 0 : _a.update();
            const qualityLevel = this._sceneRenderer.getQualityLevel();
            const fps = this._fpsCounter.getFps();
            if (fps > 0 && fps < 30 && qualityLevel !== QUALITY_LEVELS.LOW) {
                console.log(`fps at ${fps}, setting quality level to ${qualityLevel + 1}`);
                if (qualityLevel === QUALITY_LEVELS.HIGHEST) {
                    this.sceneRenderer.setQualityLevel(QUALITY_LEVELS.HIGH);
                }
                else if (qualityLevel === QUALITY_LEVELS.HIGH) {
                    this.sceneRenderer.setQualityLevel(QUALITY_LEVELS.MEDIUM);
                }
                else if (qualityLevel === QUALITY_LEVELS.MEDIUM) {
                    this.sceneRenderer.setQualityLevel(QUALITY_LEVELS.LOW);
                }
                this._fpsCounter.reset();
            }
        }
    }
    createRenderCamera(camera) {
        const renderCamera = camera.clone();
        if (this.configuratorMode && renderCamera instanceof PerspectiveCamera) {
            this._sceneRenderer.updateNearAndFarPlaneOfPerspectiveCamera(renderCamera, 120);
            renderCamera.updateProjectionMatrix();
        }
        return renderCamera;
    }
    showGUI(updateCallback) {
        const gui = getGUI();
        this.SceneRendererGUI.addGUI(gui, updateCallback);
    }
    clear() {
        this.renderer.clear();
    }
}
RoomleWebGLRenderer.enableRectAreaLightShadow = true;
RoomleWebGLRenderer.rectAreaLightsNeedsUpdate = false;
RoomleWebGLRenderer.updateNearAndFarPlaneOfPerspectiveCamera = false;

const DEFAULT_SIZE = 1024;
class ImageRenderer {
    _getRoomleRenderer(e2e = false) {
        if (!this._roomleRenderer) {
            const imageRenderer = new WebGLRenderer({ antialias: !e2e, alpha: true });
            imageRenderer.outputColorSpace = SRGBColorSpace;
            imageRenderer.autoClear = true;
            imageRenderer.setSize(DEFAULT_SIZE, DEFAULT_SIZE);
            imageRenderer.outputColorSpace = SRGBColorSpace;
            imageRenderer.autoClear = false;
            imageRenderer.shadowMap.enabled = true;
            imageRenderer.shadowMap.type = PCFSoftShadowMap;
            this._roomleRenderer = new RoomleWebGLRenderer(imageRenderer, DEFAULT_SIZE, DEFAULT_SIZE);
            this._roomleRenderer.setQualityMap(standaloneConfiguratorQualityLevels);
            this._roomleRenderer.setSize(DEFAULT_SIZE, DEFAULT_SIZE);
        }
        return this._roomleRenderer;
    }
    switchToPlannerSettings() {
        const renderer = this._getRoomleRenderer();
        renderer.switchToPlanner(RenderMode.Mode3D);
    }
    switchToConfiguratorSettings() {
        const renderer = this._getRoomleRenderer();
        renderer.switchToConfigurator();
    }
    static getCameraTargetForBBox(bbox, spacing = 0) {
        if (!bbox) {
            // this could happen if the Core crashes when it creates the  rootComponent
            const someVector = new Vector3();
            return { center: someVector, bounds: someVector, diagonal: 0 };
        }
        const bounds = bbox.getSize(new Vector3());
        bounds.addScalar(spacing);
        let center = bbox.getCenter(new Vector3());
        let diagonal = Math.sqrt(Math.pow(bounds.x, 2) + Math.pow(bounds.y, 2) + Math.pow(bounds.z, 2));
        return { center, bounds, diagonal };
    }
    preparePerspectiveImage(scene, uiScene, camera, cameraTarget, options = {}, objectRotation = 0, e2e = false, onBeforeRender) {
        return new Promise((resolve) => {
            const { size = 1024, showDimensions } = options;
            const renderer = this._getRoomleRenderer(e2e);
            renderer.setSize(size, size);
            const fog = scene.fog ? scene.fog.clone() : null;
            const background = scene.background ? scene.background.clone() : null;
            scene.background = null;
            scene.fog = null;
            camera.layers.disable(2 /* LAYER.BACKGROUND */);
            camera.layers.disable(6 /* LAYER.UI */);
            camera.layers.disable(5 /* LAYER.PREVIEW */);
            if (!showDimensions) {
                camera.layers.disable(8 /* LAYER.DIMENSIONS */);
            }
            else {
                camera.layers.enable(8 /* LAYER.DIMENSIONS */);
            }
            const angleY = -30 + toDegrees(objectRotation);
            ImageRenderer.placeCameraForPerspectiveImage(camera, cameraTarget, -20, angleY);
            if (onBeforeRender) {
                // update matrix world, otherwise walls are not hidden correctly when rendering in mode 2d
                camera.updateMatrixWorld(true);
                onBeforeRender(camera);
            }
            const image = this._render(renderer, scene, uiScene, camera, e2e);
            camera.layers.enable(2 /* LAYER.BACKGROUND */);
            camera.layers.enable(6 /* LAYER.UI */);
            camera.layers.enable(5 /* LAYER.PREVIEW */);
            scene.background = background;
            scene.fog = fog;
            resolve({ image, width: size, height: size, blob: null });
        });
    }
    renderPerspectiveImage(scene, camera, cameraTarget, size) {
        return new Promise((resolve) => {
            if (!size) {
                size = 1024;
            }
            const renderer = this._getRoomleRenderer();
            renderer.setSize(size, size);
            const fog = scene.fog ? scene.fog.clone() : null;
            const background = scene.background ? scene.background.clone() : null;
            scene.background = null;
            scene.fog = null;
            camera.layers.disable(2 /* LAYER.BACKGROUND */);
            camera.layers.disable(6 /* LAYER.UI */);
            camera.layers.disable(5 /* LAYER.PREVIEW */);
            if (cameraTarget) {
                ImageRenderer.placeCameraForPerspectiveImage(camera, cameraTarget, -20, -30);
            }
            else {
                camera.aspect = 1;
                camera.updateProjectionMatrix();
            }
            const image = this._render(renderer, scene, null, camera);
            camera.layers.enable(2 /* LAYER.BACKGROUND */);
            camera.layers.enable(6 /* LAYER.UI */);
            camera.layers.enable(5 /* LAYER.PREVIEW */);
            scene.background = background;
            scene.fog = fog;
            resolve({ image, width: size, height: size, blob: null });
        });
    }
    static placeCameraForPerspectiveImage(camera, cameraTarget, angleX, angleY) {
        camera.far = 1000;
        camera.fov = 15;
        camera.aspect = 1;
        camera.position.copy(cameraTarget.center);
        camera.rotation.set(0, 0, 0);
        camera.rotateY(toRadiant(angleY));
        camera.rotateX(toRadiant(angleX));
        camera.translateZ(cameraTarget.diagonal * 3.8); // hardcoded number is only a well estimated guess
        camera.updateProjectionMatrix();
    }
    prepareTopImage(scene, uiScene, cameraTarget, options = {}) {
        const { showDimensions = false } = options;
        return new Promise((resolve) => {
            const renderer = this._getRoomleRenderer();
            let camera = new OrthographicCamera(-cameraTarget.bounds.x / 2, cameraTarget.bounds.x / 2, cameraTarget.bounds.z / 2, -cameraTarget.bounds.z / 2, 0.5);
            camera.position.copy(cameraTarget.center);
            camera.rotateX(toRadiant(-90));
            camera.translateZ(cameraTarget.bounds.y + 1);
            camera.far = camera.position.y + 0.5;
            camera.layers.mask = 0xffff;
            let width = cameraTarget.bounds.x * 200; // 1 metre = 200px
            let height = cameraTarget.bounds.z * 200; // 1 metre = 200px
            let restrictTo = 4096;
            if (width > restrictTo || height > restrictTo) {
                let scale = 0;
                if (width > restrictTo) {
                    scale = width / restrictTo;
                }
                else if (height > restrictTo) {
                    scale = height / restrictTo;
                }
                width = width / scale;
                height = height / scale;
            }
            renderer.setSize(width, height);
            let fog = scene.fog ? scene.fog.clone() : null;
            let background = scene.background ? scene.background.clone() : null;
            scene.background = null;
            scene.fog = null;
            camera.layers.disable(2 /* LAYER.BACKGROUND */);
            camera.layers.disable(6 /* LAYER.UI */);
            camera.layers.disable(5 /* LAYER.PREVIEW */);
            if (!showDimensions) {
                camera.layers.disable(8 /* LAYER.DIMENSIONS */);
            }
            else {
                camera.layers.enable(8 /* LAYER.DIMENSIONS */);
            }
            const image = this._render(renderer, scene, uiScene, camera);
            camera.layers.enable(2 /* LAYER.BACKGROUND */);
            camera.layers.enable(6 /* LAYER.UI */);
            camera.layers.enable(5 /* LAYER.PREVIEW */);
            scene.background = background;
            scene.fog = fog;
            resolve({ image, width, height, blob: null });
        });
    }
    _render(renderer, scene, uiScene, camera, e2e = false) {
        if (e2e) {
            renderer.renderer.render(scene, camera);
        }
        else {
            renderer.forceShadowUpdates(true);
            renderer.render(scene, camera);
            // shadows are not set on first render
            renderer.render(scene, camera);
        }
        if (uiScene) {
            renderer.renderer.autoClear = false;
            renderer.renderer.clearDepth();
            renderer.renderer.render(uiScene, camera);
            renderer.renderer.autoClear = true;
        }
        const result = renderer.renderer.domElement.toDataURL();
        renderer.clear();
        return result;
    }
}

const DEFAULT_IDB_NAME = 'rml-idb';
const CONFIG_OBJ_STORE_NAME = 'rml-config-store';
const DEFAULT_ENTRY_EXPIRY_DAYS = 30;
const promisifyIdbRequest = (request) => {
    return new Promise((resolve, reject) => {
        // @ts-ignore -- not sure how to type this
        request.oncomplete = request.onsuccess = () => resolve(request.result);
        // @ts-ignore -- not sure how to type this
        request.onabort = request.onerror = () => reject(request.error);
    });
};
// https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor
const eachCursor = (store, callback) => {
    store.openCursor().onsuccess = function () {
        if (!this.result) {
            return;
        }
        callback(this.result);
        this.result.continue();
    };
    return promisifyIdbRequest(store.transaction);
};
class IdbManager {
    constructor(creator) {
        this.configStore = null;
        this._creator_ = creator;
        this.configStore = this._createStore(DEFAULT_IDB_NAME, CONFIG_OBJ_STORE_NAME);
    }
    get allStores() {
        return [this.configStore];
    }
    _getValue(key, objStore) {
        return objStore('readonly', (store) => promisifyIdbRequest(store.get(key)));
    }
    _setValue(key, value, objStore) {
        return objStore('readwrite', (store) => {
            store.put(value, key);
            return promisifyIdbRequest(store.transaction);
        });
    }
    _getEntries(objStore) {
        return objStore('readonly', async (store) => {
            if (store.getAll && store.getAllKeys) {
                const [keys, values] = await Promise.all([
                    promisifyIdbRequest(store.getAllKeys()),
                    promisifyIdbRequest(store.getAll()),
                ]);
                return keys.map((key, i) => [key, values[i]]);
            }
            const items = [];
            await objStore('readonly', async (storeInstance) => {
                await eachCursor(storeInstance, (cursor) => items.push([cursor.key, cursor.value]));
            });
            return items;
        });
    }
    _deleteValue(key, objStore) {
        return objStore('readwrite', (store) => {
            store.delete(key);
            return promisifyIdbRequest(store.transaction);
        });
    }
    _createStore(dbName, storeName) {
        const request = indexedDB.open(dbName);
        request.onupgradeneeded = () => request.result.createObjectStore(storeName);
        const dbp = promisifyIdbRequest(request);
        return async (txMode, callback) => {
            const db = await dbp;
            return callback(db.transaction(storeName, txMode).objectStore(storeName));
        };
    }
    getKey(...args) {
        return args.join('_');
    }
    async setValue(key, value, store) {
        const hostname = getHostname();
        const objectToStore = {
            id: key,
            data: value,
            lastModified: new Date().toISOString(),
            referrer: hostname,
        };
        await this._setValue(key, objectToStore, store);
        if (this._initData.debug) {
            console.info(`idbManager: data saved for key ${key}: ${objectToStore}`);
        }
    }
    getValue(key, store) {
        return this._getValue(key, store);
    }
    clearStore(objStore) {
        return objStore('readwrite', (store) => {
            store.clear();
            return promisifyIdbRequest(store.transaction);
        });
    }
    async pruneOldEntries() {
        // Delete old entries older than 30 days
        for (const stores of this.allStores) {
            const entries = await this._getEntries(stores);
            for (const entry of entries) {
                const lastModified = entry[1].lastModified;
                const now = new Date().toISOString();
                const diff = new Date(now).getTime() - new Date(lastModified).getTime();
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                if (days > DEFAULT_ENTRY_EXPIRY_DAYS) {
                    await this._deleteValue(entry[0], stores);
                }
            }
        }
    }
}
__decorate([
    inject
], IdbManager.prototype, "_initData", void 0);

const INJECTABLES = [
    new DependencyInjectionAssignment('error-handler', ErrorHandler),
    new DependencyInjectionAssignment('form-data-util', FormDataUtil),
    new DependencyInjectionAssignment('hdr-environment-loader', HdrEnvironmentLoader),
    new DependencyInjectionAssignment('static-item-loader', StaticItemLoader, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('form-data-util', FormDataUtil),
    new DependencyInjectionAssignment('single-promise-factory', SinglePromiseFactory, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('dynamic-light-setting-loader', DynamicLightSettingLoader),
    new DependencyInjectionAssignment('network-layer', NetworkLayer),
    new DependencyInjectionAssignment('local-storage', LocalStorage),
    new DependencyInjectionAssignment('network-layer', NetworkLayer),
    new DependencyInjectionAssignment('kernel-io', KernelIo, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('data-syncer', DataSyncer),
    new DependencyInjectionAssignment('memory-manager', MemoryManager),
    new DependencyInjectionAssignment('life-cycle-manager', LifeCycleManager, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('local-storage-helper', LocalStorageHelper),
    new DependencyInjectionAssignment('cache-holder', CacheHolder, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('kernel-access-callback', KernelAccessCallback, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('configurator-kernel-access-callback', ConfiguratorKernelAccessCallback, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('configurator-context', ConfiguratorContext, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('init-data', InitData, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('global-init-data', GlobalInitData, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('global-callback', GlobalCallback, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('dom-helper', DomHelper, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('unit-formatter', UnitFormatter, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('plugin-system', PluginSystem, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('configurator-mesh-generator', ConfiguratorMeshGenerator),
    new DependencyInjectionAssignment('configurator-input-manager', ConfiguratorInputManager, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('selection-handler', SelectionHandler, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('component-dimensioning-helper', ComponentDimensioningHelper, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('component-dimensioning-helper', ComponentDimensioningHelper, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('planner-kernel-access', PlannerKernelAccess),
    new DependencyInjectionAssignment('planner-mesh-generator', PlannerMeshGenerator, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('unit-formatter', UnitFormatter),
    new DependencyInjectionAssignment('configurator-history', ConfiguratorHistory, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('roomle-planner-ui-callback', RoomlePlannerUiCallback),
    new DependencyInjectionAssignment('configurator-ui-callbacks', ConfiguratorUiCallbacks, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('roomle-tools-core', RoomleToolsCore, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('image-renderer', ImageRenderer, 0 /* DI_TYPE.GLOBAL */),
    new DependencyInjectionAssignment('idb-manager', IdbManager, 0 /* DI_TYPE.GLOBAL */),
];

class RoomleDependencyInjection {
    static _ensureContainer() {
        if (!window.__RML__DI__) {
            window.__RML__DI__ = new Container();
            window.__RML__DI__.addDependencyInjectionAssignments(INJECTABLES);
        }
    }
    static setup(injectables) {
        RoomleDependencyInjection.addToContainer(injectables);
    }
    static lookup(specifier, context) {
        return !window.__RML__DI__
            ? null
            : window.__RML__DI__.lookup(specifier, context);
    }
    static getContext(name) {
        RoomleDependencyInjection._ensureContainer();
        return window.__RML__DI__.getContext(name);
    }
    static cleanUp(context) {
        return !window.__RML__DI__ ? null : window.__RML__DI__.cleanUp(context);
    }
    static addToContainer(injectables) {
        RoomleDependencyInjection._ensureContainer();
        window.__RML__DI__.addDependencyInjectionAssignments(injectables);
    }
}

export { transitionTransparencyOfMaterial as $, AppContext as A, Benchmark as B, ConfiguratorViewModel as C, DependencyInjectionAssignment as D, EventDispatcher as E, isMaterial as F, convertCObject as G, position3VectorsAreEqual as H, INJECTABLES as I, position2VectorsAreEqual as J, compareBox3Size as K, Logger as L, MaterialCreator as M, createMaterial as N, addTexture as O, PULSE_LOOPS as P, getGUI as Q, RapiAccess as R, rotationQuaternionsAreEqual as S, getDelta as T, MIN_MOVE_DISTANCE as U, LightSourceDetector as V, EnvironmentMapDecodeMaterial as W, RoomleWebGLRenderer as X, standaloneConfiguratorQualityLevels as Y, ENV_HDR_256_FILE_NAME as Z, __decorate as _, DataSyncer as a, WallPlanElementViewModel as a0, FloorPlanElementViewModel as a1, MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME as a2, MeasurementLinePlanElementViewModel as a3, NodePlanElementViewModel as a4, isSafari as a5, convertToTHREE as a6, ConfiguratorPlanObjectViewModel as a7, StaticPlanObjectViewModel as a8, INPUT_DELAY_TYPE as a9, GlobalInitData as aA, InitData as aB, AsyncDependencyLoader as aC, ScenePluginDefaultImplementation as aD, ConstructionPlanObjectViewModel as aa, CeilingPlanElementViewModel as ab, kernelBoxToThreeBox as ac, PlannerKernelAccess as ad, threeVectorToTransferableXY as ae, AsyncGuard as af, RenderMode as ag, PLAN_ELEMENT_CHANGE_TYPES as ah, hideWallsBasedOnCamera as ai, fadeIn as aj, viewSpacePositionFromUV as ak, setWallTransparency as al, getDrawingMinBounds as am, toMeasurementLineDimensionToTransferable as an, objectToWallDimensionToTransferable as ao, toConstructionMeasurementTransferable as ap, wallDimensionToTransferable as aq, isPlanSnapshotId as ar, InputManager as as, PlannerMeshGenerator as at, setMaterial as au, getMaterialShading as av, addExistingTexture as aw, UiCallback as ax, ConfiguratorMeshGenerator as ay, GlobalCallback as az, RoomleDependencyInjection as b, convertToKernel as c, disposeMesh as d, CANVAS_ID as e, Env as f, getScreenXY as g, PULSE_DURATION as h, inject as i, DynamicLightSettingLoader as j, PREDEFINED_LIGHTSETTING as k, ImageRenderer as l, createEmptySceneFromCurrent as m, dispose as n, getYRotationOfObject as o, getIdealDistance as p, getHostname as q, RoomleComponentFactoryInitializer as r, toDegrees as s, toRadiant as t, DEFAULT_CONVERSATION_ID as u, vectorIsZero as v, getCatalogIdFromItemOrConfigurationId as w, isIdItemId as x, AsyncHelper as y, isRange as z };
//# sourceMappingURL=roomle-dependency-injection-9d1679c1.js.map
