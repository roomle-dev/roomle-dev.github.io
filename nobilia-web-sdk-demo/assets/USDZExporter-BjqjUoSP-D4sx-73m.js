import{cq as E,cr as D,c as Z,cs as _,ct as I}from"./index-BowFTnF3.js";class y{constructor(a,r="",o=[],e=[]){this.name=a,this.type=r,this.metadata=o,this.properties=e,this.children=[]}addMetadata(a,r){this.metadata.push({key:a,value:r})}addProperty(a,r=[]){this.properties.push({property:a,metadata:r})}addChild(a){this.children.push(a)}toString(a=0){const r="	".repeat(a),o=this.metadata.map(l=>{const h=l.key,u=l.value;if(Array.isArray(u)){const c=[];return c.push(`${h} = {`),u.forEach(P=>{c.push(`${r}		${P}`)}),c.push(`${r}	}`),c.join(`
`)}else return`${h} = ${u}`}),e=o.length?` (
${o.map(l=>`${r}	${l}`).join(`
`)}
${r})`:"",i=this.properties.map(l=>{const h=l.property,u=l.metadata.length?` (
${l.metadata.map(c=>`${r}		${c}`).join(`
`)}
${r}	)`:"";return`${r}	${h}${u}`}),n=this.children.map(l=>l.toString(a+1)),s=[];if(i.length>0&&s.push(...i),n.length>0){i.length>0&&s.push("");for(let l=0;l<n.length;l++)s.push(n[l]),l<n.length-1&&s.push("")}const d=s.join(`
`),p=this.type?this.type+" ":"";return`${r}def ${p}"${this.name}"${e}
${r}{
${d}
${r}}`}}class W{constructor(){this.textureUtils=null}setTextureUtils(a){this.textureUtils=a}parse(a,r,o,e){this.parseAsync(a,e).then(r).catch(o)}async parseAsync(a,r={}){r=Object.assign({ar:{anchoring:{type:"plane"},planeAnchoring:{alignment:"horizontal"}},includeAnchoringProperties:!0,onlyVisible:!0,quickLookCompatible:!1,maxTextureSize:1024},r);const o=new Set,e={},i="model.usda";e[i]=null;const n=new y("Root","Xform"),s=new y("Scenes","Scope");s.addMetadata("kind",'"sceneLibrary"'),n.addChild(s);const d="Scene",p=new y(d,"Xform");p.addMetadata("customData",["bool preliminary_collidesWithEnvironment = 0",`string sceneName = "${d}"`]),p.addMetadata("sceneName",`"${d}"`),r.includeAnchoringProperties&&(p.addProperty(`token preliminary:anchoring:type = "${r.ar.anchoring.type}"`),p.addProperty(`token preliminary:planeAnchoring:alignment = "${r.ar.planeAnchoring.alignment}"`)),s.addChild(p);let l;const h={},u={};U(a,p,h,o,e,r);const c=z(h,u,r.quickLookCompatible);l=b()+`
`+n.toString()+`

`+c.toString(),e[i]=E(l),l=null;for(const M in u){let g=u[M];if(g.isCompressedTexture===!0){if(this.textureUtils===null)throw new Error("THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.");g=await this.textureUtils.decompress(g)}const x=O(g.image,g.flipY,r.maxTextureSize),$=await new Promise(f=>x.toBlob(f,"image/png",1));e[`textures/Texture_${M}.png`]=new Uint8Array(await $.arrayBuffer())}let P=0;for(const M in e){const g=e[M],x=34+M.length;P+=x;const $=P&63;if($!==4){const f=64-$,A=new Uint8Array(f);e[M]=[g,{extra:{12345:A}}]}P=g.length}return D(e,{level:0})}}function S(t,a){let r=t.name;return r=r.replace(/[^A-Za-z0-9_]/g,""),/^[0-9]/.test(r)&&(r="_"+r),r===""&&(t.isCamera?r="Camera":r="Object"),a.has(r)&&(r=r+"_"+t.id),a.add(r),r}function O(t,a,r){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const o=r/Math.max(t.width,t.height),e=document.createElement("canvas");e.width=t.width*Math.min(1,o),e.height=t.height*Math.min(1,o);const i=e.getContext("2d");return a===!0&&(i.translate(0,e.height),i.scale(1,-1)),i.drawImage(t,0,0,e.width,e.height),e}else throw new Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")}const m=7;function b(){return`#usda 1.0
(
	customLayerData = {
		string creator = "Three.js USDZExporter"
	}
	defaultPrim = "Root"
	metersPerUnit = 1
	upAxis = "Y"
)
`}function U(t,a,r,o,e,i){for(let n=0,s=t.children.length;n<s;n++){const d=t.children[n];if(d.visible===!1&&i.onlyVisible===!0)continue;let p;if(d.isMesh){const l=d.geometry,h=d.material;if(h.isMeshStandardMaterial){const u="geometries/Geometry_"+l.id+".usda";if(!(u in e)){const c=H(l);e[u]=E(b()+`
`+c.toString())}h.uuid in r||(r[h.uuid]=h),p=j(d,l,r[h.uuid],o)}else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)",d)}else d.isCamera?p=F(d,o):p=k(d,o);p&&(a.addChild(p),U(d,p,r,o,e,i))}}function k(t,a){const r=S(t,a),o=R(t.matrix);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const e=new y(r,"Xform");return e.addProperty(`matrix4d xformOp:transform = ${o}`),e.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]'),e}function j(t,a,r,o){const e=k(t,o);return e.addMetadata("prepend references",`@./geometries/Geometry_${a.id}.usda@</Geometry>`),e.addMetadata("prepend apiSchemas",'["MaterialBindingAPI"]'),e.addProperty(`rel material:binding = </Materials/Material_${r.id}>`),e}function R(t){const a=t.elements;return`( ${v(a,0)}, ${v(a,4)}, ${v(a,8)}, ${v(a,12)} )`}function v(t,a){return`(${t[a+0]}, ${t[a+1]}, ${t[a+2]}, ${t[a+3]})`}function H(t){const a=new y("Geometry"),r=L(t);return a.addChild(r),a}function L(t){const a="Geometry",r=t.attributes,o=r.position.count,e=new y(a,"Mesh");e.addProperty(`int[] faceVertexCounts = [${B(t)}]`),e.addProperty(`int[] faceVertexIndices = [${G(t)}]`),e.addProperty(`normal3f[] normals = [${w(r.normal,o)}]`,['interpolation = "vertex"']),e.addProperty(`point3f[] points = [${w(r.position,o)}]`);for(let n=0;n<4;n++){const s=n>0?n:"",d=r["uv"+s];d!==void 0&&e.addProperty(`texCoord2f[] primvars:st${s} = [${X(d)}]`,['interpolation = "vertex"'])}const i=r.color;return i!==void 0&&e.addProperty(`color3f[] primvars:displayColor = [${w(i,o)}]`,['interpolation = "vertex"']),e.addProperty('uniform token subdivisionScheme = "none"'),e}function B(t){const a=t.index!==null?t.index.count:t.attributes.position.count;return Array(a/3).fill(3).join(", ")}function G(t){const a=t.index,r=[];if(a!==null)for(let o=0;o<a.count;o++)r.push(a.getX(o));else{const o=t.attributes.position.count;for(let e=0;e<o;e++)r.push(e)}return r.join(", ")}function w(t,a){if(t===void 0)return console.warn("USDZExporter: Normals missing."),Array(a).fill("(0, 0, 0)").join(", ");const r=[];for(let o=0;o<t.count;o++){const e=t.getX(o),i=t.getY(o),n=t.getZ(o);r.push(`(${e.toPrecision(m)}, ${i.toPrecision(m)}, ${n.toPrecision(m)})`)}return r.join(", ")}function X(t){const a=[];for(let r=0;r<t.count;r++){const o=t.getX(r),e=t.getY(r);a.push(`(${o.toPrecision(m)}, ${1-e.toPrecision(m)})`)}return a.join(", ")}function z(t,a,r=!1){const o=new y("Materials");for(const e in t){const i=t[e];o.addChild(N(i,a,r))}return o}function N(t,a,r=!1){const o=new y(`Material_${t.id}`,"Material");function e(n,s,d){const p=n.source.id+"_"+n.flipY;a[p]=n;const l=n.channel>0?"st"+n.channel:"st",h={1e3:"repeat",1001:"clamp",1002:"mirror"},u=n.repeat.clone(),c=n.offset.clone(),P=n.rotation,M=Math.sin(P),g=Math.cos(P);c.y=1-c.y-u.y,r?(c.x=c.x/u.x,c.y=c.y/u.y,c.x+=M/u.x,c.y+=g-1):(c.x+=M*u.x,c.y+=(1-g)*u.y);const x=new y(`PrimvarReader_${s}`,"Shader");x.addProperty('uniform token info:id = "UsdPrimvarReader_float2"'),x.addProperty("float2 inputs:fallback = (0.0, 0.0)"),x.addProperty(`token inputs:varname = "${l}"`),x.addProperty("float2 outputs:result");const $=new y(`Transform2d_${s}`,"Shader");$.addProperty('uniform token info:id = "UsdTransform2d"'),$.addProperty(`token inputs:in.connect = </Materials/Material_${t.id}/PrimvarReader_${s}.outputs:result>`),$.addProperty(`float inputs:rotation = ${(P*(180/Math.PI)).toFixed(m)}`),$.addProperty(`float2 inputs:scale = ${C(u)}`),$.addProperty(`float2 inputs:translation = ${C(c)}`),$.addProperty("float2 outputs:result");const f=new y(`Texture_${n.id}_${s}`,"Shader");return f.addProperty('uniform token info:id = "UsdUVTexture"'),f.addProperty(`asset inputs:file = @textures/Texture_${p}.png@`),f.addProperty(`float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${s}.outputs:result>`),d!==void 0&&f.addProperty(`float4 inputs:scale = ${V(d)}`),f.addProperty(`token inputs:sourceColorSpace = "${n.colorSpace===I?"raw":"sRGB"}"`),f.addProperty(`token inputs:wrapS = "${h[n.wrapS]}"`),f.addProperty(`token inputs:wrapT = "${h[n.wrapT]}"`),f.addProperty("float outputs:r"),f.addProperty("float outputs:g"),f.addProperty("float outputs:b"),f.addProperty("float3 outputs:rgb"),(t.transparent||t.alphaTest>0)&&f.addProperty("float outputs:a"),[x,$,f]}t.side===Z&&console.warn("THREE.USDZExporter: USDZ does not support double sided materials",t);const i=new y("PreviewSurface","Shader");if(i.addProperty('uniform token info:id = "UsdPreviewSurface"'),t.map!==null?(i.addProperty(`color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`),t.transparent?i.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`):t.alphaTest>0&&(i.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`),i.addProperty(`float inputs:opacityThreshold = ${t.alphaTest}`)),e(t.map,"diffuse",t.color).forEach(n=>o.addChild(n))):i.addProperty(`color3f inputs:diffuseColor = ${T(t.color)}`),t.emissiveMap!==null){i.addProperty(`color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`);const n=new _(t.emissive.r*t.emissiveIntensity,t.emissive.g*t.emissiveIntensity,t.emissive.b*t.emissiveIntensity);e(t.emissiveMap,"emissive",n).forEach(s=>o.addChild(s))}else t.emissive.getHex()>0&&i.addProperty(`color3f inputs:emissiveColor = ${T(t.emissive)}`);if(t.normalMap!==null&&(i.addProperty(`normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`),e(t.normalMap,"normal").forEach(n=>o.addChild(n))),t.aoMap!==null){i.addProperty(`float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`);const n=new _(t.aoMapIntensity,t.aoMapIntensity,t.aoMapIntensity);e(t.aoMap,"occlusion",n).forEach(s=>o.addChild(s))}if(t.roughnessMap!==null){i.addProperty(`float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`);const n=new _(t.roughness,t.roughness,t.roughness);e(t.roughnessMap,"roughness",n).forEach(s=>o.addChild(s))}else i.addProperty(`float inputs:roughness = ${t.roughness}`);if(t.metalnessMap!==null){i.addProperty(`float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`);const n=new _(t.metalness,t.metalness,t.metalness);e(t.metalnessMap,"metallic",n).forEach(s=>o.addChild(s))}else i.addProperty(`float inputs:metallic = ${t.metalness}`);if(t.alphaMap!==null?(i.addProperty(`float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`),i.addProperty("float inputs:opacityThreshold = 0.0001"),e(t.alphaMap,"opacity").forEach(n=>o.addChild(n))):i.addProperty(`float inputs:opacity = ${t.opacity}`),t.isMeshPhysicalMaterial){if(t.clearcoatMap!==null){i.addProperty(`float inputs:clearcoat.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatMap.id}_clearcoat.outputs:r>`);const n=new _(t.clearcoat,t.clearcoat,t.clearcoat);e(t.clearcoatMap,"clearcoat",n).forEach(s=>o.addChild(s))}else i.addProperty(`float inputs:clearcoat = ${t.clearcoat}`);if(t.clearcoatRoughnessMap!==null){i.addProperty(`float inputs:clearcoatRoughness.connect = </Materials/Material_${t.id}/Texture_${t.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);const n=new _(t.clearcoatRoughness,t.clearcoatRoughness,t.clearcoatRoughness);e(t.clearcoatRoughnessMap,"clearcoatRoughness",n).forEach(s=>o.addChild(s))}else i.addProperty(`float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`);i.addProperty(`float inputs:ior = ${t.ior}`)}return i.addProperty("int inputs:useSpecularWorkflow = 0"),i.addProperty("token outputs:surface"),o.addChild(i),o.addProperty(`token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>`),o}function T(t){return`(${t.r}, ${t.g}, ${t.b})`}function V(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}function C(t){return`(${t.x}, ${t.y})`}function F(t,a){const r=S(t,a),o=R(t.matrix);t.matrix.determinant()<0&&console.warn("THREE.USDZExporter: USDZ does not support negative scales",t);const e=new y(r,"Camera");e.addProperty(`matrix4d xformOp:transform = ${o}`),e.addProperty('uniform token[] xformOpOrder = ["xformOp:transform"]');const i=t.isOrthographicCamera?"orthographic":"perspective";e.addProperty(`token projection = "${i}"`);const n=`(${t.near.toPrecision(m)}, ${t.far.toPrecision(m)})`;e.addProperty(`float2 clippingRange = ${n}`);let s;t.isOrthographicCamera?s=((Math.abs(t.left)+Math.abs(t.right))*10).toPrecision(m):s=t.getFilmWidth().toPrecision(m),e.addProperty(`float horizontalAperture = ${s}`);let d;if(t.isOrthographicCamera?d=((Math.abs(t.top)+Math.abs(t.bottom))*10).toPrecision(m):d=t.getFilmHeight().toPrecision(m),e.addProperty(`float verticalAperture = ${d}`),t.isPerspectiveCamera){const p=t.getFocalLength().toPrecision(m);e.addProperty(`float focalLength = ${p}`);const l=t.focus.toPrecision(m);e.addProperty(`float focusDistance = ${l}`)}return e}export{W as USDZExporter};
