import{U as E,E as I,L as T,p as m,G,l as P,d as R,W as _,_ as k}from"./BufferGeometry-DF44aTDz-B_l4TPCu.js";class j extends G{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new P(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const M=new m,L=new m,A=new _,y=new k,x=new R,b=new m,S=new m;class z extends E{constructor(t=new I,i=new j){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=i,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(t,i){return super.copy(t,i),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[0];for(let e=1,r=i.count;e<r;e++)M.fromBufferAttribute(i,e-1),L.fromBufferAttribute(i,e),s[e]=s[e-1],s[e]+=M.distanceTo(L);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,i){const s=this.geometry,e=this.matrixWorld,r=t.params.Line.threshold,n=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),x.copy(s.boundingSphere),x.applyMatrix4(e),x.radius+=r,t.ray.intersectsSphere(x)===!1)return;A.copy(e).invert(),y.copy(t.ray).applyMatrix4(A);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=l*l,d=this.isLineSegments?2:1,h=s.index,H=s.attributes.position;if(h!==null){const f=Math.max(0,n.start),u=Math.min(h.count,n.start+n.count);for(let o=f,g=u-1;o<g;o+=d){const p=h.getX(o),X=h.getX(o+1),W=w(this,t,y,a,p,X,o);W&&i.push(W)}if(this.isLineLoop){const o=h.getX(u-1),g=h.getX(f),p=w(this,t,y,a,o,g,u-1);p&&i.push(p)}}else{const f=Math.max(0,n.start),u=Math.min(H.count,n.start+n.count);for(let o=f,g=u-1;o<g;o+=d){const p=w(this,t,y,a,o,o+1,o);p&&i.push(p)}if(this.isLineLoop){const o=w(this,t,y,a,u-1,f,u-1);o&&i.push(o)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,i=Object.keys(t);if(i.length>0){const s=t[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,r=s.length;e<r;e++){const n=s[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=e}}}}}function w(c,t,i,s,e,r,n){const l=c.geometry.attributes.position;if(M.fromBufferAttribute(l,e),L.fromBufferAttribute(l,r),i.distanceSqToSegment(M,L,b,S)>s)return;b.applyMatrix4(c.matrixWorld);const a=t.ray.origin.distanceTo(b);if(!(a<t.near||a>t.far))return{distance:a,point:S.clone().applyMatrix4(c.matrixWorld),index:n,face:null,faceIndex:null,barycoord:null,object:c}}const B=new m,D=new m;class C extends z{constructor(t,i){super(t,i),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const i=t.attributes.position,s=[];for(let e=0,r=i.count;e<r;e+=2)B.fromBufferAttribute(i,e),D.fromBufferAttribute(i,e+1),s[e]=e===0?0:s[e-1],s[e+1]=s[e]+B.distanceTo(D);t.setAttribute("lineDistance",new T(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}const v=new m;class U extends E{constructor(t,i){super(),this.light=t,this.matrixAutoUpdate=!1,this.color=i,this.type="SpotLightHelper";const s=new I,e=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let n=0,l=1,a=32;n<a;n++,l++){const d=n/a*Math.PI*2,h=l/a*Math.PI*2;e.push(Math.cos(d),Math.sin(d),1,Math.cos(h),Math.sin(h),1)}s.setAttribute("position",new T(e,3));const r=new j({fog:!1,toneMapped:!1});this.cone=new C(s,r),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const t=this.light.distance?this.light.distance:1e3,i=t*Math.tan(this.light.angle);this.cone.scale.set(i,i,t),v.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(v),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}export{U as SpotLightHelper};
