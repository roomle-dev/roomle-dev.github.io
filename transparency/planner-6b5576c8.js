import { S as ScriptLoader, M as Main } from './script-loader-92c3f806.js';
import { Q as getGUI, E as EventDispatcher, a0 as WallPlanElementViewModel, a1 as FloorPlanElementViewModel, _ as __decorate, i as inject, a2 as MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME, c as convertToKernel, a3 as MeasurementLinePlanElementViewModel, a4 as NodePlanElementViewModel, a5 as isSafari, a6 as convertToTHREE, a7 as ConfiguratorPlanObjectViewModel, a8 as StaticPlanObjectViewModel, a9 as INPUT_DELAY_TYPE, C as ConfiguratorViewModel, aa as ConstructionPlanObjectViewModel, ab as CeilingPlanElementViewModel, ac as kernelBoxToThreeBox, ad as PlannerKernelAccess, ae as threeVectorToTransferableXY, g as getScreenXY, G as convertCObject, af as AsyncGuard, ag as RenderMode, ah as PLAN_ELEMENT_CHANGE_TYPES, q as getHostname, ai as hideWallsBasedOnCamera, M as MaterialCreator, aj as fadeIn, ak as viewSpacePositionFromUV, al as setWallTransparency, am as getDrawingMinBounds, l as ImageRenderer, m as createEmptySceneFromCurrent, n as dispose, an as toMeasurementLineDimensionToTransferable, ao as objectToWallDimensionToTransferable, ap as toConstructionMeasurementTransferable, aq as wallDimensionToTransferable, x as isIdItemId, B as Benchmark, ar as isPlanSnapshotId, j as DynamicLightSettingLoader, as as InputManager, D as DependencyInjectionAssignment, L as Logger, at as PlannerMeshGenerator, R as RapiAccess, b as RoomleDependencyInjection } from './roomle-dependency-injection-e0c1e2cf.js';
import { L as LightSetting, B as BackgroundEnvironment, C as CameraControl3D, b as CameraControl2D, c as CameraControlFirstPerson, T as TWEEN_FILE_NAME } from './scene-manager-392463ea.js';
import { a as Vector3, A as AmbientLight, C as Color, D as DirectionalLight, V as Vector2, ae as Sphere, bu as Layers, aB as deepMerge, b8 as PlaneGeometry, h as MeshBasicMaterial, z as Mesh, aU as setCursor, aP as wait, aE as CAMERA_TYPE, ad as Box3, K as Group, ao as ShaderMaterial, at as UniformsUtils, bg as BackSide, aN as BoxGeometry, m as TextureLoader, r as RepeatWrapping, bO as copy, bA as getColor, a_ as SphereGeometry, bP as applyMaterialToKernelMaterial, U as MathUtils } from './main-thread-to-worker-8a755a37.js';
import { S as SceneEventHandler, C as ConfiguratorSceneManager, R as RoomleConfigurator } from './roomle-configurator-506f105b.js';
import './query-params-helper-f12b7599.js';
import './default-light-setting-75312589.js';

var img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVUAAAFVCAYAAABfDHwuAAFvk0lEQVR42nTdPatuaVb18fWpOzbqtKIDXUFHjYmJGJiIgYEGQiMIIoKCKKKIiChVTYcP84b/5lfjWRWcOnX2vl/WutZ1zZcxxxzz+du//dvv/+Vf/uX7f/qnf/r+H//xH7//y7/8y+9/+9vffv+v//qv3//N3/zN93/1V3/1/T//8z9//9///d+fv+/19+dee7+/195reu3f//3ff/93f/d3n9feZ/b6e11/7jvuO//t3/7t8/r72b3/H/7hHz6v/ZM/+ZPPZ93n9Hn3nvv/+3Ovu9/fnz6v+7jv7R7uz732rvV+fn93Pb3+Pu9+d6/ze+61d/29/353f//7v//718/u73vNfc79/733/r57uf9vfe419+c+4773fn5/+vf9ue+899zPvPfuv8/6i7/4i8/r7/l03ffnrqHruN/18/vT+t6f//zP//z6/353n9/9d02t7b3uP/7jP772Q/fsfdzP7pm1lvf6+7s9cdfc3/eaP//zP//8vs+/tezZ9Ez++q//+vP6+3Pfd6+7992ffn7XdK+999xzudfc596/7/d/+qd/+tlj97P7+/60lvf59513rXcdPuP25P3/XXfP+v6/PXZ/7vvbI7337uH+/z7/PufW27W9n9/n3M+6x/v/e+19nmeifdY1tNb3mu7B/dqZa13aB/f3Xfd95r239ezzujb3RnvR1929+exv7Vr/zmXr1DP6r//6r6/P+LM/+7PP6+79dx3/8z//83Wt9+d+3xm653mf3zm5v3vt3Uef0d5t73Vv99q7nz77Pq/3dX/t/7vezmjP9d6bvetM3hrf7+6z2gOdy/v5H//xH3+u6enhtTh3I31QP7/NeT+/L7033UL15ffn//7v/z6bPUOUQdBY3J+7sHv9vT+j14ZoU9w1dNB6sN1Ir8mgtCAZhgxLC9ZN3//f9d9D7loyvG2GrrXDm6HuYeUIWvj7c6/r81srH/jd5/3tYbvP+KM/+qPPtdzPffBtWA1613Svu5+38fqse11rmDHKWPSaW697z13vvf7W8n7Xoej6+16dV99xB6DP7xm1ObvG9oyHoc9pP2RgO8gZrFun+9299xz4/a71uOvv/jIC7bfWOIOaYfKZdNBy5PcaDUbXUmCRo2xf5tj6fXurw3if2Trdn/Z6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";

//import { viewSpacePositionFromUV } from '../../../../common-core/src/utils/threejs-utils';
class PlannerLightSetting extends LightSetting {
    constructor(scene, oldLightSetting) {
        super(scene, oldLightSetting);
        this._center = new Vector3(0, 0, 0);
        this._params = {
            ambientLight: {
                color: '#ffffff',
            },
            hemiLight: {
                color: '#ffffff',
            },
            mainDirLight: {
                direction: {
                    x: 2,
                    y: 1,
                    z: 2,
                },
                color: '#ffffff',
            },
        };
        this._ambientLight = new AmbientLight(new Color(this._params.ambientLight.color), 0.4);
        this._ambientLight.layers.set(1 /* LAYER.LIGHTING */);
        // this._hemiLight = new HemisphereLight(new Color(0xffffff), new Color(0x555555), 0.3);
        // this._hemiLight.layers.set(LAYER.LIGHTING);
        // this._hemiLight.visible = false;
        this._mainDirLight = new DirectionalLight(new Color(this._params.mainDirLight.color), 0.5);
        this._mainDirLight.castShadow = true;
        this._mainDirLight.shadow.camera.near = 0.5;
        this._mainDirLight.shadow.camera.far = 100;
        this._mainDirLight.shadow.mapSize = new Vector2(1024, 1024);
        this._mainDirLight.visible = true;
        this.addToScene();
    }
    updateSunPosition(_inclination, _azimuth) {
        //const distance = 20;
        //const viewSpacePosition = viewSpacePositionFromUV(
        //  distance,
        //  _azimuth,
        //  _inclination
        //);
        //const position = new Vector3(
        //  viewSpacePosition.x,
        //  -viewSpacePosition.z,
        //  viewSpacePosition.y
        //);
        // this._areaLight.position.copy(position);
        // this._areaLight.lookAt(new Vector3(0, 0, 0));
    }
    addToScene() {
        this._scene.add(this._mainDirLight);
        this._scene.add(this._ambientLight);
        // this._scene.add(this._hemiLight);
        this._scene.add(this._mainDirLight.target);
    }
    removeFromScene() {
        this._scene.remove(this._mainDirLight);
        this._scene.remove(this._ambientLight);
        this._scene.remove(this._mainDirLight.target);
    }
    reload() {
        this.removeFromScene();
        this.addToScene();
    }
    needsBounds() {
        return true;
    }
    updateBounds(bounds) {
        this._center.copy(bounds.getCenter(new Vector3()));
        const boundingSphere = new Sphere();
        bounds.getBoundingSphere(boundingSphere);
        const maxSize = boundingSphere.radius;
        const lightDirection = new Vector3(this._params.mainDirLight.direction.x, this._params.mainDirLight.direction.y, this._params.mainDirLight.direction.z);
        lightDirection.normalize();
        lightDirection.multiplyScalar(maxSize);
        this._mainDirLight.position.copy(this._center);
        this._mainDirLight.position.add(lightDirection);
        this._mainDirLight.target.position.copy(this._center);
        this._mainDirLight.target.updateMatrixWorld(true);
        this._mainDirLight.shadow.camera.top = maxSize;
        this._mainDirLight.shadow.camera.bottom = -maxSize;
        this._mainDirLight.shadow.camera.left = -maxSize;
        this._mainDirLight.shadow.camera.right = maxSize;
        this._mainDirLight.shadow.camera.near = 0.01;
        this._mainDirLight.shadow.camera.far = 2 * maxSize;
        this._mainDirLight.shadow.camera.updateProjectionMatrix();
    }
    showGUI() {
        let gui = getGUI();
        if (!gui) {
            return;
        }
        if (this._ambientLight) {
            let ambiLight = gui.addFolder('Ambient Light');
            ambiLight.add(this._ambientLight, 'visible');
            ambiLight
                .add(this._ambientLight, 'intensity')
                .min(0)
                .max(5)
                .step(0.1);
            ambiLight
                .addColor(this._params.ambientLight, 'color')
                .onChange((color) => (this._ambientLight.color = new Color(color)));
        }
        if (this._hemiLight) {
            let hemiLight = gui.addFolder('Hemi Light');
            hemiLight.add(this._hemiLight, 'visible');
            hemiLight.add(this._hemiLight, 'intensity').min(0).max(5).step(0.1);
            hemiLight
                .addColor(this._params.hemiLight, 'color')
                .onChange((color) => (this._hemiLight.color = new Color(color)));
        }
        if (this._mainDirLight) {
            let mainDirectionalLight = gui.addFolder('Main Directional Light');
            mainDirectionalLight.add(this._mainDirLight, 'visible');
            mainDirectionalLight
                .add(this._mainDirLight, 'intensity')
                .min(0)
                .max(10)
                .step(0.1);
            mainDirectionalLight.add(this._mainDirLight, 'castShadow');
            mainDirectionalLight
                .addColor(this._params.mainDirLight, 'color')
                .onChange((color) => (this._mainDirLight.color = new Color(color)));
            mainDirectionalLight
                .add(this._mainDirLight.position, 'x')
                .min(-10)
                .max(10)
                .step(0.1)
                .onChange(() => this._mainDirLight.lookAt(this._center));
            mainDirectionalLight
                .add(this._mainDirLight.position, 'y')
                .min(-10)
                .max(50)
                .step(0.1)
                .onChange(() => this._mainDirLight.lookAt(this._center));
            mainDirectionalLight
                .add(this._mainDirLight.position, 'z')
                .min(-10)
                .max(10)
                .step(0.1)
                .onChange(() => this._mainDirLight.lookAt(this._center));
        }
    }
}

const isWallOrFloor = (planElementViewModel) => {
    return (planElementViewModel instanceof WallPlanElementViewModel ||
        planElementViewModel instanceof FloorPlanElementViewModel);
};
class PlannerSelectionHandlerEvent {
    constructor(data) {
        const { planElementViewModel, planElementViewModels, selectionMode, reason, } = data;
        this.planElementViewModel = planElementViewModel;
        this.planElementViewModels = planElementViewModels;
        this.selectionMode = selectionMode;
        this.reason = reason;
    }
}
class PlannerSelectionHandler extends EventDispatcher {
    constructor() {
        super(...arguments);
        this._selectionMode = "standard" /* SELECTION_MODE.STANDARD */;
        this._selectedPlanElementViewModels = new Map();
    }
    check(planElementViewModel) {
        if (this._selectionMode === "standard" /* SELECTION_MODE.STANDARD */) {
            this._checkStandard(planElementViewModel);
        }
        if (this._selectionMode === "multiselect" /* SELECTION_MODE.MULTISELECT */) {
            this._checkMulti(planElementViewModel);
        }
    }
    removeSelection() {
        this._selectedPlanElementViewModels.clear();
    }
    cancelSelection(reason) {
        if (this._selectedPlanElementViewModels.size === 0) {
            return;
        }
        this._selectedPlanElementViewModels.forEach((planElementViewModel, id) => {
            this._selectedPlanElementViewModels.delete(id);
            planElementViewModel.deselect();
            this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_PLAN_ELEMENT */, new PlannerSelectionHandlerEvent({ planElementViewModel, reason }));
        });
    }
    _checkStandard(planElementViewModel) {
        let selected = this._selectedPlanElementViewModels.has(planElementViewModel.getId());
        if (selected) {
            return;
        }
        if (this._selectedPlanElementViewModels.size > 0) {
            this._selectedPlanElementViewModels.forEach((value, id) => {
                this._selectedPlanElementViewModels.delete(id);
                value.deselect();
                this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_PLAN_ELEMENT */, new PlannerSelectionHandlerEvent({
                    planElementViewModel: value,
                }));
            });
        }
        this._selectedPlanElementViewModels.set(planElementViewModel.getId(), planElementViewModel);
        planElementViewModel.select();
        this.dispatchEvent(0 /* SELECTION_EVENT.SELECT_PLAN_ELEMENT */, new PlannerSelectionHandlerEvent({ planElementViewModel }));
    }
    _checkMulti(planElementViewModel) {
        if (isWallOrFloor(planElementViewModel)) {
            return;
        }
        let selected = this._selectedPlanElementViewModels.has(planElementViewModel.getId());
        if (selected) {
            return;
        }
        else {
            this._selectedPlanElementViewModels.set(planElementViewModel.getId(), planElementViewModel);
            planElementViewModel.select();
            const planElementViewModels = Array.from(this._selectedPlanElementViewModels).map(([_id, planElement]) => planElement);
            this.dispatchEvent(2 /* SELECTION_EVENT.SELECT_PLAN_ELEMENT_MULTI */, new PlannerSelectionHandlerEvent({
                planElementViewModels,
            }));
            this.dispatchEvent(0 /* SELECTION_EVENT.SELECT_PLAN_ELEMENT */, new PlannerSelectionHandlerEvent({ planElementViewModel }));
        }
    }
    _deselectWallAndFloorElements() {
        this._selectedPlanElementViewModels.forEach((planElementViewModel, id) => {
            if (isWallOrFloor(planElementViewModel)) {
                this._selectedPlanElementViewModels.delete(id);
                planElementViewModel.deselect();
                this.dispatchEvent(1 /* SELECTION_EVENT.DESELECT_PLAN_ELEMENT */, new PlannerSelectionHandlerEvent({
                    planElementViewModel,
                }));
            }
        });
    }
    setSelectionMode(mode) {
        if (this._selectionMode === mode) {
            return;
        }
        if (mode === "multiselect" /* SELECTION_MODE.MULTISELECT */) {
            this._deselectWallAndFloorElements();
        }
        this._selectionMode = mode;
        this.dispatchEvent(15 /* PLANNER_SCENE_EVENT.SELECTION_MODE_CHANGED */, new PlannerSelectionHandlerEvent({
            selectionMode: mode,
        }));
    }
    getSelectionMode() {
        return this._selectionMode;
    }
    hasSelection() {
        return this._selectedPlanElementViewModels.size > 0;
    }
    hasMultiSelection() {
        return this._selectedPlanElementViewModels.size > 1;
    }
    getSelectedIds() {
        let result = [];
        this._selectedPlanElementViewModels.forEach((component) => result.push(component.getId()));
        return result;
    }
    isSelected(id) {
        return !!this._selectedPlanElementViewModels.get(id);
    }
}

class SceneEventInfo {
    constructor(data) {
        const { planElementViewModel, resetCamera, state, oldState, reason } = data;
        this.planElementViewModel = planElementViewModel;
        this.resetCamera = resetCamera === undefined ? true : resetCamera;
        this.state = state === undefined ? 0 /* PLANNER_SCENE_EVENT_STATE.IDLE */ : state;
        this.oldState =
            oldState === undefined ? 0 /* PLANNER_SCENE_EVENT_STATE.IDLE */ : oldState;
        this.reason = reason;
    }
}
class PlannerSceneEventHandler extends SceneEventHandler {
    constructor(creator, scene, camera, inputManager) {
        super(creator, scene, camera, inputManager);
        this._isDrawingEnabled = false;
        this._isCurrentlyDrawing = false;
        this._isMeasurementLineDrawActive = false;
        this._state = 0 /* PLANNER_SCENE_EVENT_STATE.IDLE */;
        this._inputManager.addEventListener(4 /* INPUT_EVENT.UP */, () => (this._position = null), this);
        this._raycastHelper.setMode(0 /* INTERSECTION_MODE.PLANNER */);
        this._raycastHelper.addEventListener(0 /* RAYCAST_EVENT.CLICK_OUTSIDE */, () => {
            if (this._state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */) {
                this.resetState();
                return;
            }
            this._plannerSelectionHandler.cancelSelection('click_outside');
        }, this);
        // don't we wait for SELECTION_EVENT.SELECT_PLAN_ELEMENT here?
        this._plannerSelectionHandler.addEventListener(0 /* PLANNER_SCENE_EVENT.SELECT_PLAN_ELEMENT */, ({ planElementViewModel }) => {
            this.dispatchEvent(0 /* PLANNER_SCENE_EVENT.SELECT_PLAN_ELEMENT */, new SceneEventInfo({ planElementViewModel }));
        }, this);
        this._plannerSelectionHandler.addEventListener(2 /* SELECTION_EVENT.SELECT_PLAN_ELEMENT_MULTI */, ({ planElementViewModels }) => {
            this._roomlePlannerUiCallback.onMultiSelectionChange(planElementViewModels);
        }, this);
        this._plannerSelectionHandler.addEventListener(15 /* PLANNER_SCENE_EVENT.SELECTION_MODE_CHANGED */, ({ selectionMode }) => {
            if (selectionMode === "multiselect" /* SELECTION_MODE.MULTISELECT */ &&
                this._hoveredObject) {
                this._hoverOnMultiSelect(this._hoveredObject);
            }
            this._roomlePlannerUiCallback.onSelectionModeChange(selectionMode);
        }, this);
        this._plannerSelectionHandler.addEventListener(1 /* PLANNER_SCENE_EVENT.DESELECT_PLAN_ELEMENT */, ({ planElementViewModel, reason }) => {
            // We skipped setting the state to idle for the drag event because the plan object gets selected automatically after dragging and
            // if there is an old object already selected, we deselect it to select the new dragged object and all this should happen
            // while the drag event is in progress. we set the state to idle inside the _dragEnd
            if (this._state !== 1 /* PLANNER_SCENE_EVENT_STATE.DRAG */) {
                this.setState(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
            }
            this.dispatchEvent(1 /* PLANNER_SCENE_EVENT.DESELECT_PLAN_ELEMENT */, new SceneEventInfo({ planElementViewModel, reason }));
        }, this);
        this._inputManager.addEventListener(6 /* INPUT_EVENT.MOVE */, (event) => this._move(event), this);
    }
    disable() {
        const layers = new Layers();
        layers.disableAll();
        this._raycastHelper.setLayers(layers);
        this._raycastHelper.disableEvents();
    }
    get planInteractionHandler() {
        var _a;
        return (_a = this._plannerKernelAccess) === null || _a === void 0 ? void 0 : _a.planInteractionHandler;
    }
    get hoveredObjectId() {
        var _a;
        if ((_a = this._hoveredObject) === null || _a === void 0 ? void 0 : _a.getPlanElement()) {
            return this._hoveredObject.getId();
        }
        return null;
    }
    enable() {
        const layers = new Layers();
        layers.disableAll();
        layers.enable(3 /* LAYER.OBJECT */);
        layers.enable(7 /* LAYER.GIZMO */);
        layers.enable(6 /* LAYER.UI */);
        layers.enable(9 /* LAYER.CONSTRUCTION */);
        layers.enable(2 /* LAYER.BACKGROUND */);
        this._raycastHelper.setLayers(layers);
        this._raycastHelper.enableEvents();
    }
    enableConstructionEvents(enable) {
        if (enable) {
            this._raycastHelper.getLayers().enable(9 /* LAYER.CONSTRUCTION */);
        }
        else {
            this._raycastHelper.getLayers().disable(9 /* LAYER.CONSTRUCTION */);
        }
    }
    enableObjectEvents(enable) {
        if (enable) {
            this._raycastHelper.getLayers().enable(6 /* LAYER.UI */);
        }
        else {
            this._raycastHelper.getLayers().disable(6 /* LAYER.UI */);
        }
    }
    getSelectionMode() {
        return this._plannerSelectionHandler.getSelectionMode();
    }
    addPlanObjectHandlers(planObjectViewModel, object) {
        if (!object) {
            object = planObjectViewModel.getBoundingBox();
        }
        const planObjectEventInfo = {
            hasListener: true,
            priority: 1,
            roomleId: planObjectViewModel.getId(),
        };
        this._addPlanObjectHandlers(planObjectViewModel, object, planObjectEventInfo);
    }
    addWallHandlers(planElementViewModel) {
        this._addPlanElementHandlers(planElementViewModel, planElementViewModel.getObject(), {
            hasListener: true,
            priority: 1,
            roomleId: planElementViewModel.getId(),
        });
    }
    addMeasurementLineHandlers(planElementViewModel) {
        const componentEventInfo = {
            hasListener: true,
            priority: 1,
            roomleId: planElementViewModel.getId(),
        };
        this._addMeasurementLinePlanElementHandlers(planElementViewModel, planElementViewModel.getPoint1DraggableBoundingBox(), componentEventInfo, MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1);
        this._addMeasurementLinePlanElementHandlers(planElementViewModel, planElementViewModel.getPoint2DraggableBoundingBox(), componentEventInfo, MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2);
        this._addElementHandlers(planElementViewModel, planElementViewModel.getBoundingBox(), componentEventInfo);
    }
    addFloorHandlers(planElementViewModel) {
        this._addFloorElementHandlers(planElementViewModel, planElementViewModel.getObject(), {
            hasListener: true,
            priority: 1,
            roomleId: planElementViewModel.getId(),
        });
    }
    addNodeHandlers(planElementViewModel) {
        this._addPlanElementHandlers(planElementViewModel, planElementViewModel.getBoundingBox(), {
            hasListener: true,
            priority: 1,
            roomleId: planElementViewModel.getId(),
        });
    }
    _addPlanObjectHandlers(planObjectViewModel, object, componentEventInfo) {
        if (!object.userData.hasListener) {
            object.userData = deepMerge(object.userData, componentEventInfo);
            object.addEventListener("select" /* OBJECT_EVENT.CLICK */, () => this._clickElement(planObjectViewModel));
            object.addEventListener("drag_start" /* OBJECT_EVENT.DRAG_START */, () => this._dragStart(planObjectViewModel));
            object.addEventListener("drag" /* OBJECT_EVENT.DRAG */, (event) => this._drag(planObjectViewModel, event.attachment.position));
            object.addEventListener("drag_end" /* OBJECT_EVENT.DRAG_END */, (event) => this._dragEnd(planObjectViewModel, event.attachment.position));
            object.addEventListener("hover_on" /* OBJECT_EVENT.HOVER_ON */, () => this._hoverOn(planObjectViewModel));
            object.addEventListener("hover_off" /* OBJECT_EVENT.HOVER_OFF */, () => this._hoverOff(planObjectViewModel));
            object.addEventListener("rotate" /* OBJECT_EVENT.ROTATE */, (event) => this._rotate(planObjectViewModel, event.attachment.rotation));
        }
    }
    _addFloorElementHandlers(planElementViewModel, object, componentEventInfo) {
        this._addElementHandlers(planElementViewModel, object, componentEventInfo);
    }
    _addElementHandlers(planElementViewModel, object, componentEventInfo) {
        if (!object.userData.hasListener) {
            object.userData = deepMerge(object.userData, componentEventInfo);
            object.addEventListener("select" /* OBJECT_EVENT.CLICK */, () => this._clickElement(planElementViewModel));
            object.addEventListener("double_click" /* OBJECT_EVENT.DOUBLE_CLICK */, (event) => {
                var _a;
                this._doubleClickElement(planElementViewModel, event.attachment.type, (_a = event.attachment.intersection) === null || _a === void 0 ? void 0 : _a.point);
            });
            object.addEventListener("hover_on" /* OBJECT_EVENT.HOVER_ON */, () => this._hoverOn(planElementViewModel));
            object.addEventListener("hover_off" /* OBJECT_EVENT.HOVER_OFF */, () => this._hoverOff(planElementViewModel));
        }
    }
    _addPlanElementHandlers(planElementViewModel, object, componentEventInfo) {
        if (!object.userData.hasListener) {
            this._addElementHandlers(planElementViewModel, object, componentEventInfo);
            object.addEventListener("drag_start" /* OBJECT_EVENT.DRAG_START */, () => this._dragStart(planElementViewModel));
            object.addEventListener("drag" /* OBJECT_EVENT.DRAG */, (event) => this._drag(planElementViewModel, event.attachment.position));
            object.addEventListener("drag_end" /* OBJECT_EVENT.DRAG_END */, (event) => this._dragEnd(planElementViewModel, event.attachment.position));
        }
    }
    _addMeasurementLinePlanElementHandlers(planElementViewModel, object, componentEventInfo, point) {
        if (object.userData.hasListener) {
            return;
        }
        object.userData = deepMerge(object.userData, componentEventInfo);
        const updateCurrentPoint = () => {
            planElementViewModel.currentPoint = point;
        };
        object.addEventListener("select" /* OBJECT_EVENT.CLICK */, () => {
            this._clickElement(planElementViewModel);
            updateCurrentPoint();
        });
        object.addEventListener("drag_start" /* OBJECT_EVENT.DRAG_START */, () => {
            updateCurrentPoint();
            planElementViewModel.selectPointOnDragStart(planElementViewModel);
            this._dragStart(planElementViewModel);
        });
        object.addEventListener("drag" /* OBJECT_EVENT.DRAG */, (event) => {
            updateCurrentPoint();
            planElementViewModel.hideDraggablePointsOnDragStart(planElementViewModel, point);
            this._drag(planElementViewModel, event.attachment.position);
        });
        object.addEventListener("drag_end" /* OBJECT_EVENT.DRAG_END */, (event) => {
            planElementViewModel.showDraggablePointsOnDragEnd(planElementViewModel, point);
            this._dragEnd(planElementViewModel, event.attachment.position);
            planElementViewModel.showDraggableNodes();
            updateCurrentPoint();
        });
        object.addEventListener("hover_on" /* OBJECT_EVENT.HOVER_ON */, () => {
            updateCurrentPoint();
            planElementViewModel.showDraggablePointsOnHoverOn(planElementViewModel);
            this._hoverOn(planElementViewModel);
        });
        object.addEventListener("hover_off" /* OBJECT_EVENT.HOVER_OFF */, () => {
            updateCurrentPoint();
            planElementViewModel.showDraggablePointsOnHoverOff(planElementViewModel);
            this._hoverOff(planElementViewModel);
        });
    }
    _createFloorMeshWithHandler() {
        const geo = new PlaneGeometry(1000, 1000, 8, 8);
        const mat = new MeshBasicMaterial();
        mat.visible = false;
        const plane = new Mesh(geo, mat);
        plane.name = '2D raycaster floor mesh';
        plane.rotation.set(-Math.PI / 2, 0, 0);
        plane.layers.enable(2 /* LAYER.BACKGROUND */);
        plane.userData.ignoreElementHit = true;
        const componentEventInfo = {
            hasListener: true,
            priority: 0.9,
            roomleId: undefined,
        };
        plane.userData = deepMerge(plane.userData, componentEventInfo);
        plane.addEventListener("double_click" /* OBJECT_EVENT.DOUBLE_CLICK */, (event) => {
            this._doubleClickOnPlane(convertToKernel(event.attachment.intersection.point), event.attachment.type);
        });
        plane.addEventListener("select" /* OBJECT_EVENT.CLICK */, (event) => {
            const clickPoint = convertToKernel(event.attachment.intersection.point);
            if (!this._isCurrentlyDrawing) {
                this._plannerSelectionHandler.cancelSelection('select_other');
            }
            else {
                this._clickOnPlane(clickPoint);
            }
        });
        return plane;
    }
    _clickOnPlane(point) {
        this._createNode(null, point);
    }
    _doubleClickOnPlane(point, inputType = 0 /* INPUT_EVENT_TYPE.UNKNOWN */) {
        if (this._isMeasurementLineDrawActive) {
            return;
        }
        if (!this._closeToPoint(point)) {
            this._toggleDrawing(null, point, inputType);
        }
        else {
            this.stopDrawing();
        }
    }
    _closeToPoint(point) {
        let closeToPoint = false;
        for (const nodePlanViewModel of this._planViewModel.getNodePlanObjectViewModels()) {
            if (this._close(nodePlanViewModel.getPlanElement().getCenter(), point)) {
                closeToPoint = true;
            }
        }
        return closeToPoint;
    }
    _close(point1, point2) {
        const maxDistance = 500;
        return (Math.abs(point1.x - point2.x) < maxDistance &&
            Math.abs(point1.y - point2.y) < maxDistance &&
            Math.abs(point1.z - point2.z) < maxDistance);
    }
    _clickElement(planElementViewModel) {
        if (this._isCurrentlyDrawing) {
            return;
        }
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            planElementViewModel.handleDraggablePointsSelection(planElementViewModel);
        }
        if (this._debug) {
            console.log('select', planElementViewModel.getId());
        }
        if (this._state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */) {
            this.resetState();
            return;
        }
        this._plannerSelectionHandler.check(planElementViewModel);
        this._roomlePlannerUiCallback.onClickElement(planElementViewModel);
        this._setCursor();
    }
    _doubleClickElement(planElementViewModel, inputType = 0 /* INPUT_EVENT_TYPE.UNKNOWN */, intersectionPoint) {
        if (!this._isDrawingEnabled ||
            (!(planElementViewModel instanceof NodePlanElementViewModel) &&
                !(planElementViewModel instanceof WallPlanElementViewModel))) {
            return;
        }
        if (this._debug) {
            console.log('double click', planElementViewModel.getId());
        }
        if (planElementViewModel instanceof WallPlanElementViewModel) {
            this._plannerSelectionHandler.cancelSelection('double_click_wall');
        }
        let kernelPosition;
        if (planElementViewModel instanceof NodePlanElementViewModel) {
            kernelPosition = planElementViewModel.getPlanElement().getCenter();
        }
        else if (intersectionPoint) {
            kernelPosition = convertToKernel(new Vector3(intersectionPoint.x, 0, intersectionPoint.z));
        }
        if (this._isCurrentlyDrawing) {
            this._endWallDrawing(null, kernelPosition);
        }
        else {
            this._startWallDrawing(null, kernelPosition, inputType);
        }
    }
    _hoverOn(planElementViewModel) {
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            planElementViewModel.showDraggablePointsOnHoverOn(planElementViewModel);
        }
        if (this._isCurrentlyDrawing) {
            return;
        }
        if (this._plannerSelectionHandler.getSelectionMode() ===
            "multiselect" /* SELECTION_MODE.MULTISELECT */) {
            this._hoverOnMultiSelect(planElementViewModel);
        }
        else {
            this._hoverOnStandard(planElementViewModel);
        }
    }
    _hoverOnMultiSelect(planElementViewModel) {
        if (isWallOrFloor(this._hoveredObject) ||
            isWallOrFloor(planElementViewModel)) {
            this._hoveredObject = null;
            setCursor("default" /* CURSOR_STYLE.DEFAULT */);
        }
        else {
            this._hoverOnStandard(planElementViewModel);
        }
    }
    _hoverOnStandard(planElementViewModel) {
        planElementViewModel.hoverOn();
        this._hoveredObject = planElementViewModel;
        this.dispatchEvent(3 /* PLANNER_SCENE_EVENT.HOVER_ON */, new SceneEventInfo({ planElementViewModel }));
        this._interaction();
        this._setCursor();
    }
    _hoverOff(planElementViewModel) {
        planElementViewModel.hoverOff();
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            planElementViewModel.showDraggablePointsOnHoverOff(planElementViewModel);
        }
        this.dispatchEvent(4 /* PLANNER_SCENE_EVENT.HOVER_OFF */, new SceneEventInfo({ planElementViewModel }));
        this._interaction();
        this._hoveredObject = null;
        this._setCursor();
    }
    _isHoveredObjectNonDraggable() {
        return this._hoveredObject instanceof FloorPlanElementViewModel;
    }
    _setCursor() {
        if (this._state === 4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */) {
            setCursor("crosshair" /* CURSOR_STYLE.NODE_HOVER */);
        }
        else if (this._state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */ &&
            this._hasSelection()) {
            setCursor("ew-resize" /* CURSOR_STYLE.ROTATE */);
        }
        else if (this._state === 1 /* PLANNER_SCENE_EVENT_STATE.DRAG */) {
            setCursor("grabbing" /* CURSOR_STYLE.DRAGGING */);
        }
        else if (!this._isHoveredObjectNonDraggable &&
            this._plannerSelectionHandler.isSelected(this.hoveredObjectId)) {
            setCursor("move" /* CURSOR_STYLE.MOVE */);
        }
        else if (this._hoveredObject) {
            setCursor("pointer" /* CURSOR_STYLE.HOVER */);
        }
        else if (this._state === 3 /* PLANNER_SCENE_EVENT_STATE.DRAW */) {
            if (isSafari) {
                setCursor("url('https://res.cloudinary.com/roomle/image/upload/v1664957371/pencil_j5vkhm.svg') 0 15, auto" /* CURSOR_STYLE.DRAW_FALLBACK */);
            }
            else {
                setCursor("url('https://res.cloudinary.com/roomle/image/upload/v1664957371/pencil_j5vkhm.svg') 3 20, auto" /* CURSOR_STYLE.DRAW */);
            }
        }
        else {
            setCursor("default" /* CURSOR_STYLE.DEFAULT */);
        }
    }
    setCamera(camera) {
        this._raycastHelper.setCamera(camera);
    }
    setScene(scene) {
        this._raycastHelper.setScene(scene);
    }
    getSelectedIds() {
        return this._plannerSelectionHandler.getSelectedIds();
    }
    setSelectionMode(selectionMode) {
        this._plannerSelectionHandler.setSelectionMode(selectionMode);
    }
    setPlanViewModel(planViewModel) {
        this._planViewModel = planViewModel;
    }
    cancelSelection(reason) {
        this._plannerSelectionHandler.cancelSelection(reason);
    }
    removeSelection() {
        this._plannerSelectionHandler.removeSelection();
    }
    _dragStart(planElementViewModel) {
        if (this._isMeasurementLineDrawActive) {
            return;
        }
        if (((!this._plannerSelectionHandler.isSelected(planElementViewModel.getId()) &&
            !this._dragIn) ||
            this._state !== 0 /* PLANNER_SCENE_EVENT_STATE.IDLE */) &&
            !this._isDrawingEnabled) {
            return;
        }
        this.dispatchEvent(8 /* PLANNER_SCENE_EVENT.BEFORE_DRAG_START */);
        wait(INPUT_DELAY_TYPE.DRAG).then(() => {
            if (this._inputManager.isMouseUp()) {
                this.setState(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
                setCursor("pointer" /* CURSOR_STYLE.HOVER */);
                this.dispatchEvent(12 /* PLANNER_SCENE_EVENT.DRAG_CANCEL */);
                return;
            }
            this._draggedObject = planElementViewModel;
            this.setState(1 /* PLANNER_SCENE_EVENT_STATE.DRAG */);
            this._roomlePlannerUiCallback.onDragElementStart();
            this.dispatchEvent(9 /* PLANNER_SCENE_EVENT.DRAG_START */, new SceneEventInfo({ planElementViewModel }));
        });
    }
    _drag(planElementViewModel, position) {
        if (!this._draggedObject ||
            this._state !== 1 /* PLANNER_SCENE_EVENT_STATE.DRAG */) {
            return;
        }
        const planInteractionHandler = this.planInteractionHandler;
        if (this._plannerSelectionHandler.getSelectedIds().length > 1) {
            const planObjectPtrList = new this._plannerKernelAccess.kernelContainer.PlanObjectPtrList();
            let distance = position.sub(this._draggedObject.getPosition());
            this._plannerSelectionHandler
                .getSelectedIds()
                .forEach((id) => planObjectPtrList.push_back(this._planViewModel.getPlanObjectForId(id).getPlanElement()));
            const vector3 = convertToKernel(distance);
            // Fix z position so multiple selected items don't climb walls on move.
            if (this._plannerSelectionHandler.hasMultiSelection()) {
                vector3.z = 0;
            }
            planInteractionHandler.moveObjectsBy(planObjectPtrList, vector3);
        }
        else if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            this._dragMeasurementLine(planElementViewModel, position);
        }
        else {
            const isWallOrNode = planElementViewModel instanceof NodePlanElementViewModel ||
                planElementViewModel instanceof WallPlanElementViewModel;
            if (isWallOrNode ||
                this._planViewModel.cameraType === CAMERA_TYPE.CAMERA_2D) {
                this._plannerSelectionHandler.check(planElementViewModel);
                position.y = convertToTHREE(planElementViewModel.getPlanElement().getCenter()).y;
            }
            planInteractionHandler.moveElementTo(planElementViewModel.getPlanElement(), convertToKernel(position));
        }
        this.dispatchEvent(10 /* PLANNER_SCENE_EVENT.DRAG_MOVE */, new SceneEventInfo({ planElementViewModel }));
    }
    _dragEnd(planElementViewModel, _position) {
        if (!this._draggedObject) {
            return;
        }
        this._draggedObject = null;
        this.setState(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
        this.dispatchEvent(11 /* PLANNER_SCENE_EVENT.DRAG_END */, new SceneEventInfo({ planElementViewModel }));
        if (this._dragIn) {
            this.setDragIn(false);
        }
        this._roomlePlannerUiCallback.onDragElementEnd();
        this._setCursor();
    }
    _rotate(planElementViewModel, rotation) {
        if (this._plannerSelectionHandler.isSelected(planElementViewModel.getId())) {
            const planInteractionHandler = this.planInteractionHandler;
            const planObject = planElementViewModel.getPlanObject();
            planInteractionHandler.setObjectRotation(planElementViewModel.getPlanElement(), planObject.rotation - rotation);
        }
    }
    setState(state) {
        var _a, _b;
        const oldState = this._state;
        this._state = state;
        this._setCursor();
        this.dispatchEvent(2 /* PLANNER_SCENE_EVENT.STATE_CHANGED */, new SceneEventInfo({ state: this._state, oldState }));
        this._position = null;
        if (this._state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */) {
            (_a = this.planInteractionHandler) === null || _a === void 0 ? void 0 : _a.deactivateAllSnappingActivity();
        }
        else if (oldState === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */) {
            (_b = this.planInteractionHandler) === null || _b === void 0 ? void 0 : _b.reactivateAllSnappingActivity();
        }
    }
    resetState() {
        this.setState(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
    }
    _move(event) {
        if (this._state === 3 /* PLANNER_SCENE_EVENT_STATE.DRAW */ ||
            this._state === 4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */) {
            return;
        }
        if (this._state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */) {
            if (this._hasSelection()) {
                this._setCursor();
                let delta = Math.PI / 180;
                const { x, y } = event.positionRelative;
                if (this._position) {
                    // rotate 1.4 * 180 degree to the left and right to enable a full rotation if 30% of screen are hidden be menus
                    delta =
                        event.positionRelative.x * 1.4 * Math.PI -
                            this._position.x * 1.4 * Math.PI;
                }
                else {
                    this._position = new Vector3(event.positionRelative.x, event.positionRelative.y, 0);
                }
                const list = new this._plannerKernelAccess.kernelContainer.PlanObjectPtrList();
                const bounds = new Box3();
                this.getSelectedIds().forEach((id) => {
                    var _a;
                    const planObjectViewModel = (_a = this._planViewModel) === null || _a === void 0 ? void 0 : _a.getPlanObjectForId(id);
                    if (planObjectViewModel && planObjectViewModel.getObject()) {
                        list.push_back(planObjectViewModel.getPlanElement());
                        bounds.expandByObject(planObjectViewModel.getContainer());
                    }
                });
                const center = bounds.getCenter(new Vector3());
                const planInteractionHandler = this.planInteractionHandler;
                planInteractionHandler.rotateObjectsBy(list, delta, convertToKernel(center));
                this._position.copy(new Vector3(x, y, 0));
            }
        }
    }
    _hasSelection() {
        return this._plannerSelectionHandler.getSelectedIds().length > 0;
    }
    async selectPlanElement(planElement) {
        if (planElement instanceof ConfiguratorPlanObjectViewModel ||
            planElement instanceof StaticPlanObjectViewModel) {
            await planElement.isInitDone();
        }
        this._plannerSelectionHandler.check(planElement);
    }
    _interaction(_forceRender) {
        this.dispatchEvent(13 /* PLANNER_SCENE_EVENT.INTERACTION */, new SceneEventInfo({}));
    }
    addComponentDragInHandler(planViewModel) {
        if (!this._dragIn) {
            return;
        }
        const boundingBox = planViewModel.getBoundingBox();
        this._addPlanElementHandlers(planViewModel, boundingBox, {
            hasListener: true,
            priority: 1,
            roomleId: planViewModel.getId(),
        });
        this._raycastHelper.enableDragIn(boundingBox);
        this._dragStart(planViewModel);
    }
    enableSnapping() {
        this.planInteractionHandler.snapObjectsToWalls = true;
    }
    disableSnapping() {
        this.planInteractionHandler.snapObjectsToWalls = false;
    }
    enableWallDrawing() {
        this._isDrawingEnabled = true;
        this._drawingGroup = new Group();
        this._drawingGroup.name = 'Drawing';
        this._drawingGroup.add(this._createFloorMeshWithHandler());
        this._inputManager.addEventListener(6 /* INPUT_EVENT.MOVE */, this._drawWallOnMouseMove, this);
        this._inputManager.addEventListener(13 /* INPUT_EVENT.TOUCH_END */, this._endWallDrawing, this);
        return this._drawingGroup;
    }
    cancelWallDrawing() {
        this._isDrawingEnabled = false;
        this._setStateAndCursor(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
        this._inputManager.removeEventListener(6 /* INPUT_EVENT.MOVE */, this._drawWallOnMouseMove);
        this._inputManager.removeEventListener(13 /* INPUT_EVENT.TOUCH_END */, this._endWallDrawing);
        this._raycastHelper.clear();
        return this._drawingGroup;
    }
    stopDrawing(cancelDrawing = true) {
        var _a;
        this.planInteractionHandler.endInteraction();
        if (cancelDrawing) {
            this.planInteractionHandler.cancelDrawing();
        }
        this._raycastHelper.getLayers().enable(9 /* LAYER.CONSTRUCTION */);
        this._isCurrentlyDrawing = false;
        this._setStateAndCursor(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
        this.dispatchEvent(7 /* PLANNER_SCENE_EVENT.DRAWING_END */);
        (_a = this._continuousDrawingHelper) === null || _a === void 0 ? void 0 : _a.endDrawing();
    }
    startDrawing() {
        var _a;
        if (this._isCurrentlyDrawing) {
            return;
        }
        this._isCurrentlyDrawing = true;
        this._raycastHelper.getLayers().disable(9 /* LAYER.CONSTRUCTION */);
        this.dispatchEvent(6 /* PLANNER_SCENE_EVENT.DRAWING_START */);
        this._setStateAndCursor(3 /* PLANNER_SCENE_EVENT_STATE.DRAW */);
        (_a = this._continuousDrawingHelper) === null || _a === void 0 ? void 0 : _a.update();
    }
    _toggleDrawing(event, point, inputType) {
        if (this._isCurrentlyDrawing) {
            this._endWallDrawing(event, point);
        }
        else {
            this._startWallDrawing(event, point, inputType);
        }
    }
    _endWallDrawing(event, point) {
        if (this._isCurrentlyDrawing) {
            if (this.planInteractionHandler
                .getContinuousDrawingManager()
                .shouldShowCircle() &&
                this.planInteractionHandler
                    .getContinuousDrawingManager()
                    .shouldShowCircle()) {
                this.planInteractionHandler.cancelDrawing();
            }
            else {
                const { x, y } = point
                    ? point
                    : this._getIntersectionPointWithScene(event);
                this.planInteractionHandler.endDrawing({ x, y, z: 0 });
            }
            this.stopDrawing(false);
        }
    }
    async _startWallDrawing(event, point, inputType) {
        if ((event && event.type === 2 /* INPUT_EVENT_TYPE.TOUCH */) ||
            inputType === 2 /* INPUT_EVENT_TYPE.TOUCH */) {
            await this._initMobileDrawing();
            this._continuousDrawingHelper.update();
        }
        this.planInteractionHandler.startInteraction();
        const { x, y } = point ? point : this._getIntersectionPointWithScene(event);
        this.planInteractionHandler.beginDrawing({ x, y, z: 0 });
        this.startDrawing();
    }
    async _initMobileDrawing() {
        this.planInteractionHandler.setDrawingType(0 /* DrawingType.CONTINOUS */);
        this.planInteractionHandler.setSnapFeedbackWhileDrawing(true);
        if (!this._continuousDrawingHelper) {
            const { default: ContinuousDrawingHelperClass } = await import('./continuous-drawing-helper-605f2e98.js');
            this._continuousDrawingHelper = new ContinuousDrawingHelperClass();
            this._continuousDrawingHelper.init(this._drawingGroup, this.planInteractionHandler.getContinuousDrawingManager(), this._kernelZoomFactor);
        }
    }
    _drawWallOnMouseMove(event) {
        var _a;
        if (!this._isCurrentlyDrawing || this._isMeasurementLineDrawActive) {
            return;
        }
        const { x, y } = this._getIntersectionPointWithScene(event);
        this.planInteractionHandler.currentDrawingPosition({ x, y, z: 0 });
        (_a = this._continuousDrawingHelper) === null || _a === void 0 ? void 0 : _a.update();
        this.dispatchEvent(5 /* PLANNER_SCENE_EVENT.DRAW */);
    }
    _createNode(event, point) {
        if (!this._isCurrentlyDrawing) {
            return;
        }
        const { x, y } = point ? point : this._getIntersectionPointWithScene(event);
        this.planInteractionHandler.forceNode({ x, y, z: 0 });
        this._raycastHelper.clear();
    }
    _getIntersectionPointWithScene(event) {
        return this._raycastHelper.intersectMouseOnScene(event);
    }
    _setStateAndCursor(state) {
        this.setState(state);
        this._setCursor();
    }
    setKernelZoomFactor(kernelZoomFactor) {
        var _a;
        this._kernelZoomFactor = kernelZoomFactor;
        (_a = this._continuousDrawingHelper) === null || _a === void 0 ? void 0 : _a.setKernelZoomFactor(kernelZoomFactor);
    }
    enableMeasurementLineDrawing() {
        this._setStateAndCursor(4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */);
        this._isMeasurementLineDrawActive = true;
        this._enableDrawingListeners();
    }
    disableMeasurementLineDrawing() {
        this._disableDrawingListeners();
        this.dispatchEvent(17 /* PLANNER_SCENE_EVENT.ADD_MEASUREMENT_LINE_END */);
        this.setState(0 /* PLANNER_SCENE_EVENT_STATE.IDLE */);
        this._isMeasurementLineDrawActive = false;
        this._currentPlanMeasure = null;
    }
    _handleMeasurementLineDrawingEvent(eventNumber) {
        if (eventNumber === 6 /* INPUT_EVENT.MOVE */) {
            return this._drawMeasurementLineOnMouseMove;
        }
        else if (eventNumber === 5 /* INPUT_EVENT.CLICK */ ||
            eventNumber === 14 /* INPUT_EVENT.LONG_TOUCH */ ||
            eventNumber === 13 /* INPUT_EVENT.TOUCH_END */) {
            return this._createPlanMeasure;
        }
        return null;
    }
    _enableDrawingListeners() {
        const events = [
            5 /* INPUT_EVENT.CLICK */,
            6 /* INPUT_EVENT.MOVE */,
            14 /* INPUT_EVENT.LONG_TOUCH */,
            13 /* INPUT_EVENT.TOUCH_END */,
        ];
        events.forEach((eventType) => {
            this._inputManager.addEventListener(eventType, this._handleMeasurementLineDrawingEvent(eventType), this);
        });
    }
    _disableDrawingListeners() {
        const events = [
            5 /* INPUT_EVENT.CLICK */,
            6 /* INPUT_EVENT.MOVE */,
            14 /* INPUT_EVENT.LONG_TOUCH */,
            13 /* INPUT_EVENT.TOUCH_END */,
        ];
        events.forEach((eventType) => {
            this._inputManager.removeEventListener(eventType, this._handleMeasurementLineDrawingEvent(eventType));
        });
    }
    _drawMeasurementLineOnMouseMove(event) {
        if (!this._currentPlanMeasure) {
            return;
        }
        if (this._state !== 4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */) {
            this._setStateAndCursor(4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */);
        }
        const { x, y } = this._getIntersectionPointWithScene(event);
        this.planInteractionHandler.setMeasurePoint2(this._currentPlanMeasure, {
            x,
            y,
            z: 0,
        });
    }
    _updateMeasurementLineViewModels(action) {
        if (action === 'hide_dragged_node') {
            this._planViewModel
                .getMeasurementLineObjectViewModels()
                .forEach((viewModel) => {
                if (this._currentPlanMeasure.getId() === viewModel.getId()) {
                    viewModel.hidePoint2DraggableNode();
                }
            });
        }
        else if (action === 'showDraggableNodes') {
            this._planViewModel
                .getMeasurementLineObjectViewModels()
                .forEach((viewModel) => {
                if (this._currentPlanMeasure.getId() === viewModel.getId()) {
                    viewModel.showDraggableNodes();
                    viewModel.showDraggablePointsOnDragEnd(viewModel, 'point2');
                }
            });
        }
    }
    _createPlanMeasure(event) {
        const { x, y } = this._getIntersectionPointWithScene(event);
        const position = { x, y, z: 0 };
        if (!this._currentPlanMeasure) {
            this.dispatchEvent(16 /* PLANNER_SCENE_EVENT.ADD_MEASUREMENT_LINE_START */);
            this._currentPlanMeasure = this.planInteractionHandler.addMeasure(position, position);
            this._updateMeasurementLineViewModels('hide_dragged_node');
            return;
        }
        this.planInteractionHandler.setMeasurePoint2(this._currentPlanMeasure, position);
        this._updateMeasurementLineViewModels('showDraggableNodes');
        this.disableMeasurementLineDrawing();
    }
    _dragMeasurementLine(planElementViewModel, newPosition) {
        const planMeasure = planElementViewModel.getPlanElement();
        if (planElementViewModel.currentPoint ===
            MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT1) {
            this.planInteractionHandler.setMeasurePoint1(planMeasure, convertToKernel(newPosition));
        }
        if (planElementViewModel.currentPoint ===
            MEASUREMENTS_LINE_DRAGGABLE_POINTS_NAME.POINT2) {
            this.planInteractionHandler.setMeasurePoint2(planMeasure, convertToKernel(newPosition));
        }
    }
}
__decorate([
    inject
], PlannerSceneEventHandler.prototype, "_plannerSelectionHandler", void 0);
__decorate([
    inject
], PlannerSceneEventHandler.prototype, "_plannerKernelAccess", void 0);
__decorate([
    inject
], PlannerSceneEventHandler.prototype, "_roomlePlannerUiCallback", void 0);

const GROUP_CONSTRUCTION = 'Construction';
const GROUP_CEILING = 'Ceiling';
const GROUP_FLOOR = 'Floor';
const GROUP_MEASUREMENT_LINE = 'Measurement Line';
class PlanViewModel extends ConfiguratorViewModel {
    constructor(creator) {
        super(creator);
        this._configurablePlanObjectViewModels = [];
        this._staticPlanObjectViewModels = [];
        this._constructionPlanObjectViewModels = [];
        this._wallPlanObjectViewModels = [];
        this._measurementLinePlanObjectViewModels = [];
        this._floorPlanObjectViewModels = [];
        this._nodePlanObjectViewModels = [];
        this._constructionGroup = new Group();
        this._constructionGroup.name = GROUP_CONSTRUCTION;
        this._ceilingGroup = new Group();
        this._ceilingGroup.name = GROUP_CEILING;
        this._floorGroup = new Group();
        this._floorGroup.name = GROUP_FLOOR;
        this._measurementLineGroup = new Group();
        this._measurementLineGroup.name = GROUP_MEASUREMENT_LINE;
        this._getKernelAccess().addPlannerListener(this);
    }
    startedDrawing() {
        // unused
    }
    stoppedDrawing() {
        // unused
    }
    planBoundsChanged() {
        // unused
    }
    setReference(plan) {
        this._coreReference = plan.clone();
    }
    clearReference() {
        this._coreReference.delete();
        this._coreReference = null;
    }
    getCorePlan() {
        return this._coreReference;
    }
    addPlanElementViewModel(planElementViewModel) {
        if (planElementViewModel instanceof ConfiguratorPlanObjectViewModel) {
            this._handleConfiguratorPlanObjectViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof ConstructionPlanObjectViewModel) {
            this._handleConstructionPlanObjectViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof StaticPlanObjectViewModel) {
            this._handleStaticPlanObjectViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            this._handleMeasurementLinePlanElementViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof WallPlanElementViewModel) {
            this._handleWallPlanElementViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof FloorPlanElementViewModel) {
            this._handleFloorPlanElementViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof CeilingPlanElementViewModel) {
            this._handleCeilingPlanElementViewModel(planElementViewModel);
        }
        else if (planElementViewModel instanceof NodePlanElementViewModel) {
            this._handleNodePlanElementViewModel(planElementViewModel);
        }
    }
    _handleConfiguratorPlanObjectViewModel(viewModel) {
        this._configurablePlanObjectViewModels.push(viewModel);
    }
    _handleConstructionPlanObjectViewModel(viewModel) {
        this._constructionPlanObjectViewModels.push(viewModel);
        this.commonHandlerForEditableAndTopView(viewModel);
    }
    _handleStaticPlanObjectViewModel(viewModel) {
        this._staticPlanObjectViewModels.push(viewModel);
        this.commonHandlerForEditableAndTopView(viewModel);
    }
    _handleMeasurementLinePlanElementViewModel(viewModel) {
        if (this._initData.edit) {
            this._plannerSceneEventHandler.addMeasurementLineHandlers(viewModel);
        }
        viewModel.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D);
        viewModel.getPoint1Draggable().scale.setScalar(this._nodeZoom);
        viewModel.getPoint2Draggable().scale.setScalar(this._nodeZoom);
        this._measurementLinePlanObjectViewModels.push(viewModel);
        this._measurementLineGroup.add(viewModel.getContainer());
    }
    _handleWallPlanElementViewModel(viewModel) {
        if (this._initData.edit) {
            this._plannerSceneEventHandler.addWallHandlers(viewModel);
        }
        viewModel.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D);
        this._wallPlanObjectViewModels.push(viewModel);
        this._constructionGroup.add(viewModel.getContainer());
    }
    _handleFloorPlanElementViewModel(viewModel) {
        const floor = viewModel.getContainer();
        floor.name = 'Floor';
        if (this._initData.edit) {
            this._plannerSceneEventHandler.addFloorHandlers(viewModel);
        }
        this._floorPlanObjectViewModels.push(viewModel);
        this._floorGroup.add(floor);
    }
    _handleCeilingPlanElementViewModel(viewModel) {
        this._ceilingGroup.add(viewModel.getContainer());
    }
    _handleNodePlanElementViewModel(viewModel) {
        if (this._initData.edit) {
            this._plannerSceneEventHandler.addNodeHandlers(viewModel);
        }
        viewModel.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D);
        viewModel.getObject().scale.setScalar(this._nodeZoom);
        this._nodePlanObjectViewModels.push(viewModel);
        this._constructionGroup.add(viewModel.getContainer());
    }
    commonHandlerForEditableAndTopView(viewModel) {
        if (this._initData.edit) {
            this._plannerSceneEventHandler.addPlanObjectHandlers(viewModel);
        }
        viewModel.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D);
    }
    _addRootComponent(component) {
        const planViewModel = this._getPlanObjectViewModelForRuntimeId(component.parentObjectId);
        if (planViewModel &&
            planViewModel instanceof ConfiguratorPlanObjectViewModel) {
            planViewModel.addRootComponent(component);
            if (this._initData.edit) {
                this._plannerSceneEventHandler.addPlanObjectHandlers(planViewModel);
            }
            planViewModel.hidePreviewBox();
        }
    }
    _getPlanObjectViewModelForRuntimeId(runtimeId) {
        let result = null;
        this._configurablePlanObjectViewModels.forEach((planObjectViewModel) => {
            if (runtimeId === planObjectViewModel.getConfigurationRuntimeId()) {
                result = planObjectViewModel;
            }
        });
        return result;
    }
    getConfigurablePlanObjectForId(id) {
        for (const planObjectViewModel of this._configurablePlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        return null;
    }
    getStaticPlanObjectForId(id) {
        for (const planObjectViewModel of this._staticPlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        return null;
    }
    getConstructionObjectForId(id) {
        for (const planObjectViewModel of this._constructionPlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        return null;
    }
    getStaticPlanObjectViewModelForId(id) {
        const staticObj = this.getStaticPlanObjectForId(id);
        if (staticObj) {
            return staticObj;
        }
        return this.getConstructionObjectForId(id);
    }
    getPlanObjectForId(id) {
        const configurablePlanObject = this.getConfigurablePlanObjectForId(id);
        if (configurablePlanObject) {
            return configurablePlanObject;
        }
        const staticPlanObject = this.getStaticPlanObjectForId(id);
        if (staticPlanObject) {
            return staticPlanObject;
        }
        for (const planObjectViewModel of this._nodePlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        for (const planObjectViewModel of this._wallPlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        for (const planObjectViewModel of this
            ._measurementLinePlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        for (const planObjectViewModel of this._floorPlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        for (const planObjectViewModel of this._constructionPlanObjectViewModels) {
            if (id === planObjectViewModel.getId()) {
                return planObjectViewModel;
            }
        }
        return null;
    }
    getPlanObjectViewModelsFromRapiId() {
        return [
            ...this._configurablePlanObjectViewModels,
            ...this._staticPlanObjectViewModels,
        ];
    }
    getPlanObjectCount() {
        return (this._configurablePlanObjectViewModels.length +
            this._staticPlanObjectViewModels.length);
    }
    getConstructionGroup() {
        return this._constructionGroup;
    }
    getCeilingGroup() {
        return this._ceilingGroup;
    }
    getFloorGroup() {
        return this._floorGroup;
    }
    getMeasurementLineGroup() {
        return this._measurementLineGroup;
    }
    getBoundingBox() {
        if (this._configuratorContext.baseContext === "configurator" /* BASE_CONTEXT.CONFIGURATOR */) {
            const planObject = this.getPlanObjectForId(this._configuratorContext.planElementId);
            if (planObject) {
                return planObject.getBounds();
            }
        }
        if (this._configuratorContext.baseContext === "glb-viewer" /* BASE_CONTEXT.GLB_VIEWER */) {
            const ids = this._plannerSceneEventHandler.getSelectedIds();
            if (ids && ids.length === 1) {
                const planObject = this.getPlanObjectForId(ids[0]);
                if (planObject) {
                    return planObject.getBounds();
                }
            }
        }
        const plan = this.getCorePlan();
        if (plan) {
            try {
                return kernelBoxToThreeBox(plan.getBounds());
            }
            catch (e) {
                console.error(e);
            }
        }
        const box = new Box3();
        box.expandByObject(this._constructionGroup);
        for (const planObject of this._staticPlanObjectViewModels) {
            box.expandByObject(planObject.getContainer());
        }
        for (const planObject of this._configurablePlanObjectViewModels) {
            box.expandByObject(planObject.getContainer());
        }
        return box;
    }
    /**
     * Merges geometries on the fly when creating them
     *
     * @param runtimeComponentId
     * @param meshId
     * @param materialId
     * @param transform
     * @param vertices
     * @param indices
     * @param uvCoords
     * @param normals
     * @private
     */
    // private _addOrMergeMeshToComponent(runtimeComponentId: number, meshId: string, materialId: string, transform: Float32Array, vertices: Int32Array, indices: Int32Array, uvCoords: Float32Array, normals: Float32Array): void {
    //     let existingMesh: Mesh;
    //     const roomleComponent = this._components.get(runtimeComponentId);
    //     roomleComponent.meshes.forEach((componentMesh) => {
    //         if (componentMesh.userData.material === materialId) {
    //             existingMesh = componentMesh;
    //         }
    //     });
    //     if (existingMesh) {
    //         const existingGeometry = existingMesh.geometry as Geometry;
    //         const geometry = this._plannerMeshGenerator.generateGeometry(meshId, vertices, indices, uvCoords, normals);
    //         existingGeometry.merge(geometry, convertToThreeMatrix(transform));
    //     } else {
    //         let mesh = this._plannerMeshGenerator.generateMesh(meshId, materialId, vertices, indices, uvCoords, normals, null, true);
    //         if (transform) {
    //             mesh.applyMatrix(convertToThreeMatrix(transform));
    //         }
    //         this._addMeshToComponentId(mesh, runtimeComponentId);
    //     }
    // }
    setPlannerSceneEventHandler(plannerSceneEventHandler) {
        this._plannerSceneEventHandler = plannerSceneEventHandler;
    }
    getStaticPlanObjectViewModels() {
        return this._staticPlanObjectViewModels;
    }
    getConfigurablePlanObjectViewModels() {
        return this._configurablePlanObjectViewModels;
    }
    getConstructionPlanObjectViewModels() {
        return this._constructionPlanObjectViewModels;
    }
    getWallPlanObjectViewModels() {
        return this._wallPlanObjectViewModels;
    }
    getNodePlanObjectViewModels() {
        return this._nodePlanObjectViewModels;
    }
    getFloorPlanObjectViewModels() {
        return this._floorPlanObjectViewModels;
    }
    getMeasurementLineObjectViewModels() {
        return this._measurementLinePlanObjectViewModels;
    }
    _generateMesh(runtimeComponentId = 0, geometryId = null, material, vertices, indices, uvCoords, normals, type, newGeometryInstance, materialAttributes) {
        return this._plannerMeshGenerator.generateMesh(runtimeComponentId, geometryId, material, vertices, indices, uvCoords, normals, type, newGeometryInstance, materialAttributes);
    }
    _setMaterial(mesh, material, _type, materialAttributes) {
        this._plannerMeshGenerator.setMaterial(mesh, material, _type, materialAttributes);
    }
    Editor3dComponentCreated(id, position, eulerAngles, parentObjectRuntimeId, isRootComponent) {
        super.Editor3dComponentCreated(id, position, eulerAngles, parentObjectRuntimeId, isRootComponent);
        //FIXME Workaround because Editor3dComponentDocked gets not called in planner kernel access
        if (this._getKernelAccess() instanceof PlannerKernelAccess) {
            this.dockComponent(id, parentObjectRuntimeId, position, eulerAngles);
        }
    }
    addPlanObjectToScene(_planViewModel) {
        // unused
    }
    handlerSwitchedPlans(_fromPlan, _toPlan) {
        this._constructionGroup.clear();
        this._ceilingGroup.clear();
        this._floorGroup.clear();
        this._measurementLineGroup.clear();
    }
    planCompletelyLoaded(_plan) {
        // unused
    }
    beginPlanConstruction(_plan) {
        // unused
    }
    addPlanMesh(_plan, _material, _vertices, _indices, _uvCoords, _normals, _type) {
        // unused
    }
    endPlanConstruction(_plan) {
        // unused
    }
    planElementChanged(_plan, _planObject) {
        // unused
    }
    planObjectConfigurationLoaded(_plan, element, success) {
        const configuration = this.getConfigurablePlanObjectForId(element.getId());
        if (!configuration) {
            console.warn('planObjectConfigurationLoaded but no view model found');
            return;
        }
        if (success) {
            configuration.finishConstruction();
        }
        else {
            configuration.failConstruction();
        }
    }
    addMesh(planElement, material, vertices, indices, uvCoords, normals) {
        const planElementViewModel = planElement.extRef
            .jsObject;
        let mesh = planElementViewModel.getMesh(material);
        if (mesh) {
            mesh.geometry = this._plannerMeshGenerator.generateGeometry(null, vertices, indices, uvCoords, normals);
        }
        else {
            mesh = this._generateMesh(0, null, material, vertices, indices, uvCoords, normals, planElement.getType());
            planElementViewModel.addMesh(mesh);
        }
    }
    removePlanObjectFromScene(planElementViewModel) {
        const type = planElementViewModel.getPlanElement().getType();
        if (this._isConstructionType(type)) {
            this._constructionGroup.remove(planElementViewModel.getContainer());
        }
        else if (type === this._getKernelAccess().kernelContainer.PlanElementType.FLOOR) {
            this._floorGroup.remove(planElementViewModel.getContainer());
        }
        else if (type === this._getKernelAccess().kernelContainer.PlanElementType.CEILING) {
            this._ceilingGroup.remove(planElementViewModel.getContainer());
        }
        else if (type === this._getKernelAccess().kernelContainer.PlanElementType.MEASURE) {
            this._measurementLineGroup.remove(planElementViewModel.getContainer());
        }
        planElementViewModel.clear();
    }
    _isConstructionType(type) {
        return (type === this._getKernelAccess().kernelContainer.PlanElementType.WALL ||
            type === this._getKernelAccess().kernelContainer.PlanElementType.NODE);
    }
    planElementRemoved(element) {
        var _a;
        const planObject = element;
        const planObjectViewModel = (_a = planObject.extRef) === null || _a === void 0 ? void 0 : _a.jsObject;
        if (planObjectViewModel instanceof ConfiguratorPlanObjectViewModel) {
            this._removeObject(this._configurablePlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof ConstructionPlanObjectViewModel) {
            this._removeObject(this._constructionPlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof StaticPlanObjectViewModel) {
            this._removeObject(this._staticPlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof FloorPlanElementViewModel) {
            this._removeObject(this._floorPlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof WallPlanElementViewModel) {
            this._removeObject(this._wallPlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof NodePlanElementViewModel) {
            this._removeObject(this._nodePlanObjectViewModels, planObjectViewModel);
        }
        else if (planObjectViewModel instanceof MeasurementLinePlanElementViewModel) {
            this._removeObject(this._measurementLinePlanObjectViewModels, planObjectViewModel);
        }
    }
    _removeObject(array, planObjectViewModel) {
        const index = array.indexOf(planObjectViewModel);
        if (index > -1) {
            array.splice(index, 1);
        }
    }
    getMeshGenerator() {
        return this._plannerMeshGenerator;
    }
    componentConfigurationUpdated(runtimeComponentId, geometryChanged) {
        super.componentConfigurationUpdated(runtimeComponentId, geometryChanged);
    }
    hideAllExcept(planObjectId) {
        this._ceilingGroup.visible = false;
        this._floorGroup.visible = false;
        this._measurementLineGroup.visible = false;
        this._constructionGroup.visible = false;
        this._staticPlanObjectViewModels.forEach((m) => {
            if (m.getId() === planObjectId) {
                return;
            }
            m.getContainer().visible = false;
        });
        this._configurablePlanObjectViewModels.forEach((m) => {
            if (m.getId() === planObjectId) {
                return;
            }
            m.getContainer().visible = false;
        });
        this._constructionPlanObjectViewModels.forEach((m) => {
            if (m.getId() === planObjectId) {
                return;
            }
            m.getContainer().visible = false;
        });
    }
    showAll() {
        this._ceilingGroup.visible = this._cameraType === CAMERA_TYPE.CAMERA_FP;
        this._floorGroup.visible = true;
        this._measurementLineGroup.visible = true;
        this._constructionGroup.visible = true;
        this._staticPlanObjectViewModels.forEach((m) => (m.getContainer().visible = true));
        this._configurablePlanObjectViewModels.forEach((m) => (m.getContainer().visible = true));
    }
    planHistoryStateChanged() {
        // unused
    }
    setCameraType(cameraType) {
        this._cameraType = cameraType;
        this._wallPlanObjectViewModels.forEach((wallPlanObject) => wallPlanObject.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D));
        this._measurementLinePlanObjectViewModels.forEach((measurementPlanObject) => measurementPlanObject.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D));
        this._nodePlanObjectViewModels.forEach((nodePlanObject) => nodePlanObject.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D));
        this._constructionPlanObjectViewModels.forEach((nodePlanObject) => nodePlanObject.setTopView(this._cameraType === CAMERA_TYPE.CAMERA_2D));
    }
    get cameraType() {
        return this._cameraType;
    }
    setNodeZoom(zoom) {
        zoom = Math.min(4, zoom);
        this._nodeZoom = zoom;
        for (const node of this._nodePlanObjectViewModels) {
            node.getObject().scale.setScalar(zoom);
        }
        for (const node of this._measurementLinePlanObjectViewModels) {
            node.getPoint1Draggable().scale.setScalar(zoom);
            node.getPoint2Draggable().scale.setScalar(zoom);
        }
    }
    planCleared() {
        this._configurablePlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._staticPlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._wallPlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._measurementLinePlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._nodePlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._floorPlanObjectViewModels.forEach((viewModel) => viewModel.remove());
        this._constructionPlanObjectViewModels.forEach((viewModel) => viewModel.remove());
    }
}
__decorate([
    inject
], PlanViewModel.prototype, "_plannerMeshGenerator", void 0);
__decorate([
    inject
], PlanViewModel.prototype, "_roomlePlannerUiCallback", void 0);

const createTransferableObjectPosition = (planViewModel, camera, clientWidth, clientHeight) => {
    const bounds = new Box3().setFromObject(planViewModel.getContainer());
    const center = bounds.getCenter(new Vector3());
    return {
        runtimeId: planViewModel.getId(),
        position2d: threeVectorToTransferableXY(getScreenXY(center, camera, clientWidth, clientHeight)),
    };
};
const getCallbackObjectType = (planElementViewModel) => {
    if (planElementViewModel instanceof StaticPlanObjectViewModel) {
        const objectType = planElementViewModel
            .getPlanObject()
            .getObjectType();
        if (objectType !== 'door' && objectType !== 'window') {
            return 'static';
        }
        else {
            return objectType;
        }
    }
    if (planElementViewModel instanceof ConfiguratorPlanObjectViewModel) {
        return 'configuration';
    }
    if (planElementViewModel instanceof WallPlanElementViewModel) {
        return 'wall';
    }
    if (planElementViewModel instanceof FloorPlanElementViewModel) {
        return 'floor';
    }
    if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
        return 'measure';
    }
    return 'unknown';
};

/**
 * Based on "A Practical Analytic Model for Daylight"
 * aka The Preetham Model, the de facto standard analytic skydome model
 * https://www.researchgate.net/publication/220720443_A_Practical_Analytic_Model_for_Daylight
 *
 * First implemented by Simon Wallner
 * http://simonwallner.at/project/atmospheric-scattering/
 *
 * Improved by Martin Upitis
 * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR
 *
 * Three.js integration by zz85 http://twitter.com/blurspline
*/

class Sky extends Mesh {

	constructor() {

		const shader = Sky.SkyShader;

		const material = new ShaderMaterial( {
			name: shader.name,
			uniforms: UniformsUtils.clone( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			depthWrite: false
		} );

		super( new BoxGeometry( 1, 1, 1 ), material );

		this.isSky = true;

	}

}

Sky.SkyShader = {

	name: 'SkyShader',

	uniforms: {
		'turbidity': { value: 2 },
		'rayleigh': { value: 1 },
		'mieCoefficient': { value: 0.005 },
		'mieDirectionalG': { value: 0.8 },
		'sunPosition': { value: new Vector3() },
		'up': { value: new Vector3( 0, 1, 0 ) }
	},

	vertexShader: /* glsl */`
		uniform vec3 sunPosition;
		uniform float rayleigh;
		uniform float turbidity;
		uniform float mieCoefficient;
		uniform vec3 up;

		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		// constants for atmospheric scattering
		const float e = 2.71828182845904523536028747135266249775724709369995957;
		const float pi = 3.141592653589793238462643383279502884197169;

		// wavelength of used primaries, according to preetham
		const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
		// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
		// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
		const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

		// mie stuff
		// K coefficient for the primaries
		const float v = 4.0;
		const vec3 K = vec3( 0.686, 0.678, 0.666 );
		// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
		const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

		// earth shadow hack
		// cutoffAngle = pi / 1.95;
		const float cutoffAngle = 1.6110731556870734;
		const float steepness = 1.5;
		const float EE = 1000.0;

		float sunIntensity( float zenithAngleCos ) {
			zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
			return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
		}

		vec3 totalMie( float T ) {
			float c = ( 0.2 * T ) * 10E-18;
			return 0.434 * c * MieConst;
		}

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vWorldPosition = worldPosition.xyz;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			gl_Position.z = gl_Position.w; // set z to camera.far

			vSunDirection = normalize( sunPosition );

			vSunE = sunIntensity( dot( vSunDirection, up ) );

			vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

			float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

			// extinction (absorbtion + out scattering)
			// rayleigh coefficients
			vBetaR = totalRayleigh * rayleighCoefficient;

			// mie coefficients
			vBetaM = totalMie( turbidity ) * mieCoefficient;

		}`,

	fragmentShader: /* glsl */`
		varying vec3 vWorldPosition;
		varying vec3 vSunDirection;
		varying float vSunfade;
		varying vec3 vBetaR;
		varying vec3 vBetaM;
		varying float vSunE;

		uniform float mieDirectionalG;
		uniform vec3 up;

		// constants for atmospheric scattering
		const float pi = 3.141592653589793238462643383279502884197169;

		const float n = 1.0003; // refractive index of air
		const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

		// optical length at zenith for molecules
		const float rayleighZenithLength = 8.4E3;
		const float mieZenithLength = 1.25E3;
		// 66 arc seconds -> degrees, and the cosine of that
		const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

		// 3.0 / ( 16.0 * pi )
		const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
		// 1.0 / ( 4.0 * pi )
		const float ONE_OVER_FOURPI = 0.07957747154594767;

		float rayleighPhase( float cosTheta ) {
			return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
		}

		float hgPhase( float cosTheta, float g ) {
			float g2 = pow( g, 2.0 );
			float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
			return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
		}

		void main() {

			vec3 direction = normalize( vWorldPosition - cameraPosition );

			// optical length
			// cutoff angle at 90 to avoid singularity in next formula.
			float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
			float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
			float sR = rayleighZenithLength * inverse;
			float sM = mieZenithLength * inverse;

			// combined extinction factor
			vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

			// in scattering
			float cosTheta = dot( direction, vSunDirection );

			float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
			vec3 betaRTheta = vBetaR * rPhase;

			float mPhase = hgPhase( cosTheta, mieDirectionalG );
			vec3 betaMTheta = vBetaM * mPhase;

			vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
			Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

			// nightsky
			float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
			float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
			vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
			vec3 L0 = vec3( 0.1 ) * Fex;

			// composition + solar disc
			float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
			L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

			vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

			vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

			gl_FragColor = vec4( retColor, 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`

};

const mapToUiPlanObjects = async (planObjects, plannerKernelAccess, rapiAccess) => {
    let objects = [];
    const itemIDs = [];
    const configurationIDs = [];
    await Promise.all(planObjects.map(async (planObject) => {
        const obj = convertCObject(planObject);
        if (obj.catalogItemId) {
            itemIDs.push(obj.catalogItemId);
        }
        else if (obj.configurationHash) {
            configurationIDs.push(obj.configurationHash);
        }
        if (obj.parts) {
            const hash = obj.configurationHash || obj.catalogItemId;
            obj.parts = await plannerKernelAccess.addUiDataAndPriceToPartList(obj.parts, hash);
        }
        if (obj.configuration) {
            const configurationData = await plannerKernelAccess.getConfigurationData(obj.runtimeId);
            obj.configuration = configurationData.configuration;
        }
        obj.data = null;
        objects.push(obj);
    }));
    const [responseItems, responseConfigurations] = await Promise.all([
        rapiAccess.getItems(itemIDs),
        rapiAccess.getConfigurations(configurationIDs),
    ]);
    const rootComponentIds = [];
    const data = new Map();
    for (const item of responseItems) {
        data.set(item.id, item);
    }
    for (const configuration of responseConfigurations) {
        data.set(configuration.id, configuration);
        rootComponentIds.push(configuration.rootComponentId);
    }
    const rootComponents = await rapiAccess.getComponents(rootComponentIds);
    const rootComponentsMap = new Map();
    for (const rootComponent of rootComponents) {
        rootComponentsMap.set(rootComponent.id, rootComponent);
    }
    for (const obj of objects) {
        const id = obj.catalogItemId || obj.configurationHash;
        const entryData = data.get(id) || null;
        if (entryData &&
            !entryData.label &&
            rootComponentsMap.has(entryData.rootComponentId)) {
            const component = rootComponentsMap.get(entryData.rootComponentId);
            entryData.label = component.label;
        }
        if (entryData && !entryData.label) {
            entryData.label = id;
        }
        obj.data = entryData;
    }
    return objects;
};

class PaperBackground extends Mesh {
    constructor() {
        const geo = new PlaneGeometry(1000, 1000, 8, 8);
        geo.rotateX(-Math.PI / 2);
        const material = new MeshBasicMaterial();
        const textureLoader = new TextureLoader();
        textureLoader.load(img, (texture) => {
            texture.wrapS = RepeatWrapping;
            texture.wrapT = RepeatWrapping;
            const repeatEveryM = 5;
            texture.repeat.set(1000 / repeatEveryM, 1000 / repeatEveryM);
            material.map = texture;
            material.alphaTest = 0.3;
            material.transparent = true;
        });
        super(geo, material);
        this.name = '2d paper background';
        this.position.set(0, -0.1, 0);
        this.layers.set(2 /* LAYER.BACKGROUND */);
        this.userData.ignoreElementHit = true;
    }
}

const PLAN_STORE = 'rml_plans';
const SET_WALL_MATERIAL_TYPE = {
    INTERIOR: 'interior',
    EXTERIOR: 'exterior',
};
const isCtrlOrCmd = (event) => event.key === 'Meta' || event.key === 'Control';
const ctrlOrCmd = (event, checkIfItIsTheOnlyKey = false) => {
    const isMultiSelectKey = checkIfItIsTheOnlyKey === false
        ? checkIfItIsTheOnlyKey
        : isCtrlOrCmd(event);
    return event.key && (event.metaKey || event.ctrlKey || isMultiSelectKey);
};
const getPressedKeysCount = (event) => ['altKey', 'ctrlKey', 'shiftKey', 'metaKey'].reduce((acc, key) => {
    if (event[key]) {
        acc++;
    }
    return acc;
}, 0);
class PlannerSceneManager extends ConfiguratorSceneManager {
    constructor(creator, offset, plannerCallback, mode) {
        super(creator, offset, mode);
        this._staticItemGuard = new AsyncGuard();
        this._configurableItemGuard = new AsyncGuard();
        this._planCompletelyLoadedGuard = new AsyncGuard();
        this.currentSelection = null;
        this._paperBackground = null;
        // debug variables
        this._debugSpheres = {
            wallPoints: [],
            constructionElementsPoints: [],
        };
        this._stopRendering = true;
        this._configuratorContext.baseContext = "planner" /* BASE_CONTEXT.PLANNER */;
        this._roomlePlannerCallback = plannerCallback;
        this._plannerMeshGenerator.maxAnisotropy =
            this._renderer.capabilities.getMaxAnisotropy();
        this._plannerMeshGenerator.maxTextures =
            this._renderer.capabilities.maxTextures;
        this._plannerSceneEventHandler = new PlannerSceneEventHandler(creator, this._scene, this._cameraControl.getCamera(), this._getInputManager());
        this._roomleRenderer.switchToPlanner(RenderMode.Mode3D);
        this._imageRenderer.switchToPlannerSettings();
        this._plannerSceneEventHandler.addEventListener(2 /* PLANNER_SCENE_EVENT.STATE_CHANGED */, ({ state, oldState }) => {
            if (oldState === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */ &&
                state !== oldState) {
                this._roomlePlannerUiCallback.onRotationCancel();
            }
            if (state === 2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */ ||
                state === 1 /* PLANNER_SCENE_EVENT_STATE.DRAG */ ||
                state === 4 /* PLANNER_SCENE_EVENT_STATE.MEASURE */ ||
                state === 3 /* PLANNER_SCENE_EVENT_STATE.DRAW */) {
                this._cameraControl.lock();
                this._onCameraMove();
            }
            else {
                this._cameraControl.unlock();
                this._onCameraIdle();
            }
        }, this);
        this._plannerSceneEventHandler.addEventListener(13 /* PLANNER_SCENE_EVENT.INTERACTION */, () => this._renderWithoutShadowsAndAO(), this);
        this._plannerSceneEventHandler.addEventListener(0 /* PLANNER_SCENE_EVENT.SELECT_PLAN_ELEMENT */, ({ planElementViewModel }) => {
            this._sendElementMeasurements();
            if (planElementViewModel instanceof StaticPlanObjectViewModel &&
                this._initData.debug) {
                console.log(planElementViewModel.getGLBUrl());
            }
            this._highlightPlanElement(planElementViewModel);
            this._onSelectionChange(planElementViewModel);
            this._renderWithoutShadowsAndAO();
        }, this);
        this._plannerSceneEventHandler.addEventListener(1 /* PLANNER_SCENE_EVENT.DESELECT_PLAN_ELEMENT */, ({ planElementViewModel, reason }) => {
            this._highlightPlanElement(null);
            this._onSelectionCancel(planElementViewModel);
            this._roomlePlannerUiCallback.onSelectionCancel(reason);
            this._renderWithoutShadowsAndAO();
        }, this);
        this._plannerSceneEventHandler.addEventListener(8 /* PLANNER_SCENE_EVENT.BEFORE_DRAG_START */, () => {
            this._cameraControl.lock();
        }, this);
        this._plannerSceneEventHandler.addEventListener(9 /* PLANNER_SCENE_EVENT.DRAG_START */, ({ planElementViewModel }) => {
            const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
            planInteractionHandler.startInteraction();
            this._sendElementMeasurements();
            if (planElementViewModel instanceof WallPlanElementViewModel) {
                this._sendWallDimensions();
            }
            this._requestRender();
            this._dragStartBounds = this.getBounds();
        }, this);
        this._plannerSceneEventHandler.addEventListener(10 /* PLANNER_SCENE_EVENT.DRAG_MOVE */, ({ planElementViewModel }) => {
            this._cameraControl.checkNearFarDistance(planElementViewModel.getPosition());
            this._requestRender();
        }, this);
        this._plannerSceneEventHandler.addEventListener(11 /* PLANNER_SCENE_EVENT.DRAG_END */, async ({ planElementViewModel }) => {
            const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
            planInteractionHandler.endInteraction();
            this._cameraControl.unlock();
            const position = this._getDragPosition(planElementViewModel.getPosition());
            if (position) {
                planInteractionHandler.moveElementTo(planElementViewModel.getPlanElement(), convertToKernel(position));
            }
            this.updateEnvironment(this.getBounds(), true);
            this._zoomToBounds(false);
            this._renderEverything();
            const planObject = this.getPlanObject(planElementViewModel.getId());
            let planObjects;
            if (planObject) {
                planObjects = await mapToUiPlanObjects([planObject], this._plannerKernelAccess, this._rapiAccess);
            }
            this._roomlePlannerUiCallback.onPlanElementChanged(PLAN_ELEMENT_CHANGE_TYPES.CHANGED, planObjects ? planObjects[0] : null);
        }, this);
        this._plannerSceneEventHandler.addEventListener(12 /* PLANNER_SCENE_EVENT.DRAG_CANCEL */, () => {
            this._cameraControl.unlock();
        }, this);
        this._plannerSceneEventHandler.addEventListener(16 /* PLANNER_SCENE_EVENT.ADD_MEASUREMENT_LINE_START */, () => {
            this._cameraControl.lock();
        }, this);
        this._plannerSceneEventHandler.addEventListener(17 /* PLANNER_SCENE_EVENT.ADD_MEASUREMENT_LINE_END */, () => {
            this._cameraControl.unlock();
            this._roomlePlannerUiCallback.onMeasurementLineStateChange(false);
        }, this);
        this._plannerSceneEventHandler.addEventListener(6 /* PLANNER_SCENE_EVENT.DRAWING_START */, () => {
            this._setKernelZoomFactor();
            this._renderWithoutShadowsAndAO();
        }, this);
        this._plannerSceneEventHandler.addEventListener(5 /* PLANNER_SCENE_EVENT.DRAW */, () => this._renderWithoutShadowsAndAO(), this);
        this._plannerSceneEventHandler.addEventListener(7 /* PLANNER_SCENE_EVENT.DRAWING_END */, () => this._renderWithoutShadowsAndAO(), this);
        this._getKernelAccess().addPlannerListener(this);
        this._plannerMeshGenerator.setMaterialLoadedListener(() => {
            // disabled because it has not been implemented for BufferGeometry yet
            // this._getViewModel().tryToMergeComponents();
            this._configurableItemGuard.resolve();
            this._requestRender();
        });
        window.onbeforeunload = this.clearScene.bind(this);
        this._renderListener = () => {
            this._requestRender();
        };
        this._getInputManager().addEventListener(7 /* INPUT_EVENT.ZOOM_IN */, this._renderListener, this);
        this._getInputManager().addEventListener(8 /* INPUT_EVENT.ZOOM_OUT */, this._renderListener, this);
        this.disableConfiguratorEvents();
        if (mode !== CAMERA_TYPE.CAMERA_FP) {
            this.enablePlannerEvents();
        }
        // relevant for mode=2d
        // move to next frame otherwise we stop rendering before setting the color and thus have a black background
        setTimeout(() => this._updatePaperBackground(), 0);
    }
    planCleared() {
        // unused
    }
    planHistoryStateChanged() {
        var _a, _b;
        this._sendWallDimensions();
        // Save plan to IDB
        const planInteractionHandler = (_a = this._plannerKernelAccess) === null || _a === void 0 ? void 0 : _a.planInteractionHandler;
        const planXml = (_b = planInteractionHandler.getPlan()) === null || _b === void 0 ? void 0 : _b.getPlanXML(true, 2);
        const key = this._idbManager.getKey(getHostname(), this._initData.id);
        this._idbManager.setValue(key, planXml, this._idbManager.configStore);
    }
    _getViewModel() {
        if (!this._viewModel) {
            this._viewModel = new PlanViewModel(this._creator_);
        }
        return this._viewModel;
    }
    _getDragPosition(elementPosition) {
        // only check position if an element gets dragged in
        if (!this._plannerSceneEventHandler.isDragIn()) {
            return null;
        }
        const bounds = this._dragStartBounds
            ? this._dragStartBounds
            : this.getBounds();
        const center = bounds.getCenter(new Vector3());
        const distance = elementPosition.distanceTo(center);
        const size = bounds.getSize(new Vector3());
        const boundsSize = Math.max(size.x, size.z);
        // add distance of 3 meters to max bounds distance
        const maxAllowedDistance = boundsSize + 3;
        if (distance > maxAllowedDistance) {
            const direction = new Vector3()
                .subVectors(elementPosition, center)
                .normalize();
            // set new element position to max allowed distance from center and original position
            return center.clone().add(direction.multiplyScalar(maxAllowedDistance));
        }
        return null;
    }
    _hideAllMeasurementsNodeOnElementChange(planElementViewModel) {
        const measurementLineViewModels = this._getViewModel().getMeasurementLineObjectViewModels();
        measurementLineViewModels.forEach((measurementModel) => measurementModel.hideDraggableNodes());
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            planElementViewModel.showDraggableNodes();
        }
    }
    _onSelectionChange(planElementViewModel) {
        this._hideAllMeasurementsNodeOnElementChange(planElementViewModel);
        const payload = {};
        if (planElementViewModel instanceof StaticPlanObjectViewModel) {
            payload.item = planElementViewModel.getRapiItem();
            payload.staticItemRuntimeId = planElementViewModel
                .getPlanElement()
                .getId();
        }
        if (planElementViewModel instanceof ConfiguratorPlanObjectViewModel) {
            payload.configurationRuntimeId =
                planElementViewModel.getConfigurationRuntimeId();
        }
        if (planElementViewModel instanceof WallPlanElementViewModel) {
            const zoomFactor = this._cameraControl.getKernelZoomFactor();
            payload.wall = planElementViewModel.getWallDimension(zoomFactor);
        }
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            payload.measurementLine =
                planElementViewModel.getMeasurementLineDimension();
        }
        if (planElementViewModel instanceof FloorPlanElementViewModel) {
            payload.staticItemRuntimeId = planElementViewModel
                .getPlanElement()
                .getId();
        }
        let objectType = getCallbackObjectType(planElementViewModel);
        const fetchPayloadData = async () => {
            const promisePayload = {};
            if (planElementViewModel instanceof StaticPlanObjectViewModel) {
                promisePayload.item = planElementViewModel.getRapiItem();
                promisePayload.staticItemRuntimeId = planElementViewModel
                    .getPlanElement()
                    .getId();
            }
            if (planElementViewModel instanceof ConfiguratorPlanObjectViewModel) {
                await planElementViewModel.isInitDone();
                const configurationRuntimeId = planElementViewModel.getConfigurationRuntimeId();
                const catalogItemId = planElementViewModel
                    .getPlanObject()
                    .getCatalogItemId();
                let idToUse = catalogItemId;
                if (!idToUse) {
                    const configurationHash = this._getKernelAccess().kernelInstance.getHashOfConfiguration(configurationRuntimeId);
                    idToUse = configurationHash;
                }
                this._configuratorContext.planObjectId = configurationRuntimeId;
                this._configuratorContext.planElementId = planElementViewModel.getId();
                this._configuratorContext.rootComponentId =
                    planElementViewModel.getRootComponentRuntimeId();
                let rootComponentId;
                if (catalogItemId && isIdItemId(catalogItemId)) {
                    const item = await this._rapiAccess.getItem(catalogItemId);
                    promisePayload.item = item;
                    rootComponentId = item.rootComponentId ? item.rootComponentId : null;
                }
                else {
                    try {
                        const configuration = await this._rapiAccess.getConfiguration(idToUse);
                        promisePayload.configuration = configuration;
                        rootComponentId = configuration.rootComponentId
                            ? configuration.rootComponentId
                            : null;
                    }
                    catch (e) {
                        console.warn('Could not get RAPI configuration for kernel hash ' +
                            idToUse +
                            ', saving configuration...');
                        const configurationData = (await this._getKernelAccess().getConfigurationData(configurationRuntimeId));
                        const rapiConfiguration = await this._rapiAccess.saveConfiguration(configurationData);
                        promisePayload.configuration = rapiConfiguration;
                        rootComponentId = rapiConfiguration.rootComponentId
                            ? rapiConfiguration.rootComponentId
                            : null;
                    }
                }
                if (rootComponentId) {
                    const component = await this._rapiAccess.getComponent(rootComponentId);
                    promisePayload.component = component;
                }
                promisePayload.configurationRuntimeId = configurationRuntimeId;
                objectType = 'configuration';
            }
            promisePayload.planElementId = planElementViewModel.getId();
            return copy(promisePayload);
        };
        // no await on purpose because we want to return
        // the promise and not the actual value
        const payloadPromise = fetchPayloadData();
        this.currentSelection = copy(payload);
        this._sendElementMeasurements();
        this._roomlePlannerUiCallback.onSelectionChange(copy(this._plannerSceneEventHandler.getSelectionMode()), copy(objectType), copy(payload), payloadPromise, planElementViewModel);
        if (planElementViewModel instanceof WallPlanElementViewModel ||
            planElementViewModel instanceof NodePlanElementViewModel) {
            this._getViewModel()
                .getNodePlanObjectViewModels()
                .forEach((node) => node.show());
            this._updateNodeSize();
        }
        this._renderWithoutShadowsAndAO();
    }
    _onSelectionCancel(_planElementViewModel) {
        this._getViewModel()
            .getNodePlanObjectViewModels()
            .forEach((node) => node.hide());
        this._renderWithoutShadowsAndAO();
        this.resetConfiguratorContext();
        this._handleMeasurementLineDraggablePoints(_planElementViewModel);
        this.currentSelection = null;
    }
    _handleMeasurementLineDraggablePoints(planElementViewModel) {
        this._getViewModel()
            .getMeasurementLineObjectViewModels()
            .forEach((measurementLineViewModel) => {
            measurementLineViewModel.hideDraggableNodes();
            measurementLineViewModel.deselectAllDraggablePoints();
        });
        if (planElementViewModel instanceof MeasurementLinePlanElementViewModel) {
            planElementViewModel.deselectAllDraggablePoints();
            planElementViewModel.currentPoint = null;
        }
    }
    resetConfiguratorContext() {
        this._configuratorContext.planObjectId = 0;
        this._configuratorContext.planElementId = 0;
        this._configuratorContext.rootComponentId = 0;
        this._configuratorContext.dockingRootComponentId = 0;
    }
    _setupScene(offset, transparent) {
        super._setupScene(offset, transparent, true);
        if (this._initData.legacyLight) {
            this._lightSetting = new PlannerLightSetting(this._scene, this._lightSetting);
        }
        if (!this._initData.moc) {
            this._addSky();
        }
        this._setEnvironment(new BackgroundEnvironment(this._scene, this._environment, getColor(this._initData.colors.DEFAULT_BACKGROUND)));
    }
    onBeforeRender() {
        if (this._cameraControl instanceof CameraControl3D) {
            const anyVisibilityChanged = hideWallsBasedOnCamera(this._cameraControl.getCamera(), this._getViewModel().getWallPlanObjectViewModels());
            if (anyVisibilityChanged) {
                this._roomleRenderer.forceShadowUpdates(true);
            }
        }
    }
    _getInputManager() {
        return this._plannerInputManager;
    }
    createCameraControl(mode, _offset) {
        this.setMode(mode);
    }
    startViewing() {
        this._configuratorContext.baseContext = "glb-viewer" /* BASE_CONTEXT.GLB_VIEWER */;
        const ids = this._plannerSceneEventHandler.getSelectedIds();
        if (ids.length === 1) {
            const planObjectViewModel = this._getViewModel().getPlanObjectForId(ids[0]);
            if (this._cameraControl instanceof CameraControl3D) {
                this._cameraControl.setObjectRotation(planObjectViewModel.getPlanElement().rotation);
            }
            this._getViewModel().hideAllExcept(planObjectViewModel.getId());
        }
        this.resetCamera();
        this.disablePlannerEvents();
        // update environment because we did hide other objects
        this.updateEnvironment(this.getBounds(), true);
    }
    startConfiguring() {
        var _a;
        this._configuratorContext.baseContext = "configurator" /* BASE_CONTEXT.CONFIGURATOR */;
        const { planElementId } = this._configuratorContext;
        const planObjectViewModel = this._getViewModel().getPlanObjectForId(planElementId);
        if (planObjectViewModel) {
            this.setRootComponentId(planObjectViewModel.getRootComponentRuntimeId());
            if (this._cameraControl instanceof CameraControl3D) {
                this._cameraControl.setObjectRotation(planObjectViewModel.getPlanElement().rotation);
            }
        }
        const planObjectId = planObjectViewModel === null || planObjectViewModel === void 0 ? void 0 : planObjectViewModel.getConfigurationRuntimeId();
        if (this._configuratorContext.planObjectId !== planObjectId) {
            this._configuratorContext.planObjectId = planObjectId;
        }
        this._getViewModel().hideAllExcept(planElementId);
        // unselect all plan elements, otherwise meshes are still highlighted in configurator
        this._plannerSceneEventHandler.removeSelection();
        this._highlightPlanElement(null);
        this.resetCamera();
        this.disablePlannerEvents();
        this.enableConfiguratorEvents();
        this._roomleRenderer.switchToConfigurator();
        this._imageRenderer.switchToConfiguratorSettings();
        this.updateScene();
        this._getKernelAccess().updatePlanObjectDependencies(planObjectId);
        this._getKernelAccess().requestPartListAndUpdatePricesOfParts();
        this._getKernelAccess().planObjectUpdated(planObjectId, false);
        // update environment because we did hide other objects
        this.updateEnvironment(this.getBounds(), true);
        const planInteractionHandler = (_a = this._plannerKernelAccess) === null || _a === void 0 ? void 0 : _a.planInteractionHandler;
        planInteractionHandler === null || planInteractionHandler === void 0 ? void 0 : planInteractionHandler.startInteraction();
    }
    async selectPlanObject(runtimeId) {
        if (this._plannerSceneEventHandler.getSelectedIds().includes(runtimeId)) {
            return;
        }
        const planObjectViewModel = this._getViewModel().getPlanObjectForId(runtimeId);
        await this._plannerSceneEventHandler.selectPlanElement(planObjectViewModel);
        this._onSelectionChange(planObjectViewModel);
    }
    backToPlanner() {
        var _a;
        this._getViewModel().showAll();
        if (this._configuratorContext.baseContext === "configurator" /* BASE_CONTEXT.CONFIGURATOR */) {
            const planInteractionHandler = (_a = this._plannerKernelAccess) === null || _a === void 0 ? void 0 : _a.planInteractionHandler;
            planInteractionHandler === null || planInteractionHandler === void 0 ? void 0 : planInteractionHandler.endInteraction();
        }
        this._configuratorContext.baseContext = "planner" /* BASE_CONTEXT.PLANNER */;
        if (this._cameraControl instanceof CameraControl3D) {
            this._cameraControl.setObjectRotation(0);
        }
        this.resetCamera();
        this.enablePlannerEvents();
        this.disableConfiguratorEvents();
        this._roomleRenderer.switchToPlanner(this._cameraControl instanceof CameraControl3D
            ? RenderMode.Mode3D
            : RenderMode.Mode2D);
        this._imageRenderer.switchToPlannerSettings();
        this.updateScene();
    }
    resetCamera() {
        if (this._cameraControl.hasSavedState()) {
            this.resetCameraToState();
        }
        else {
            this.resetCameraPositionToStart();
        }
    }
    resetCameraToState() {
        this._cameraControl.resetToState();
    }
    _getYRotationOfObject(object) {
        let objectDirection = object.getWorldDirection(new Vector3()).clone();
        objectDirection.y = 0;
        if (objectDirection.lengthSq() < 0.01) {
            objectDirection = new Vector3(0, 1, 0);
            objectDirection.applyQuaternion(object.quaternion);
            objectDirection.y = 0;
        }
        objectDirection.normalize();
        let angle = Math.asin(objectDirection.x);
        if (objectDirection.z < 0) {
            angle = Math.PI - angle;
        }
        // clamp to a value between 0 and 2 PI
        if (angle < 0) {
            angle += Math.PI * 2;
        }
        return angle;
    }
    loadStaticPlanObjects() {
        let kernelPlanObjects = new Map();
        this._getViewModel()
            .getStaticPlanObjectViewModels()
            .forEach((planObjectViewModel) => {
            let planObject = planObjectViewModel.getPlanObject();
            if (kernelPlanObjects.has(planObject.getCatalogItemId())) {
                let objects = kernelPlanObjects.get(planObject.getCatalogItemId());
                objects.push(planObjectViewModel);
            }
            else {
                kernelPlanObjects.set(planObject.getCatalogItemId(), [
                    planObjectViewModel,
                ]);
            }
        });
        this._rapiAccess
            .getItems(Array.from(kernelPlanObjects.keys()))
            .then((rapiItems) => {
            let promises = [];
            rapiItems.forEach((rapiItem) => {
                this._getKernelAccess().catalogItemLoaded(rapiItem);
                kernelPlanObjects.get(rapiItem.id).forEach((planObjectViewModel) => {
                    promises.push(new Promise((resolve, reject) => {
                        planObjectViewModel.setRapiItem(rapiItem).then(() => {
                            this._requestRender();
                            resolve();
                        }, reject);
                    }));
                });
            });
            Promise.all(promises).then(() => this._staticItemsLoaded());
        });
    }
    _staticItemsLoaded() {
        this._requestRender();
        this._staticItemGuard.resolve();
        this._roomlePlannerUiCallback.onItemsLoaded();
    }
    preload(id) {
        this._planId = id;
        let planGLTF = this._localStorageHelper.getItem(this._planId, PLAN_STORE);
        if (planGLTF) {
            this._loadGLTF(planGLTF).then((glb) => {
                this._preloadScene = glb;
                if (this._preloadScene) {
                    this._scene.add(this._preloadScene);
                }
                this._requestRender();
            });
        }
    }
    planXMLLoaded(plan) {
        this.endPlanConstruction(plan);
        const kernelBounds = plan.getBounds();
        const bounds = kernelBoxToThreeBox(kernelBounds);
        this._updateBounds(bounds);
        this.loadStaticPlanObjects();
    }
    planCompletelyLoaded(_plan) {
        this._stopRendering = false;
        this._renderEverything();
        this.resetCamera();
        // move call to the next run loop otherwise elements will still be added to the scene
        setTimeout(() => this._planCompletelyLoadedGuard.resolve(), 0);
        this._getViewModel()
            .getNodePlanObjectViewModels()
            .forEach((node) => node.hide());
        this._getViewModel()
            .getMeasurementLineObjectViewModels()
            .forEach((measurementLineViewModel) => measurementLineViewModel.hideDraggableNodes());
    }
    handlerSwitchedPlans(fromPlan, toPlan) {
        this._roomlePlannerUiCallback.onHandlerSwitchedPlans();
        this._getViewModel().setReference(toPlan);
        this._getKernelAccess().coupleReferences(this._getViewModel(), toPlan);
        this._getViewModel().setPlannerSceneEventHandler(this._plannerSceneEventHandler);
        this._getViewModel().setGeometriesMergedListener(() => {
            this._renderEverything();
        });
        this._plannerSceneEventHandler.setPlanViewModel(this._getViewModel());
        if (fromPlan) {
            this.clearScene();
        }
        if (!this._initData.moc) {
            this._addSky();
            let planeGeometry = new PlaneGeometry(1000, 1000);
            planeGeometry.rotateX(-Math.PI / 2);
            let planeMaterial = MaterialCreator.createMeshStandardMaterial({
                color: '#f0f0f0',
                roughness: 1,
                metalness: 0,
                depthWrite: false,
            });
            // planeMaterial.opacity = 0.2;
            let plane = new Mesh(planeGeometry, planeMaterial);
            plane.name = 'Ground';
            plane.position.y = -0.01;
            plane.userData.isFloor = true;
            this._scene.add(plane);
        }
        this.resetCamera();
        this._setCeiling();
        this._staticItemGuard.reset();
        this._configurableItemGuard.reset();
        this._planCompletelyLoadedGuard.reset();
        Promise.all([
            this._staticItemGuard.wait(),
            this._configurableItemGuard.wait(),
            this._planCompletelyLoadedGuard.wait(),
        ]).then(this._itemsLoaded.bind(this));
    }
    _itemsLoaded() {
        var _a;
        const plan = this._getViewModel().getCorePlan();
        if (this._roomleRenderer) {
            const box = kernelBoxToThreeBox(plan.getBounds());
            (_a = this._roomleRenderer) === null || _a === void 0 ? void 0 : _a.updateBounds(box);
        }
        // store plan again when we use BufferGeometry instead of Geometry
        // construction group should not always be stored to localstorage, only when version changes
        // if (this._planId) {
        //     this.exportGLB([...this._getViewModel().getConstructionGroup().children, ...this._getViewModel().getCeilingGroup().children], this._planId);
        // }
        this._roomlePlannerUiCallback.onCompletelyLoaded();
        this.updateEnvironment(this.getBounds(), true);
        this._renderEverything();
    }
    beginPlanConstruction(_plan) {
        // Keep tslint quite
    }
    addPlanMesh(_plan, _material, _vertices, _indices, _uvCoords, _normals, _type) {
        // Keep tslint quite
    }
    endPlanConstruction(_plan) {
        this._renderLoopFunction = () => {
            var _a;
            this._scene.add(this._getViewModel().getConstructionGroup());
            this._scene.add(this._getViewModel().getCeilingGroup());
            this._scene.add(this._getViewModel().getFloorGroup());
            this._scene.add(this._getViewModel().getMeasurementLineGroup());
            if ((_a = this._lightSetting) === null || _a === void 0 ? void 0 : _a.needsBounds()) {
                this._lightSetting.updateBounds(this._getViewModel().getBoundingBox());
            }
            this._scene.remove(this._preloadScene);
        };
    }
    async addPlanObjectToScene(planViewModel) {
        if (planViewModel) {
            const object3D = planViewModel.getContainer();
            fadeIn(object3D);
            this._scene.add(object3D);
            if (this._plannerSceneEventHandler.isDragIn()) {
                this._plannerSceneEventHandler.addComponentDragInHandler(planViewModel);
                this._requestRender();
            }
            this._roomlePlannerUiCallback.onPlanChanged();
            await planViewModel.isInitDone();
            this._zoomToBounds(false, false);
            this.updateEnvironment(this.getBounds());
            this._renderEverything();
            const planObject = this.getPlanObject(planViewModel.getId());
            let planObjects;
            if (planObject) {
                planObjects = await mapToUiPlanObjects([planObject], this._plannerKernelAccess, this._rapiAccess);
            }
            this._roomlePlannerUiCallback.onPlanElementChanged(PLAN_ELEMENT_CHANGE_TYPES.ADDED, planObjects ? planObjects[0] : null);
        }
    }
    removePlanObjectFromScene(planViewModel) {
        if (planViewModel instanceof WallPlanElementViewModel ||
            planViewModel instanceof NodePlanElementViewModel) {
            this._sendWallDimensions();
        }
        if (planViewModel instanceof MeasurementLinePlanElementViewModel) {
            this._sendMeasurementLineDimension();
        }
        this._scene.remove(planViewModel.getContainer());
        planViewModel.clear();
        this.updateEnvironment(this.getBounds(), true);
        this._zoomToBounds(true);
        this._renderEverything();
    }
    async planElementChanged(_plan, _planViewModel) {
        if (this._drawingEnabled) {
            this._sendWallDimensions(false); // show the measurements while wall drawing
        }
        this._sendElementMeasurements();
        this.updateEnvironment(this.getBounds(), true);
        this._renderEverything();
        this._onPlanChanged();
        if (!this._plannerSceneEventHandler.isDragIn()) {
            const planObject = this.getPlanObject(_planViewModel.getId());
            let planObjects;
            if (planObject) {
                planObjects = await mapToUiPlanObjects([planObject], this._plannerKernelAccess, this._rapiAccess);
            }
            this._roomlePlannerUiCallback.onPlanElementChanged(PLAN_ELEMENT_CHANGE_TYPES.CHANGED, planObjects ? planObjects[0] : null);
        }
    }
    exportGLB(_exportObjects, _id) {
        // three-refactor - GLTFExporter
        //this._scriptLoader
        //  .fetch(GLTF_EXPORTER_FILE_NAME, { id: 'gltf-exporter' })
        //  .then(() => {
        //    let exporter = new (THREE as any).GLTFExporter();
        //
        //    if (!exportObjects) {
        //      exportObjects = [];
        //      this._scene.children.forEach((child: any) => {
        //        if (this._isPartOfScene(child)) {
        //          exportObjects.push(child);
        //        }
        //      });
        //    }
        //
        //    // Parse the input and generate the glTF output
        //    exporter.parse(
        //      exportObjects,
        //      (gltf: any) => {
        //        let key = id ? id : 'test';
        //        this._localStorageHelper.addItem(
        //          key,
        //          JSON.stringify(gltf),
        //          PLAN_STORE
        //        );
        //        // download(gltf);
        //
        //        // const blob = new Blob([gltf], {type: 'model/gltf-binary'});
        //        // a.href = URL.createObjectURL(blob);
        //        // a.download = 'scene.glb';
        //      },
        //      { binary: false, embedImages: true, forceIndices: true }
        //    );
        //  });
    }
    importGLB(url) {
        this._loadGLB(url).then((object) => this._scene.add(object));
    }
    clearScene() {
        this._plannerMeshGenerator.clear();
        this._getViewModel().sceneCleared();
        super.clearScene();
    }
    //https://threejs.org/examples/webgl_shaders_sky.html
    _addSky() {
        let skyParams = {
            distance: 400000,
            turbidity: 10,
            rayleigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            inclination: 0.6,
            azimuth: 0, // Facing front
        };
        if (!this._sky) {
            //SKY
            this._sky = new Sky();
            this._sky.name = 'Sky';
            this._sky.scale.setScalar(450000);
            this._sky.frustumCulled = false;
            this._scene.add(this._sky);
            this._sky.material.uniforms.turbidity.value = skyParams.turbidity;
            this._sky.material.uniforms.rayleigh.value = skyParams.rayleigh;
            this._sky.material.uniforms.mieCoefficient.value =
                skyParams.mieCoefficient;
            this._sky.material.uniforms.mieDirectionalG.value =
                skyParams.mieDirectionalG;
            let sunPosition = viewSpacePositionFromUV(skyParams.distance, skyParams.azimuth, skyParams.inclination);
            this._sky.material.uniforms.sunPosition.value.copy(sunPosition);
            // Add Sun Helper
            // three-refactor
            let sunSphere = new Mesh(new SphereGeometry(20000, 16, 8), new MeshBasicMaterial({ color: 0xffffff }));
            sunSphere.name = 'Sunsphere';
            sunSphere.position.y = -700000;
            sunSphere.visible = false;
            //this._scene.add(sunSphere);
            sunSphere.position.set(sunPosition.x, -sunPosition.z, sunPosition.y);
            //sunSphere.visible = true;
        }
        if (this._lightSetting instanceof PlannerLightSetting) {
            this._lightSetting.updateSunPosition(skyParams.inclination, skyParams.azimuth);
        }
    }
    switchTo2D() {
        var _a, _b, _c;
        this._onCameraMove();
        if (this._cameraControl instanceof CameraControl2D) {
            return;
        }
        (_a = this._roomleRenderer) === null || _a === void 0 ? void 0 : _a.sceneRenderer.setCameraType(CAMERA_TYPE.CAMERA_2D);
        (_b = this._plannerSceneEventHandler) === null || _b === void 0 ? void 0 : _b.enable();
        for (const wallPlanObject of this._getViewModel().getWallPlanObjectViewModels()) {
            wallPlanObject.show();
        }
        this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_2D);
        (_c = this._roomleRenderer) === null || _c === void 0 ? void 0 : _c.switchToPlanner(RenderMode.Mode2D);
        this._renderEverything();
        this._changeCameraControl(new CameraControl2D(this._creator_, this._getInputManager(), null, this.getOrthographicOffsetCamera()));
        this._updateCamera();
        this._addCameraControlListener();
        this._setCeiling();
        this._roomlePlannerUiCallback.onCameraChanged(CAMERA_TYPE.CAMERA_2D);
        this._setCameraControlListeners();
        // set initial zoom factor, otherwise kernel won't send callbacks
        this._setKernelZoomFactor();
        this._onCameraMove();
    }
    switchTo3D() {
        var _a, _b, _c;
        this._onCameraMove();
        if (this._cameraControl instanceof CameraControl3D) {
            return;
        }
        (_a = this._roomleRenderer) === null || _a === void 0 ? void 0 : _a.sceneRenderer.setCameraType(CAMERA_TYPE.CAMERA_3D);
        (_b = this._plannerSceneEventHandler) === null || _b === void 0 ? void 0 : _b.enable();
        this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_3D);
        (_c = this._roomleRenderer) === null || _c === void 0 ? void 0 : _c.switchToPlanner(RenderMode.Mode3D);
        this._renderEverything();
        this._changeCameraControl(new CameraControl3D(this._creator_, this._getInputManager(), new Vector3(0, 10, 0), this.getPerspectiveOffsetCamera()));
        this._updateCamera();
        this._addCameraControlListener();
        this._setCeiling();
        this._roomlePlannerUiCallback.onCameraChanged(CAMERA_TYPE.CAMERA_3D);
        this._setCameraControlListeners();
    }
    switchToFirstPerson() {
        var _a, _b;
        if (this._cameraControl instanceof CameraControlFirstPerson) {
            return;
        }
        (_a = this._roomleRenderer) === null || _a === void 0 ? void 0 : _a.sceneRenderer.setCameraType(CAMERA_TYPE.CAMERA_FP);
        (_b = this._plannerSceneEventHandler) === null || _b === void 0 ? void 0 : _b.disable();
        this._plannerMeshGenerator.wallMeshes.forEach((mesh) => setWallTransparency(mesh.material, false, false));
        this._getViewModel()
            .getWallPlanObjectViewModels()
            .forEach((wall) => {
            wall.show();
        });
        this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_FP);
        this._renderEverything();
        let firstPersonPosition = new Vector3(0, 0, 0);
        if (this._getViewModel()) {
            firstPersonPosition = this._getViewModel()
                .getBoundingBox()
                .getCenter(new Vector3());
        }
        if (this._cameraControl) {
            this._cameraControl.cleanUp();
        }
        this._changeCameraControl(new CameraControlFirstPerson(this._creator_, this._getInputManager(), firstPersonPosition, this.getPerspectiveOffsetCamera()));
        this._addCameraControlListener();
        this._setCeiling();
        this._roomlePlannerUiCallback.onCameraChanged(CAMERA_TYPE.CAMERA_FP);
        this._setCameraControlListeners();
    }
    _setCameraControlListeners() {
        this._cameraControl.addEventListener(8 /* CAMERA_EVENT.IDLE */, () => {
            this._onCameraIdle();
        }, this);
        this._cameraControl.addEventListener(1 /* CAMERA_EVENT.ORBIT_MOVE */, () => {
            this._onCameraMove();
        }, this);
        this._cameraControl.addEventListener(7 /* CAMERA_EVENT.MOVING */, () => {
            this._onCameraMove();
        }, this);
        this._cameraControl.addEventListener(3 /* CAMERA_EVENT.ZOOM_IN */, () => {
            this._onCameraMove();
        }, this);
        this._cameraControl.addEventListener(4 /* CAMERA_EVENT.ZOOM_OUT */, () => {
            this._onCameraMove();
        }, this);
        this._cameraControl.addEventListener(5 /* CAMERA_EVENT.ZOOM_CHANGE */, () => {
            this._onCameraZoomChange();
        }, this);
    }
    _onCameraZoomChange() {
        this._setKernelZoomFactor();
    }
    _setKernelZoomFactor() {
        var _a, _b;
        const zoomFactor = this._cameraControl.getKernelZoomFactor();
        (_a = this._getKernelAccess().planInteractionHandler) === null || _a === void 0 ? void 0 : _a.setZoomFactor(zoomFactor);
        (_b = this._plannerSceneEventHandler) === null || _b === void 0 ? void 0 : _b.setKernelZoomFactor(zoomFactor);
    }
    _setCeiling() {
        if (!this._getViewModel()) {
            return;
        }
        if (this._cameraControl instanceof CameraControlFirstPerson) {
            this._getViewModel().getCeilingGroup().visible = true;
        }
        else {
            this._getViewModel().getCeilingGroup().visible = false;
        }
    }
    cameraControlChanged() {
        var _a;
        super.cameraControlChanged();
        (_a = this._plannerSceneEventHandler) === null || _a === void 0 ? void 0 : _a.setCamera(this._cameraControl.getCamera());
        this._updatePaperBackground();
    }
    _updatePaperBackground() {
        var _a, _b;
        if (this._cameraControl instanceof CameraControl2D) {
            if (!this._paperBackground) {
                this._paperBackground = new PaperBackground();
            }
            (_a = this._scene) === null || _a === void 0 ? void 0 : _a.add(this._paperBackground);
            this._requestRender();
        }
        else {
            if (this._paperBackground) {
                (_b = this._scene) === null || _b === void 0 ? void 0 : _b.remove(this._paperBackground);
            }
        }
    }
    sceneChanged() {
        // if this is called from constructor we do not need to setScene because this happens on instantiation
        // therefore _plannerSceneEventHandler is still undefined
        if (this._plannerSceneEventHandler) {
            // sceneChanges after everything is setup, tell all the others
            this._plannerSceneEventHandler.setScene(this._scene);
        }
    }
    closeHSC() {
        this._requestRender();
        if (this._cameraControl instanceof CameraControl3D) {
            this._cameraControl.resetToState();
        }
    }
    _onKeyDown(event) {
        super._onKeyDown(event);
        if (this._initData.debug) {
            this._checkNumKey(event);
        }
        //CMD or CTRL
        if (ctrlOrCmd(event)) {
            const numPressedKeys = getPressedKeysCount(event);
            const correctKeyPressed = (event.metaKey && event.key === 'Meta') ||
                (event.ctrlKey && event.key === 'Control');
            const selectionMode = numPressedKeys > 1
                ? "standard" /* SELECTION_MODE.STANDARD */
                : correctKeyPressed
                    ? "multiselect" /* SELECTION_MODE.MULTISELECT */
                    : "standard" /* SELECTION_MODE.STANDARD */;
            this._plannerSceneEventHandler.setSelectionMode(selectionMode);
            event.preventDefault();
        }
        // Shift
        if (event.key && event.key.includes('Shift')) {
            if (this._cameraControl instanceof CameraControl3D) {
                this._cameraControl.enablePanning();
                event.preventDefault();
            }
        }
    }
    _checkNumKey(event) {
        //1
        if (event.key && event.key === '1') {
            this.switchTo2D();
            event.preventDefault();
        }
        //2
        if (event.key && event.key === '2') {
            this.switchTo3D();
            event.preventDefault();
        }
        //3
        if (event.key && event.key === '3') {
            this.switchToFirstPerson();
            event.preventDefault();
        }
    }
    _onKeyUp(event) {
        super._onKeyDown(event);
        //CMD or CTRL
        if (ctrlOrCmd(event, true)) {
            const numPressedKeys = getPressedKeysCount(event);
            let selectionMode = "standard" /* SELECTION_MODE.STANDARD */;
            const isMultiSelectKey = isCtrlOrCmd(event);
            if (!isMultiSelectKey && numPressedKeys === 1) {
                selectionMode = "multiselect" /* SELECTION_MODE.MULTISELECT */;
            }
            this._plannerSceneEventHandler.setSelectionMode(selectionMode);
            event.preventDefault();
        }
        // Shift
        if (event.key && event.key.includes('Shift')) {
            if (this._cameraControl instanceof CameraControl3D) {
                this._cameraControl.disablePanning();
                event.preventDefault();
            }
        }
        // Escape
        if (event.key && (event.key === 'Escape' || event.key === 'Esc')) {
            if (this._drawingEnabled) {
                this.escapeDrawing();
                this._roomlePlannerUiCallback.onDrawCancel();
            }
        }
    }
    setMode(mode) {
        switch (mode) {
            case CAMERA_TYPE.CAMERA_2D:
                this.switchTo2D();
                break;
            case CAMERA_TYPE.CAMERA_3D:
                this.switchTo3D();
                break;
            case CAMERA_TYPE.CAMERA_FP:
                this.switchToFirstPerson();
                break;
        }
    }
    _highlightPlanElement(planElementViewModel) {
        var _a;
        let selectedMeshes = new Set();
        if (planElementViewModel instanceof ConstructionPlanObjectViewModel &&
            this._cameraControl instanceof CameraControl2D &&
            planElementViewModel &&
            planElementViewModel.getTopViewContainer()) {
            selectedMeshes.add(planElementViewModel.getTopViewContainer());
        }
        else if (planElementViewModel &&
            planElementViewModel.getObject() &&
            planElementViewModel.getObject().children) {
            planElementViewModel
                .getObject()
                .children.forEach((child) => selectedMeshes.add(child));
        }
        this._plannerSceneEventHandler.getSelectedIds().forEach((id) => {
            const planObjectViewModel = this._getViewModel().getPlanObjectForId(id);
            if (planObjectViewModel instanceof ConstructionPlanObjectViewModel &&
                this._cameraControl instanceof CameraControl2D &&
                planObjectViewModel &&
                planObjectViewModel.getTopViewContainer()) {
                selectedMeshes.add(planObjectViewModel.getTopViewContainer());
            }
            else if (planObjectViewModel &&
                planObjectViewModel.getObject() &&
                planObjectViewModel.getObject().children) {
                planObjectViewModel
                    .getObject()
                    .children.forEach((child) => selectedMeshes.add(child));
            }
        });
        (_a = this._roomleRenderer) === null || _a === void 0 ? void 0 : _a.highlightObjects(Array.from(selectedMeshes));
    }
    destroy() {
        super.destroy();
        this._plannerMeshGenerator.removeMaterialLoadedListener();
        this._getViewModel().removeGeometriesMergedListener();
    }
    planObjectConfigurationLoaded(plan, element, _success) {
        if (plan && plan.extRef && element && element.extRef) {
            let planObjectViewModel = element.extRef.jsObject;
            let runtimeId = planObjectViewModel
                .getPlanObject()
                .getConfigurationRuntimeId();
            if (runtimeId > 0) {
                this._getViewModel().constructComponents(runtimeId);
            }
        }
    }
    addMesh(_planElement, _material, _vertices, _indices, _uvCoords, _normals) {
        // unused
    }
    _updateBounds(bounds) {
        if (!bounds) {
            return;
        }
        if (this._configuratorContext.baseContext === "planner" /* BASE_CONTEXT.PLANNER */) {
            this._updateCamera(bounds);
        }
        super._updateBounds(bounds);
    }
    _updateCamera(bounds) {
        if (!bounds) {
            bounds = this.getBounds();
        }
        if (!bounds) {
            return;
        }
        if (this._cameraControl instanceof CameraControl3D) {
            this._cameraControl.updateToBounds(bounds, false);
        }
        if (this._cameraControl instanceof CameraControl2D) {
            this._cameraControl.zoomToFitBounds(getDrawingMinBounds(bounds, this._domHelper.element.clientWidth, this._domHelper.element.clientHeight, 1.1), true);
        }
        this._renderEverything();
    }
    _zoomToBounds(zoomInAllowed, reset = true) {
        const bounds = this.getBounds();
        if (this._cameraControl instanceof CameraControl3D) {
            if (this._getViewModel().getPlanObjectCount() <= 1) {
                this._cameraControl.zoomToFitBounds(bounds, reset);
            }
            else {
                this._cameraControl.checkBoundsAndPlaceCamera(bounds, reset);
            }
        }
        if (this._cameraControl instanceof CameraControl2D &&
            !this._drawingEnabled) {
            this._cameraControl.zoomToFitBounds(bounds, zoomInAllowed, reset);
        }
    }
    updateCameraOnDrawWalls() {
        const bounds = this.getBounds();
        if (this._cameraControl instanceof CameraControl2D) {
            this._cameraControl.zoomToFitBounds(bounds, false, true);
        }
        if (this._cameraControl instanceof CameraControl3D) {
            this._cameraControl.zoomToFitBounds(bounds, true);
        }
    }
    getBounds() {
        if (!this._getViewModel()) {
            return null;
        }
        return this._getViewModel().getBoundingBox();
    }
    getPlanObject(id) {
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        const planModelViewHelper = this._plannerKernelAccess.planModelViewHelper;
        const plan = planInteractionHandler.getPlan();
        return planModelViewHelper.getPlanObject(plan, id);
    }
    cancelPlanElementSelection(reason) {
        this._plannerSceneEventHandler.cancelSelection(reason);
        this._highlightPlanElement(null);
        this._requestRender();
    }
    async deletePlanElementSelection() {
        const selectedIds = this._plannerSceneEventHandler.getSelectedIds();
        this.cancelPlanElementSelection('delete_object');
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        planInteractionHandler.startInteraction();
        await this.deletePlanElementByIds(selectedIds);
        planInteractionHandler.endInteraction();
    }
    async deletePlanElementByIds(runtimeIds) {
        for (const id of runtimeIds) {
            const planObjectViewModel = this._getViewModel().getPlanObjectForId(id);
            if (planObjectViewModel && planObjectViewModel.getObject()) {
                const planObject = this.getPlanObject(planObjectViewModel.getId());
                let planObjects;
                if (planObject) {
                    planObjects = await mapToUiPlanObjects([planObject], this._plannerKernelAccess, this._rapiAccess);
                }
                this._roomlePlannerUiCallback.onPlanElementChanged(PLAN_ELEMENT_CHANGE_TYPES.REMOVED, planObjects ? planObjects[0] : null);
                this._getKernelAccess().planInteractionHandler.removeElement(planObjectViewModel.getKernelObject());
            }
        }
    }
    rotatePlanElementSelection(rotateBy) {
        const list = new (this._getKernelAccess().kernelContainer.PlanObjectPtrList)();
        const bounds = new Box3();
        let kernelCenter = { x: 0, y: 0, z: 0 };
        this._plannerSceneEventHandler.getSelectedIds().forEach((id) => {
            const planObjectViewModel = this._getViewModel().getPlanObjectForId(id);
            if (planObjectViewModel && planObjectViewModel.getObject()) {
                kernelCenter = planObjectViewModel.getPlanElement().getCenter();
                list.push_back(planObjectViewModel.getPlanElement());
                bounds.expandByObject(planObjectViewModel.getContainer());
            }
        });
        if (list.size() > 1) {
            const center = bounds.getCenter(new Vector3());
            kernelCenter = convertToKernel(center);
        }
        this._getKernelAccess().planInteractionHandler.rotateObjectsBy(list, rotateBy, kernelCenter);
    }
    planBoundsChanged() {
        this.updateEnvironment(this.getBounds());
        this._requestRender();
    }
    planElementRemoved(_element) {
        this._onPlanChanged();
        this._renderEverything();
    }
    _onPlanChanged() {
        this._roomlePlannerUiCallback.onPlanChanged();
    }
    prepareTopImage(options = {}) {
        return new Promise((resolve) => {
            this._getViewModel()
                .materialQueue.finished(true)
                .then(async () => {
                var _a, _b;
                let cameraTarget = this._calculateBoundingBoxOfAllMeshes(0.1);
                (_a = this._lightSetting) === null || _a === void 0 ? void 0 : _a.removeFromScene();
                if (this._cameraControl instanceof CameraControl3D) {
                    this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_2D);
                }
                let image = await this._imageRenderer.prepareTopImage(this._scene, null, cameraTarget, options);
                if (this._cameraControl instanceof CameraControl3D) {
                    this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_3D);
                }
                (_b = this._lightSetting) === null || _b === void 0 ? void 0 : _b.addToScene();
                this._requestRender();
                resolve(image);
            });
        });
    }
    preparePerspectiveImageOf(runtimeId, options = {}) {
        const object = this._getViewModel().getPlanObjectForId(runtimeId);
        if (!object) {
            const error = 'Object with runtimeId ' + runtimeId + ' not found';
            console.warn(error);
            throw new Error(error);
        }
        return this._preparePerspectiveImage({
            ...options,
            object: object.getObject().clone(),
        });
    }
    _preparePerspectiveImage(options = {}) {
        if (this._configuratorContext.baseContext === "configurator" /* BASE_CONTEXT.CONFIGURATOR */) {
            return super.preparePerspectiveImage(options);
        }
        return new Promise((resolve, reject) => {
            this._getViewModel()
                .materialQueue.finished(true)
                .then(async () => {
                var _a, _b;
                let camera;
                if (this._cameraControl instanceof CameraControl3D) {
                    camera = this._cameraControl.getCamera().clone();
                }
                else {
                    camera = this.getPerspectiveOffsetCamera().clone();
                    camera.layers.enableAll();
                    this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_3D);
                }
                camera.resetOffset();
                let cameraTarget = !options.object
                    ? this._calculateBoundingBoxOfAllMeshes()
                    : ImageRenderer.getCameraTargetForBBox(new Box3().setFromObject(options.object));
                (_a = this._lightSetting) === null || _a === void 0 ? void 0 : _a.removeFromScene();
                let scene = !options.object
                    ? this._scene
                    : createEmptySceneFromCurrent(this._scene);
                if (options.object) {
                    scene.add(options.object);
                }
                const image = await this._imageRenderer.preparePerspectiveImage(scene, null, camera, cameraTarget, options, undefined, undefined, (placedCamera) => {
                    hideWallsBasedOnCamera(placedCamera, this._getViewModel().getWallPlanObjectViewModels());
                });
                dispose(camera);
                if (options.object) {
                    dispose(scene);
                }
                if (this._cameraControl instanceof CameraControl2D) {
                    this._getViewModel().setCameraType(CAMERA_TYPE.CAMERA_2D);
                    this._getViewModel()
                        .getWallPlanObjectViewModels()
                        .forEach((node) => node.show());
                }
                else {
                    hideWallsBasedOnCamera(this._cameraControl.getCamera(), this._getViewModel().getWallPlanObjectViewModels());
                }
                (_b = this._lightSetting) === null || _b === void 0 ? void 0 : _b.addToScene();
                this._requestRender();
                resolve(image);
            }, reject);
        });
    }
    preparePerspectiveImage(options = {}) {
        return this._preparePerspectiveImage(options);
    }
    _calculateBoundingBoxOfAllMeshes(spacing = 0) {
        const bounds = this.getBounds();
        return ImageRenderer.getCameraTargetForBBox(bounds, spacing);
    }
    enableRotation() {
        this._plannerSceneEventHandler.setState(2 /* PLANNER_SCENE_EVENT_STATE.ROTATE */);
    }
    disableRotation() {
        this._plannerSceneEventHandler.resetState();
    }
    enableSnapping() {
        this._plannerSceneEventHandler.enableSnapping();
    }
    disableSnapping() {
        this._plannerSceneEventHandler.disableSnapping();
    }
    dragIn(dragEvent) {
        this._plannerSceneEventHandler.setDragIn(true, dragEvent);
    }
    getPlannerSceneEventHandler() {
        return this._plannerSceneEventHandler;
    }
    disablePlannerEvents() {
        this._plannerSceneEventHandler.disable();
    }
    enablePlannerEvents() {
        this._plannerSceneEventHandler.enable();
    }
    _onCameraIdle() {
        if (super._onCameraIdle()) {
            this._sendWallDimensions();
            this._sendPlanObjectPositions();
            this._roomlePlannerUiCallback.onCameraIdle();
            this._sendElementMeasurements();
            this._hideAllNodeIfThereAreNoSelections();
        }
        return true;
    }
    _hideAllNodeIfThereAreNoSelections() {
        if (!this.currentSelection) {
            this._getViewModel()
                .getMeasurementLineObjectViewModels()
                .forEach((measurementLineViewModel) => measurementLineViewModel.hideDraggableNodes());
            this._getViewModel()
                .getNodePlanObjectViewModels()
                .forEach((node) => node.hide());
        }
    }
    _onCameraMove() {
        if (super._onCameraMove()) {
            this._roomlePlannerUiCallback.disableWallDimensions();
            this._roomlePlannerUiCallback.cameraStartsMoving();
        }
        this._updateNodeSize();
        return true;
    }
    _updateNodeSize() {
        if (this._cameraControl instanceof CameraControl2D) {
            const zoom = 1 / this._cameraControl.getCamera().zoom;
            this._getViewModel().setNodeZoom(zoom);
        }
    }
    _sendPlanObjectPositions() {
        if (this._cameraControl.isLocked()) {
            return;
        }
        const { clientWidth, clientHeight } = this._domHelper.element;
        const camera = this._cameraControl.getCamera();
        const planObjectPositions = [];
        const planViewModels = {
            staticPlanObjectViewModels: this._getViewModel().getStaticPlanObjectViewModels(),
            configurablePlanObjectViewModels: this._getViewModel().getConfigurablePlanObjectViewModels(),
            constructionPlanObjectViewModels: this._getViewModel().getConstructionPlanObjectViewModels(),
            wallPlanObjectViewModels: this._getViewModel().getWallPlanObjectViewModels(),
            floorPlanObjectViewModels: this._getViewModel().getFloorPlanObjectViewModels(),
            nodePlanObjectViewModels: this._getViewModel().getNodePlanObjectViewModels(),
        };
        for (const planViewModelsType of Object.values(planViewModels)) {
            for (const planViewModel of planViewModelsType) {
                planObjectPositions.push(createTransferableObjectPosition(planViewModel, camera, clientWidth, clientHeight));
            }
        }
        this._roomlePlannerUiCallback.onUpdatePlanObjectPositions(planObjectPositions);
    }
    _updateMeasurementPositions(measurements, camera, clientWidth, clientHeight) {
        if (measurements.fromPosition3d) {
            measurements.fromPosition2d = getScreenXY(measurements.fromPosition3d, camera, clientWidth, clientHeight);
        }
        if (measurements.toPosition3d) {
            measurements.toPosition2d = getScreenXY(measurements.toPosition3d, camera, clientWidth, clientHeight);
        }
        if (measurements.textPosition3d) {
            measurements.textPosition2d = getScreenXY(measurements.textPosition3d, camera, clientWidth, clientHeight);
        }
        return measurements;
    }
    _sendElementMeasurements() {
        this._sendConstructionElementDimensions();
        this._sendObjectMeasurements();
        this._sendMeasurementLineDimension();
    }
    _sendMeasurementLineDimension() {
        const camera = this._cameraControl.getCamera();
        const { clientWidth, clientHeight } = this._domHelper.element;
        const measurementLineDimensions = [];
        const measurementLineViewModels = this._getViewModel().getMeasurementLineObjectViewModels();
        for (const measurementLineViewModel of measurementLineViewModels) {
            const measurementLineDimension = measurementLineViewModel.getMeasurementLineDimension();
            measurementLineDimension.fromPosition2d = getScreenXY(measurementLineDimension.fromPosition3d, camera, clientWidth, clientHeight);
            measurementLineDimension.toPosition2d = getScreenXY(measurementLineDimension.toPosition3d, camera, clientWidth, clientHeight);
            measurementLineDimension.textPosition2d = getScreenXY(measurementLineDimension.textPosition3d, camera, clientWidth, clientHeight);
            measurementLineDimension.lengthFormatted =
                this._unitFormatter.formatMMValueToUnitString(measurementLineDimension.length);
            measurementLineDimensions.push(toMeasurementLineDimensionToTransferable(measurementLineDimension));
        }
        this._roomlePlannerUiCallback.onUpdateMeasurementLineDimensions(measurementLineDimensions);
    }
    _sendObjectMeasurements() {
        if (!this.currentSelection) {
            return;
        }
        const ids = this._plannerSceneEventHandler.getSelectedIds();
        if (ids.length === 0) {
            // We did not show object to wall Measurements for multi-select case
            return;
        }
        const planObjectViewModel = this._getViewModel().getPlanObjectForId(ids[0]);
        if (!planObjectViewModel ||
            planObjectViewModel instanceof ConstructionPlanObjectViewModel ||
            (!(planObjectViewModel instanceof StaticPlanObjectViewModel) &&
                !(planObjectViewModel instanceof ConfiguratorPlanObjectViewModel))) {
            return;
        }
        const camera = this._cameraControl.getCamera();
        const { clientWidth, clientHeight } = this._domHelper.element;
        const zoomFactor = this._cameraControl.getKernelZoomFactor();
        const objectDimensions = planObjectViewModel.getObjectMeasurements(zoomFactor);
        const transferableRectMeasurements = this.transformMeasurements(objectDimensions.rectMeasurements, camera, clientWidth, clientHeight);
        const transferableObjectMeasurements = this.transformMeasurements(objectDimensions.objectMeasurements, camera, clientWidth, clientHeight);
        const transferableObjectToWallsMeasurements = this.transformMeasurements(objectDimensions.objectToWallsMeasurements, camera, clientWidth, clientHeight);
        this._roomlePlannerUiCallback.onUpdateObjectMeasurements({
            rectMeasurements: transferableRectMeasurements,
            objectMeasurements: transferableObjectMeasurements,
            objectToWallsMeasurements: transferableObjectToWallsMeasurements,
        });
    }
    transformMeasurements(dimensions, camera, clientWidth, clientHeight) {
        return dimensions.map((dimension) => {
            const fromPosition2d = getScreenXY(dimension.fromPosition3d, camera, clientWidth, clientHeight);
            const toPosition2d = getScreenXY(dimension.toPosition3d, camera, clientWidth, clientHeight);
            const textPosition2d = getScreenXY(dimension.textPosition3d, camera, clientWidth, clientHeight);
            return objectToWallDimensionToTransferable({
                ...dimension,
                fromPosition2d,
                toPosition2d,
                textPosition2d,
            });
        });
    }
    _sendConstructionElementDimensions() {
        if (!this.currentSelection) {
            return;
        }
        const currentRuntimeID = this.currentSelection.staticItemRuntimeId ||
            this.currentSelection.configurationRuntimeId;
        const planObjectViewModel = this._getViewModel().getPlanObjectForId(currentRuntimeID);
        if (!planObjectViewModel ||
            !(planObjectViewModel instanceof ConstructionPlanObjectViewModel)) {
            return;
        }
        const camera = this._cameraControl.getCamera();
        const { clientWidth, clientHeight } = this._domHelper.element;
        const zoomFactor = this._cameraControl.getKernelZoomFactor();
        const constructionMeasurements = planObjectViewModel.getConstructionElementMeasurements(zoomFactor);
        if (!constructionMeasurements) {
            return;
        }
        if (this._initData.debug) {
            if (this._debugSpheres.constructionElementsPoints.length) {
                this._debugSpheres.constructionElementsPoints.forEach((sphere) => this._scene.remove(sphere));
                this._debugSpheres.constructionElementsPoints = [];
            }
            const redMaterial = new MeshBasicMaterial({ color: 0xff0000 });
            const greenMaterial = new MeshBasicMaterial({ color: 0x00ff00 });
            const blueMaterial = new MeshBasicMaterial({ color: 0x0000ff });
            const sphereGeometry = new SphereGeometry(0.1, 32, 16);
            const leftFromSphere = new Mesh(sphereGeometry, redMaterial);
            leftFromSphere.position.copy(constructionMeasurements.leftMeasurement.fromPosition3d);
            leftFromSphere.position.y = 5;
            const leftToSphere = new Mesh(sphereGeometry, redMaterial);
            leftToSphere.position.copy(constructionMeasurements.leftMeasurement.toPosition3d);
            leftToSphere.position.y = 5;
            const rightFromSphere = new Mesh(sphereGeometry, greenMaterial);
            rightFromSphere.position.copy(constructionMeasurements.rightMeasurement.fromPosition3d);
            rightFromSphere.position.y = 5;
            const rightToSphere = new Mesh(sphereGeometry, greenMaterial);
            rightToSphere.position.copy(constructionMeasurements.rightMeasurement.toPosition3d);
            rightToSphere.position.y = 5;
            const rangeFromSphere = new Mesh(sphereGeometry, blueMaterial);
            rangeFromSphere.position.copy(constructionMeasurements.elementRange.fromPosition3d);
            rangeFromSphere.position.y = 5;
            const rangeToSphere = new Mesh(sphereGeometry, blueMaterial);
            rangeToSphere.position.copy(constructionMeasurements.elementRange.toPosition3d);
            rangeToSphere.position.y = 5;
            this._scene.add(leftFromSphere);
            this._scene.add(leftToSphere);
            this._scene.add(rightFromSphere);
            this._scene.add(rightToSphere);
            this._scene.add(rangeFromSphere);
            this._scene.add(rangeToSphere);
            this._debugSpheres.constructionElementsPoints.push(leftFromSphere, leftToSphere, rightFromSphere, rightToSphere, rangeFromSphere, rangeToSphere);
        }
        constructionMeasurements.leftMeasurement = this._updateMeasurementPositions(constructionMeasurements.leftMeasurement, camera, clientWidth, clientHeight);
        constructionMeasurements.rightMeasurement =
            this._updateMeasurementPositions(constructionMeasurements.rightMeasurement, camera, clientWidth, clientHeight);
        constructionMeasurements.elementRange = this._updateMeasurementPositions(constructionMeasurements.elementRange, camera, clientWidth, clientHeight);
        const transferableMeasurements = {
            leftMeasurement: {
                ...toConstructionMeasurementTransferable(constructionMeasurements.leftMeasurement),
            },
            rightMeasurement: {
                ...toConstructionMeasurementTransferable(constructionMeasurements.rightMeasurement),
            },
            elementRange: {
                ...toConstructionMeasurementTransferable(constructionMeasurements.elementRange),
            },
        };
        this._roomlePlannerUiCallback.onUpdateConstructionElementsMeasurements(transferableMeasurements);
    }
    _sendWallDimensions(isFixedWalls = true) {
        if (this._cameraControl.isLocked() && isFixedWalls) {
            return;
        }
        const wallDimensions = [];
        const { clientWidth, clientHeight } = this._domHelper.element;
        const wallViewModels = this._getViewModel().getWallPlanObjectViewModels();
        const zoomFactor = this._cameraControl.getKernelZoomFactor();
        for (const planViewModel of wallViewModels) {
            const wallDimension = planViewModel.getWallDimension(zoomFactor);
            const { thickness, height } = planViewModel.getKernelObject();
            if (wallDimension.length > 0 && thickness > 0 && height > 0) {
                const camera = this._cameraControl.getCamera();
                wallDimension.fromPosition2d = getScreenXY(wallDimension.fromPosition3d, camera, clientWidth, clientHeight);
                wallDimension.toPosition2d = getScreenXY(wallDimension.toPosition3d, camera, clientWidth, clientHeight);
                wallDimension.fromWithoutPadding = getScreenXY(wallDimension.fromWithoutPadding, camera, clientWidth, clientHeight);
                wallDimension.toWithoutPadding = getScreenXY(wallDimension.toWithoutPadding, camera, clientWidth, clientHeight);
                wallDimension.textPosition2d = getScreenXY(wallDimension.textPosition3d, camera, clientWidth, clientHeight);
                wallDimension.lengthFormatted =
                    this._unitFormatter.formatMMValueToUnitString(wallDimension.length);
                wallDimensions.push(wallDimensionToTransferable(wallDimension));
            }
            if (this._initData.debug) {
                if (this._debugSpheres.wallPoints.length) {
                    this._debugSpheres.wallPoints.forEach((sphere) => this._scene.remove(sphere));
                    this._debugSpheres.wallPoints = [];
                }
                console.log('wall dimension', wallDimension);
                const geometry = new SphereGeometry(0.1, 32, 16);
                const material = new MeshBasicMaterial({ color: 0xff0000 });
                const fromSphere = new Mesh(geometry, material);
                fromSphere.position.copy(wallDimension.fromPosition3d);
                const toSphere = new Mesh(geometry, material);
                toSphere.position.copy(wallDimension.toPosition3d);
                const centerSphere = new Mesh(geometry, new MeshBasicMaterial({ color: 0x00ff00 }));
                centerSphere.position.copy(wallDimension.textPosition3d);
                this._scene.add(fromSphere);
                this._scene.add(toSphere);
                this._scene.add(centerSphere);
                this._debugSpheres.wallPoints.push(fromSphere, toSphere, centerSphere);
            }
        }
        this._roomlePlannerUiCallback.onUpdateWallDimensions(wallDimensions);
    }
    enableWallDrawing() {
        if (this._cameraControl instanceof CameraControl2D) {
            const bounds = getDrawingMinBounds(this.getBounds(), this._domHelper.element.clientWidth, this._domHelper.element.clientHeight);
            this._cameraControl.zoomToFitBounds(bounds, true);
        }
        if (this._drawingEnabled) {
            // return if drawing is enabled so that eventListeners are not added multiple times
            return;
        }
        this._drawingEnabled = true;
        this._scene.add(this._plannerSceneEventHandler.enableWallDrawing());
    }
    disableWallDrawing() {
        this._drawingEnabled = false;
        this._cameraControl.unlock();
        this._scene.remove(this._plannerSceneEventHandler.cancelWallDrawing());
    }
    escapeDrawing() {
        this._plannerSceneEventHandler.stopDrawing();
    }
    _changeCameraControl(cameraControl) {
        super._changeCameraControl(cameraControl);
    }
    setSceneEvents(sceneEvents) {
        var _a, _b;
        if (this._cameraControl instanceof CameraControlFirstPerson) {
            return;
        }
        if (sceneEvents.construction !== undefined) {
            (_a = this._plannerSceneEventHandler) === null || _a === void 0 ? void 0 : _a.enableConstructionEvents(sceneEvents.construction);
        }
        if (sceneEvents.objects !== undefined) {
            (_b = this._plannerSceneEventHandler) === null || _b === void 0 ? void 0 : _b.enableObjectEvents(sceneEvents.objects);
        }
    }
    /**
     * called by kernel
     */
    startedDrawing() {
        this._plannerSceneEventHandler.startDrawing();
    }
    /**
     * called by kernel
     */
    stoppedDrawing() {
        this._plannerSceneEventHandler.stopDrawing();
    }
    disableEvents() {
        super.disableEvents();
        this.disablePlannerEvents();
    }
    enableEvents() {
        super.enableEvents();
        if (this._configuratorContext.baseContext === "planner" /* BASE_CONTEXT.PLANNER */ &&
            !(this._cameraControl instanceof CameraControlFirstPerson)) {
            this.enablePlannerEvents();
        }
    }
    resetCameraPositionToStart(animate = true) {
        if (this._cameraControl instanceof CameraControl3D) {
            super.resetCameraPositionToStart(animate);
        }
        if (this._cameraControl instanceof CameraControl2D) {
            this._updateCamera();
        }
    }
    async moveCamera(cameraParameter) {
        if (this._cameraControl instanceof CameraControl3D) {
            return super.moveCamera(cameraParameter);
        }
        return Promise.reject('Camera can only be moved in 3D');
    }
    _setInteriorOrExteriorWallMaterial(type, material) {
        const viewModel = this._getViewModel();
        const wallPlanObjectViewModels = viewModel.getWallPlanObjectViewModels();
        if (!wallPlanObjectViewModels.length) {
            return;
        }
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        const setLeftMaterial = (wall) => {
            planInteractionHandler.setWallLeftMaterial(wall, applyMaterialToKernelMaterial(wall.leftMaterial, material));
        };
        const setRightMaterial = (wall) => {
            planInteractionHandler.setWallRightMaterial(wall, applyMaterialToKernelMaterial(wall.rightMaterial, material));
        };
        const kernelWalls = wallPlanObjectViewModels.map((wall) => wall.getKernelObject());
        // TODO: Find a way to deal with standalone walls
        // const kernelStandAloneWallEnum =
        //   this._plannerKernelAccess.kernelContainer.WallType.StandAloneWall;
        const kernelInnerWallEnum = this._plannerKernelAccess.kernelContainer.WallType.InnerWall;
        const kernelOuterWallLeftEnum = this._plannerKernelAccess.kernelContainer.WallType.OuterWallLeft;
        const kernelOuterWallRightEnum = this._plannerKernelAccess.kernelContainer.WallType.OuterWallRight;
        for (const wall of kernelWalls) {
            if (wall.wallType === kernelInnerWallEnum &&
                type === SET_WALL_MATERIAL_TYPE.INTERIOR) {
                setLeftMaterial(wall);
                setRightMaterial(wall);
            }
            if (wall.wallType === kernelOuterWallLeftEnum) {
                if (type === SET_WALL_MATERIAL_TYPE.INTERIOR) {
                    setRightMaterial(wall);
                }
                else {
                    setLeftMaterial(wall);
                }
            }
            if (wall.wallType === kernelOuterWallRightEnum) {
                if (type === SET_WALL_MATERIAL_TYPE.EXTERIOR) {
                    setRightMaterial(wall);
                }
                else {
                    setLeftMaterial(wall);
                }
            }
            // TODO: Find a way to deal with standalone walls
            // if (wall.wallType === kernelStandAloneWallEnum) {
            //   setLeftMaterial(wall);
            //   setRightMaterial(wall);
            // }
        }
    }
    changeInteriorWallsMaterial(material) {
        this._setInteriorOrExteriorWallMaterial(SET_WALL_MATERIAL_TYPE.INTERIOR, material);
    }
    changeExteriorWallsMaterial(material) {
        this._setInteriorOrExteriorWallMaterial(SET_WALL_MATERIAL_TYPE.EXTERIOR, material);
    }
    changeFloorsMaterial(material) {
        const viewModel = this._getViewModel();
        const floorPlanObjectViewModels = viewModel.getFloorPlanObjectViewModels();
        if (!floorPlanObjectViewModels.length) {
            return;
        }
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        const kernelFloors = floorPlanObjectViewModels.map((floor) => floor.getKernelObject());
        for (const floor of kernelFloors) {
            planInteractionHandler.setFloorMaterial(floor, applyMaterialToKernelMaterial(floor.material, material));
        }
    }
    getWallAngleDegrees(wall) {
        if (!(wall instanceof WallPlanElementViewModel)) {
            return 0;
        }
        const camera = this._cameraControl.getCamera();
        const cameraPosition = new Vector2(camera.position.x, camera.position.z);
        const wallPosition = new Vector2(wall.getPosition().x, wall.getPosition().z);
        const cameraToWall = wallPosition.clone().sub(cameraPosition).normalize();
        const wallKernelObject = wall.getKernelObject();
        const wallForward = new Vector2(Math.sin(wallKernelObject.getAngle()), Math.cos(wallKernelObject.getAngle()));
        const angleRadians = cameraToWall.angle() - wallForward.angle();
        return MathUtils.radToDeg(angleRadians);
    }
    moveElementPosition(selectedElement, position) {
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        planInteractionHandler.setObjectFixedZ(selectedElement.getPlanElement(), true);
        planInteractionHandler.moveElementTo(selectedElement.getPlanElement(), position);
        this._sendPlanObjectPositions();
    }
    moveElementsPosition(selectedElements, position) {
        const planObjectPtrList = new this._plannerKernelAccess.kernelContainer.PlanObjectPtrList();
        let distance = convertToTHREE(position).sub(selectedElements[selectedElements.length - 1].getPosition());
        selectedElements.forEach((planElementViewModel) => planObjectPtrList.push_back(planElementViewModel.getPlanElement()));
        const vector3 = convertToKernel(distance);
        const planInteractionHandler = this._getKernelAccess().planInteractionHandler;
        planInteractionHandler.moveObjectsBy(planObjectPtrList, vector3);
        this._sendPlanObjectPositions();
    }
    enableMeasurementLineDrawing() {
        this._roomlePlannerUiCallback.onMeasurementLineStateChange(true);
        this._plannerSceneEventHandler.enableMeasurementLineDrawing();
    }
    disableMeasurementLineDrawing() {
        this._plannerSceneEventHandler.disableMeasurementLineDrawing();
    }
}
__decorate([
    inject
], PlannerSceneManager.prototype, "_rapiAccess", void 0);
__decorate([
    inject
], PlannerSceneManager.prototype, "_plannerMeshGenerator", void 0);
__decorate([
    inject
], PlannerSceneManager.prototype, "_plannerInputManager", void 0);
__decorate([
    inject
], PlannerSceneManager.prototype, "_roomlePlannerUiCallback", void 0);
__decorate([
    inject
], PlannerSceneManager.prototype, "_localStorageHelper", void 0);
__decorate([
    inject
], PlannerSceneManager.prototype, "_unitFormatter", void 0);

const OFFSET = { left: 0, top: 1, right: 1, bottom: 0 };
class RoomlePlanner {
    constructor(creator) {
        this._hscInstance = null;
        this._glbInstance = null;
        this._configurator = null;
        this._currentMode = 1 /* MODE.PLANNER */;
        this._creator_ = creator;
        this._kernelAccessCallback.addListener(this);
    }
    setEnvironmentMap(params) {
        const { url, intensity, rotation, maxLightSources } = params;
        this._sceneManager.setEnvironmentMap(url, intensity, rotation, maxLightSources);
    }
    deleteSelection() {
        this._sceneManager.deletePlanElementSelection();
    }
    /**
     * rotates the selected item(s)
     * @param rotateBy angle in rad
     */
    rotateSelection(rotateBy) {
        this._sceneManager.rotatePlanElementSelection(rotateBy);
    }
    cancelSelection(reason = 'unknown') {
        this._sceneManager.cancelPlanElementSelection(reason);
    }
    init(element, preloadPlanId, options) {
        Benchmark.start('loadingTime');
        this._domHelper.setDomElement(element);
        if (this._sceneManager) {
            this._lifeCycleManager.resume();
            return Promise.resolve();
        }
        this._preloadPlanId = preloadPlanId;
        this.setOverrides(options);
        return new Promise(this._initPromiseCallback.bind(this));
    }
    loadPlanXml(xml, options) {
        this.setOverrides(options);
        return new Promise((resolve) => {
            this._plan = this._planInteractionHandler.loadPlanXML(xml);
            this._sceneManager.planXMLLoaded(this._plan);
            this._roomlePlannerUiCallback.onTotalFloorAreaChanged(this._planInteractionHandler.getPlan().getTotalFloorArea());
            this._currentMode = 1 /* MODE.PLANNER */;
            if (this._initData.moc) {
                if (options.id) {
                    this._rapiAccess.trackView(options.id);
                }
                else {
                    this._rapiAccess.trackView('planXML');
                }
            }
            resolve();
        });
    }
    loadPlan(id, options) {
        this.setOverrides(options);
        return new Promise((resolve, reject) => {
            const isPlanSnapshot = isPlanSnapshotId(id);
            const planPromise = isPlanSnapshot
                ? this._rapiAccess.getPlanSnapshot(id)
                : this._rapiAccess.getPlan(id);
            planPromise.then((plan) => {
                const planObjects = isPlanSnapshot ? plan.plan : plan.planObjects;
                this._plan = this._planInteractionHandler.loadPlanXML(planObjects);
                this._sceneManager.planXMLLoaded(this._plan);
                this._roomlePlannerUiCallback.onTotalFloorAreaChanged(this._planInteractionHandler.getPlan().getTotalFloorArea());
                this._configuratorContext.lastLoadedPlanId = id;
                this._currentMode = 1 /* MODE.PLANNER */;
                if (this._initData.moc) {
                    this._rapiAccess.trackView(id);
                }
                resolve(plan);
            }, reject);
        });
    }
    /**
     * Set general configuration parameter
     * @param initData
     */
    setOverrides(initData) {
        if (!initData) {
            return;
        }
        this._initData.setOverrides(initData);
        this._globalInitData.setOverrides(initData);
    }
    switch2D() {
        this._sceneManager.switchTo2D();
    }
    switch3D() {
        this._sceneManager.switchTo3D();
    }
    switchToFirstPerson() {
        this._sceneManager.switchToFirstPerson();
    }
    resetCameraPosition() {
        this._sceneManager.resetCameraPositionToStart();
    }
    exportGLB() {
        this._sceneManager.exportGLB();
    }
    importGLB(url) {
        this._sceneManager.importGLB(url);
    }
    _initPromiseCallback(resolve, _reject) {
        // three-refactor - ?
        Promise.all([
            this._scriptLoader.fetch(TWEEN_FILE_NAME, { id: 'tween-js' }),
        ]).then(() => {
            this._kernelReadyCallback = resolve;
            const { dls, ls, mode, stats } = this._initData;
            if (!this._sceneManager) {
                this._sceneManager = new PlannerSceneManager(this._creator_, OFFSET, this, mode);
            }
            if (this._preloadPlanId) {
                this._sceneManager.preload(this._preloadPlanId);
            }
            const dynamicLightSettingSource = DynamicLightSettingLoader.createDynamicLightSettingSource(dls, ls);
            if (stats) {
                this.showStats();
            }
            this._sceneManager.enableHD(dynamicLightSettingSource);
            if (this._planInteractionHandler) {
                this._kernelReadyCallback();
            }
        });
        // });
    }
    isReady() {
        this._planInteractionHandler =
            this._plannerKernelAccess.planInteractionHandler;
        if (this._kernelReadyCallback) {
            this._kernelReadyCallback();
        }
    }
    showBenchmarks() {
        Benchmark.showBenchmarks();
    }
    getConfiguratorApi() {
        if (!this._configurator) {
            this._configurator = new RoomleConfigurator(this._creator_);
            this._configurator.setOverrides(this._initData);
            this._configurator.initSceneManager(this._sceneManager);
        }
        return this._configurator;
    }
    startViewing() {
        this._sceneManager.startViewing();
    }
    startConfiguring() {
        var _a, _b;
        const currentSelection = this._sceneManager.currentSelection;
        const id = ((_a = currentSelection.item) === null || _a === void 0 ? void 0 : _a.id) || ((_b = currentSelection.configuration) === null || _b === void 0 ? void 0 : _b.id);
        this._sceneManager.startConfiguring();
        if (id) {
            this._configurator.notifyUiAboutNewLabel(id);
        }
    }
    /**
     * select an object in the scene based on its runtime id
     * @param runtimeId
     */
    async selectPlanObjectById(runtimeId) {
        return this._sceneManager.selectPlanObject(runtimeId);
    }
    backToPlanner() {
        this._sceneManager.backToPlanner();
    }
    showGUI() {
        this._sceneManager.showGUI();
    }
    async switchToConfigurator() {
        const configurator = await this._singlePromiseFactory.create(3 /* PROMISE_CATEGORY.START_HSC */, 'startHSC', (resolve) => {
            if (this._hscInstance) {
                return resolve(this._hscInstance);
            }
            import('./configurator-6ecc8bcb.js').then(({ Configurator: ConfiguratorClass }) => {
                const hsc = new ConfiguratorClass(this._creator_);
                hsc.boot({
                    kernelInstance: this._planInteractionHandler.getConfiguratorKernel(),
                    kernelContainer: this._plannerKernelAccess.kernelContainer,
                });
                hsc.getApi().setOverrides(this._initData);
                hsc.getApi().initSceneManager(this._sceneManager);
                hsc
                    .getApi()
                    .init(this._domHelper.element)
                    .then(() => {
                    this._hscInstance = hsc;
                    resolve(this._hscInstance);
                });
            });
        });
        this._currentMode = 0 /* MODE.CONFIGURATOR */;
        this.cancelSelection();
        return configurator;
    }
    async switchToViewer() {
        const viewer = await this._singlePromiseFactory.create(4 /* PROMISE_CATEGORY.START_GLB */, 'startGLB', (resolve) => {
            if (this._glbInstance) {
                return resolve(this._glbInstance);
            }
            import('./glb-viewer-47b640f5.js').then((GLBViewerModule) => {
                const glb = new GLBViewerModule.GlbViewer(this._creator_);
                glb.boot();
                glb.getApi().setOverrides(this._initData);
                glb
                    .getApi()
                    .init(this._domHelper.element)
                    .then(() => {
                    this._glbInstance = glb;
                    resolve(this._glbInstance);
                });
            });
        });
        this._currentMode = 2 /* MODE.GLB */;
        this.cancelSelection();
        return viewer;
    }
    switchToPlanner(id) {
        if (id) {
            this.loadPlan(id);
        }
        this._currentMode = 1 /* MODE.PLANNER */;
    }
    updateSize() {
        this._sceneManager.updateCamera();
    }
    /**
     * Return the main class which has access to lifecycle events and RapiAccess.
     * Hidden because it's only useful for embedding API.
     * Has to be overridden by main class.
     * @hidden
     */
    getMain() {
        return undefined;
    }
    update() {
        this.updateSize();
        if (this._glbInstance) {
            this._glbInstance.getApi().updateSize();
        }
        if (this._hscInstance) {
            this._hscInstance.getApi().updateSize();
        }
    }
    get callbacks() {
        return this._roomlePlannerUiCallback;
    }
    set callbacks(callback) {
        this._roomlePlannerUiCallback = callback;
    }
    showStats() {
        this._sceneManager.showStats();
    }
    onCloseHSC() {
        this._sceneManager.closeHSC();
        if (this._hscInstance) {
            this._hscInstance.getApi().pauseKernelCallbacks();
        }
    }
    back() {
        if (this._currentMode === 2 /* MODE.GLB */ && this._glbInstance) {
            const roomleGLBViewer = this._glbInstance.getApi();
            roomleGLBViewer.clearScene();
        }
        if (this._currentMode === 0 /* MODE.CONFIGURATOR */ && this._hscInstance) {
            const roomleConfigurator = this._hscInstance.getApi();
            roomleConfigurator.cancelSelection();
            roomleConfigurator.cancelDockings();
            roomleConfigurator.hideDimensions();
            roomleConfigurator.disableMultiselect();
            this._sceneManager.updateScene();
        }
        this._currentMode = 1 /* MODE.PLANNER */;
    }
    backTo(_cssClass) {
        console.error('backTo in planner Needs to be implemented later');
    }
    getConfigurator() {
        return this._hscInstance;
    }
    getCurrentSkin() {
        return this._rapiAccess.getCurrentSkin();
    }
    /**
     * Returns the runtime component id of the plan object with the given id
     * @param planObjectId id of the plan object you want to get the runtime component id of the root component from
     * @return number the number of the runtime id of the root component
     */
    getRuntimeComponentIdOfRootComponent(planObjectId) {
        // Maybe we refactor this to a own class in future
        // abstract class then must have a getConfiguratorKernelMethod and getRuntimeComponentIdOfRootComponent
        // further more we need to think how to deal with planObjectId vs no planObjectId (see roomle-configurator vs roomle-planner)
        if (!planObjectId) {
            console.warn('Can not retrieve runtime id without planObjectId');
            return 0; // Kernel returns 0 if something is invalid, to be same as kernel also return 0 here
        }
        if (!this._plannerKernelAccess.planInteractionHandler) {
            console.warn('Can not retrieve runtime id without planInteractionHandler');
            return 0; // Kernel returns 0 if something is invalid, to be same as kernel also return 0 here
        }
        return this._plannerKernelAccess.planInteractionHandler
            .getConfiguratorKernel()
            .getRootPlanComponentIdFromObjectId(planObjectId);
    }
    /**
     * This method is used for lifecycle tests only
     * @hidden
     */
    resumeTest(element) {
        this._domHelper.setDomElement(element);
        this._lifeCycleManager.resume();
    }
    /**
     * This method is used for lifecycle tests only
     * @hidden
     */
    pauseTest() {
        this._lifeCycleManager.pause();
    }
    syncCatalog(catalogId) {
        return this._dataSyncer.syncCatalog(catalogId);
    }
    loadError(error) {
        console.log(error);
    }
    getPlanInteractionHandler() {
        return Promise.resolve(this._planInteractionHandler);
    }
    getPlanModelViewHelper() {
        return Promise.resolve(this._plannerKernelAccess.planModelViewHelper);
    }
    /**
     * Inserts the object into the scene (at a given position and rotation)
     * @param id
     * @param position x (left/right),y (up, down) and z(front, back) in meters
     * @param rotation in radians
     */
    async insertObject(id, position, rotation) {
        if (!this._planInteractionHandler) {
            throw new Error('no plan interaction handler');
        }
        if (position) {
            position = convertToKernel(new Vector3(position.x, position.y, position.z));
        }
        const rapiItem = await (isIdItemId(id)
            ? this._rapiAccess.getItem(id)
            : this._rapiAccess.getConfiguration(id));
        const object = await this._plannerKernelAccess.addPlanObjectFromItem(rapiItem, position, rotation);
        this._sceneManager.updateScene();
        return object;
    }
    async insertItemList(ids) {
        const mapFun = (id) => {
            const item = isIdItemId(id)
                ? this._rapiAccess.getItem(id)
                : this._rapiAccess.getConfiguration(id);
            return item;
        };
        const itemsPromise = ids.map(mapFun);
        const itemList = await Promise.all(itemsPromise);
        return await this._plannerKernelAccess.insertItems(itemList);
    }
    /**
     * Inserts all of the items in the array into current plan
     * @param itemList Array of items received from the Roomle API
     */
    async insertItems(itemList) {
        return await this._plannerKernelAccess.insertItems(itemList);
    }
    /**
     * Duplicates all planObjects in the array and inserts them into the current plan
     * @param itemList Array of PlanObjects
     */
    duplicateItems(itemList) {
        return this._plannerKernelAccess.duplicateItems(itemList);
    }
    getScene() {
        return this._sceneManager.getScene();
    }
    updateScene() {
        this._sceneManager.updateScene();
    }
    getCameraOffset() {
        return this._sceneManager.getCameraOffset();
    }
    setCameraOffset(offset) {
        this._sceneManager.setCameraOffset(offset);
    }
    /**
     * returns all objects found in the current plan
     * this includes info about size, rotation, id and parts
     */
    async getObjects() {
        const planOverview = (await this.getPlanModelViewHelper()).getPlanOverview(this._plan);
        const planObjects = convertCObject(planOverview.objects);
        return mapToUiPlanObjects(planObjects, this._plannerKernelAccess, this._rapiAccess);
    }
    /**
     * get all info available for the current plan, including objects, rooms and walls
     */
    async getPlanOverview() {
        const planOverview = (await this.getPlanModelViewHelper()).getPlanOverview(this._plan);
        return convertCObject(planOverview);
    }
    /**
     * Generates a top image (birds eye view) and returns it as base64
     * @param options
     */
    prepareTopImage(options = {}) {
        return this._sceneManager.prepareTopImage(options);
    }
    /**
     * Generates a perspective image (slightly from the side) and returns it as base64
     * @param options
     */
    preparePerspectiveImage(options = {}) {
        return this._sceneManager.preparePerspectiveImage(options);
    }
    /**
     * Enables rotation of selected elements
     */
    enableRotation() {
        this._sceneManager.enableRotation();
    }
    /**
     * Disable rotation of selected elements
     */
    disableRotation() {
        this._sceneManager.disableRotation();
    }
    /**
     * Enable the selection of multiple elements.
     * Common parameters shared between those elements can then be changed at once
     */
    enableMultiselect() {
        this._sceneManager
            .getPlannerSceneEventHandler()
            .setSelectionMode("multiselect" /* SELECTION_MODE.MULTISELECT */);
        this._configuratorContext.selectionMode = "multiselect" /* SELECTION_MODE.MULTISELECT */;
    }
    /**
     * Disable the selection of multiple elements.
     */
    disableMultiselect() {
        this._sceneManager
            .getPlannerSceneEventHandler()
            .setSelectionMode("standard" /* SELECTION_MODE.STANDARD */);
        // since we set it in enableMultiselect we need to reset it here
        // there is also an ongoing discussion why we set configuratorContext
        // here in the planner for more details see:
        // https://roomle.slack.com/archives/GQD67DDC5/p1700748062512249
        this._configuratorContext.selectionMode = "standard" /* SELECTION_MODE.STANDARD */;
    }
    async dragInObject(id, dragEvent) {
        this._sceneManager.dragIn(dragEvent);
        const item = await this._rapiAccess.getItem(id);
        const objects = await this.insertItems([item]);
        if (objects.length !== 1) {
            throw new Error('More than one object added, abort');
        }
        return objects[0];
    }
    /**
     * enable snapping of object to object and object to wall
     */
    enableSnapping() {
        this._sceneManager.enableSnapping();
    }
    /**
     * disable all types of snapping
     */
    disableSnapping() {
        this._sceneManager.disableSnapping();
    }
    /**
     * get the Partlist of certain runtimeID
     * can be used if partlist of a selected Item is needed
     * @param id runtimeID of a configurable item
     * @returns kernelPartlist with processed price, currency and RAL colors
     */
    async getPartlistOf(id) {
        const configurationHash = this._plannerKernelAccess.kernelInstance.getHashOfConfiguration(id);
        if (!configurationHash) {
            const warning = 'Object has no partlist because it is not a configuration: ' +
                configurationHash;
            console.warn(warning);
            return Promise.reject(warning);
        }
        const element = this._plannerKernelAccess.kernelInstance.getPartList(id);
        const enhancedPartList = await this._plannerKernelAccess.addUiDataAndPriceToPartList(element, configurationHash);
        return enhancedPartList;
    }
    /**
     * Returns the formatted value based on the parameter.unitType
     *
     * @param value
     * @param parameter
     */
    formatValueToUnitString(value, parameter) {
        return this._unitFormatter.formatValueToUnitString(value, parameter);
    }
    /**
     * Draws walls according to the wall definitions
     * this can be used to create a room on the fly
     */
    drawWalls(wallDefinitions, interactionOptions = {}) {
        var _a, _b;
        const planInteractionHandler = this._planInteractionHandler;
        planInteractionHandler.startInteraction();
        const createdWalls = [];
        for (const wallDefinition of wallDefinitions) {
            const nodeFrom = planInteractionHandler.addNode(wallDefinition.from);
            const nodeTo = planInteractionHandler.addNode(wallDefinition.to);
            const wall = planInteractionHandler.addWall(nodeFrom, nodeTo);
            if (((_a = wallDefinition.props) === null || _a === void 0 ? void 0 : _a.height) !== undefined) {
                planInteractionHandler.setWallHeight(wall, wallDefinition.props.height);
            }
            if (((_b = wallDefinition.props) === null || _b === void 0 ? void 0 : _b.thickness) !== undefined) {
                planInteractionHandler.setWallThickness(wall, wallDefinition.props.thickness);
            }
            createdWalls.push(wall);
        }
        if (!interactionOptions.keepInteractionOpen) {
            planInteractionHandler.endInteraction();
        }
        this._sceneManager.updateCameraOnDrawWalls();
        this._sceneManager.updateScene();
        return createdWalls;
    }
    async removeElements(kernelPlanElements, interactionOptions = {}) {
        this._sceneManager.lockCamera();
        const planInteractionHandler = this._planInteractionHandler;
        for (const element of kernelPlanElements) {
            const planObject = this._sceneManager.getPlanObject(element.getId());
            let planObjects;
            if (planObject) {
                planObjects = await mapToUiPlanObjects([planObject], this._plannerKernelAccess, this._rapiAccess);
            }
            this._roomlePlannerUiCallback.onPlanElementChanged(PLAN_ELEMENT_CHANGE_TYPES.REMOVED, planObjects ? planObjects[0] : null);
            this._planInteractionHandler.removeElement(element);
        }
        if (!interactionOptions.keepInteractionOpen) {
            planInteractionHandler.endInteraction();
        }
        this._sceneManager.unlockCamera();
    }
    hasWalls() {
        const planInteractionHandler = this._planInteractionHandler;
        const plan = planInteractionHandler === null || planInteractionHandler === void 0 ? void 0 : planInteractionHandler.getPlan();
        if (!plan) {
            return false;
        }
        if (plan.getWallCount() < 1) {
            return false;
        }
        return true;
    }
    enableWallDrawing() {
        this._sceneManager.enableWallDrawing();
    }
    disableWallDrawing() {
        this._sceneManager.disableWallDrawing();
    }
    /**
     * returns unit formatter for formatting input und output values in scene
     */
    getUnitFormatter() {
        return this._unitFormatter;
    }
    /**
     * returns manager class to interface with indexedDB storage
     */
    getStorage() {
        return this._idbManager;
    }
    /**
     * returns class containing configurator specific data properties
     */
    getConfiguratorContext() {
        return this._configuratorContext;
    }
    /**
     * @returns an object which has all type constants from Roomle Core (C/C++)
     */
    get PlannerCoreTypes() {
        return this._plannerKernelAccess.kernelContainer;
    }
    /**
     * set which events are enabled in the scene, for example disable selection of walls and wall nodes
     * @param sceneEvents
     */
    setSceneEvents(sceneEvents) {
        this._sceneManager.setSceneEvents(sceneEvents);
    }
    async saveCurrentPlanSnapshot(parentPlanId) {
        const planModelViewHelper = await this.getPlanModelViewHelper();
        const plan = this._planInteractionHandler.getPlan();
        const planOverview = planModelViewHelper.getPlanOverview(plan);
        const snapshot = {
            parentId: parentPlanId || null,
            planObjects: [],
            combinedIds: [],
            plan: plan.getPlanXML(false /** includeRuntimeId */, 2 /** XML version */),
        };
        const objects = planOverview.objects;
        const objectsSize = objects.size();
        for (let i = 0; i < objectsSize; i++) {
            const object = objects.get(i);
            const id = object.configurationHash || object.catalogItemId;
            const { center, dimensions, rotation } = object;
            const locationString = JSON.stringify({ center, dimensions, rotation });
            snapshot.planObjects.push({
                combinedId: id,
                location: locationString,
            });
        }
        const planSnapshot = await this._rapiAccess.savePlanSnapshot(snapshot);
        const result = new Promise((resolve, reject) => {
            // use .then so everything runs in parallel (NOT TRUE CURRENTLY, see below)
            // switch back to serial request until backend is ready
            // for more detail see here: https://roomle.atlassian.net/browse/RML-8113
            // to handle parallel requests: https://roomle.atlassian.net/browse/RML-8163
            /* this was the parallel version:
              const result = new Promise<RapiPlanSnapshotGetData>((resolve, reject) => {
                let perspectiveImageSaved: RapiPlanSnapshotGetData = null;
                let topImageSaved: RapiPlanSnapshotGetData = null;
                // use .then so everything runs in parallel
                this.preparePerspectiveImage().then(
                  (image) =>
                    this._rapiAccess
                      .savePlanSnapshotPerspectiveImage(planSnapshot, image)
                      .then((data) => {
                        perspectiveImageSaved = data;
                        if (topImageSaved) {
                          data.topImage = topImageSaved.topImage;
                          resolve(data);
                        }
                      }, reject),
                  reject
                );
                // use .then so everything runs in parallel
                this.prepareTopImage().then(
                  (image) =>
                    this._rapiAccess
                      .savePlanSnapshotTopImage(planSnapshot, image)
                      .then((data) => {
                        topImageSaved = data;
                        if (perspectiveImageSaved) {
                          data.perspectiveImage = topImageSaved.perspectiveImage;
                          resolve(data);
                        }
                      }, reject),
                  reject
                );
              });
            */
            Promise.allSettled([
                this.preparePerspectiveImage(),
                this.prepareTopImage(),
            ]).then(async ([perspectiveImage, topImage]) => {
                if (perspectiveImage.status === 'rejected' ||
                    topImage.status === 'rejected') {
                    reject('Could not generate images of plan snapshot');
                    return;
                }
                try {
                    const responsePerspectiveImage = await this._rapiAccess.savePlanSnapshotPerspectiveImage(planSnapshot, perspectiveImage.value);
                    const responseTopImage = await this._rapiAccess.savePlanSnapshotTopImage(planSnapshot, topImage.value);
                    resolve({ ...responsePerspectiveImage, ...responseTopImage });
                }
                catch (e) {
                    reject(e);
                }
            });
        });
        try {
            return await result;
        }
        catch (e) {
            console.error(e);
            return planSnapshot;
        }
    }
    getPlanXmlFrom(plan) {
        if (!plan) {
            return null;
        }
        return isPlanSnapshotId(plan.id) ? plan.plan : plan.planObjects;
    }
    async moveCamera(cameraParameter) {
        return this._sceneManager.moveCamera(cameraParameter);
    }
    async createNewSerializedConfiguration(configurationRuntimeId) {
        return Promise.resolve(this._plannerKernelAccess.createNewSerializedConfiguration(configurationRuntimeId));
    }
    changeInteriorWallsMaterial(material) {
        this._sceneManager.changeInteriorWallsMaterial(material);
    }
    changeExteriorWallsMaterial(material) {
        this._sceneManager.changeExteriorWallsMaterial(material);
    }
    changeFloorsMaterial(material) {
        this._sceneManager.changeFloorsMaterial(material);
    }
    /**
     * Returns the wall angle in degrees relative to the camera
     * @param wall a WallPlanElementViewModel instance
     */
    getWallAngleDegrees(wall) {
        return this._sceneManager.getWallAngleDegrees(wall);
    }
    calcPartsPriceSum(partList) {
        return this._plannerKernelAccess.calcPartsPriceSum(partList);
    }
    /**
     * Swap two plan objects in the scene in the same position for example swap two object variants
     * @param old this is the current selected plan object
     * @param idOfNew the RAPI id of the new plan object
     * returns runtime ID of the new object
     */
    async swapObject(old, idOfNew) {
        const pos = old.getPosition();
        const rot = old.getRotation();
        await this._sceneManager.deletePlanElementByIds([
            old.getPlanElement().getId(),
        ]);
        this.cancelSelection('swap_object');
        return await this.insertObject(idOfNew, pos, rot);
    }
    exportImageFromCamera(filename = 'image') {
        this._sceneManager.exportImageFromCamera(filename);
    }
    /**
     * Move the current selected element in the 3D space
     * @param selectedElement this is the current selected plan object
     * @param position new KernelVector3 position of the current selected element
     * returns runtime ID of the new object
     */
    moveElementPosition(selectedElement, position) {
        this._sceneManager.moveElementPosition(selectedElement, position);
    }
    /**
     * Moves the current multi-selected elements in the 3D space
     * @param selectedElements this is the current selected plan object
     * @param position new KernelVector3 position of the current selected element
     * returns runtime ID of the new object
     */
    moveElementsPosition(selectedElements, position) {
        this._sceneManager.moveElementsPosition(selectedElements, position);
    }
    /**
     * Generates a perspective image (slightly from the side) of a plan element by a
     * given runtime-id and returns it as base64
     * @param runtimeId runtime-id of the plan element, e.g.: a selected element
     * @param options PrepareImageOptions
     */
    preparePerspectiveImageOf(runtimeId, options = {}) {
        return this._sceneManager.preparePerspectiveImageOf(runtimeId, options);
    }
    async generateTCExport(planObjectIds = []) {
        try {
            const stringArray = new this._plannerKernelAccess.kernelContainer.StringArray();
            for (const id of planObjectIds) {
                stringArray.push(id);
            }
            return Promise.resolve(JSON.parse(this._planInteractionHandler.generateTCExport(stringArray)));
        }
        catch (e) {
            console.error(e);
            return Promise.reject('Could not create Blue Ocean MVP JSON');
        }
    }
    enableMeasurementLineDrawing() {
        this._sceneManager.enableMeasurementLineDrawing();
    }
    disableMeasurementLineDrawing() {
        this._sceneManager.disableMeasurementLineDrawing();
    }
}
__decorate([
    inject
], RoomlePlanner.prototype, "_configuratorContext", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_domHelper", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_scriptLoader", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_kernelAccessCallback", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_plannerKernelAccess", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_rapiAccess", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_singlePromiseFactory", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_roomlePlannerUiCallback", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_lifeCycleManager", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_dataSyncer", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_initData", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_idbManager", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_globalInitData", void 0);
__decorate([
    inject
], RoomlePlanner.prototype, "_unitFormatter", void 0);

class PlannerInputManager extends InputManager {
    _canDrag(_type) {
        return true;
    }
}

const INJECTABLES = [
    new DependencyInjectionAssignment('script-loader', ScriptLoader),
    new DependencyInjectionAssignment('planner-input-manager', PlannerInputManager, 1 /* DI_TYPE.CONTEXT */),
    new DependencyInjectionAssignment('logger', Logger),
    new DependencyInjectionAssignment('planner-mesh-generator', PlannerMeshGenerator),
    new DependencyInjectionAssignment('rapi-access', RapiAccess),
    new DependencyInjectionAssignment('planner-selection-handler', PlannerSelectionHandler),
];

class Planner extends Main {
    setupGlobals() {
        //globals are initialized in bootFinished()
    }
    setupDependencies() {
        RoomleDependencyInjection.setup(INJECTABLES);
        this.lookup('logger', this._context);
        // instantiate kernel acccess
        // instantiate pka
        // set pka on kernel access
        const plannerKernelAccess = this.lookup('planner-kernel-access', this._context);
        plannerKernelAccess.init(0 /* KERNEL_TYPE.PLANNER */);
    }
    cleanUpGlobals() {
        throw new Error('Method not implemented.');
    }
    cleanUpDependencies() {
        throw new Error('Method not implemented.');
    }
    bootFinished() {
        this._planner = new RoomlePlanner(this._context);
        this._planner.getMain = () => {
            return this;
        };
        if (!window.RoomlePlanner) {
            window.RoomlePlanner = this._planner;
        }
    }
    getApi() {
        return this._planner;
    }
    getContextName() {
        return "planner" /* BASE_CONTEXT.PLANNER */;
    }
}

export { Planner };
//# sourceMappingURL=planner-6b5576c8.js.map
